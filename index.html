<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>AI小手机</title>
    
    <style>
        /* 先做一些准备工作，让页面表现更统一 */
     /* 准备工作 - 移除居中，改为全屏填充 */
body {
    margin: 0;
    padding: 0; /*  确保没有内边距 */
    font-family: sans-serif;
    /* 【删除】不再需要 flex 居中 */
    /* display: flex;
    justify-content: center;
    align-items: center; */
    min-height: 100vh;
    background-color: #000; /* 【修改】背景改为黑色，更像真手机 */
    overflow: hidden; /*  防止页面滚动 */
}


   /* 手机屏幕的整体样式 - 响应式全屏版本 */
.phone-screen {
    /* 【关键修改】使用视口单位实现全屏 */
    width: 100vw;
    height: 100vh;
    /* 【兼容性修复】使用 CSS 变量应对移动端浏览器地址栏 */
    height: calc(var(--vh, 1vh) * 100);
    
    background-color: #ffffff;
    border-radius: 0px; /* 全屏不需要圆角 */
    box-shadow: none; /* 全屏不需要阴影 */
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    
    /* 保留原有的背景设置 */
    background-image: url('https://i.pinimg.com/564x/8b/2c/3a/8b2c3ae5123519a797f66a1a1f3b39d1.jpg');
    background-size: cover;
    background-position: center;
}


   /* 状态栏的样式 */
        .status-bar {
            /* 修改这里：减少上下内边距，让它更靠上 */
            padding: 10px 25px;
     
            font-weight: bold;
            color: #333;
      
            /* 添加下面两行：重新请回我们的“交通指挥员” */
            display: flex;
            justify-content: space-between; /* 这句代码就是魔法！它命令里面的元素一个靠左，一个靠右 */
        }
        /* 在这里添加新代码：时间组件的样式 */
        .time-widget {
            color: #333;
            text-align: center;
            padding: 20px 0;
            text-shadow: 0 1px 3px rgba(0,0,0,0.1); /* 给文字加一点点阴影 */
           cursor: pointer;
        }
        .time-widget p {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }
        .time-widget h1 {
            margin: 0;
            font-size: 72px; /* 超大字号 */
            font-weight: bold;
            letter-spacing: 2px;
        }

        /* 中间App区域的网格布局 */
        .app-grid {
            flex-grow: 1; /* 让它占据所有剩余空间 */
            padding: 20px;
            display: grid;
            /* ↓↓↓ 把下面这一行改掉 ↓↓↓ */
            grid-template-columns: 75px 75px 1fr 1fr; /* 前两列固定宽度，后两列平分剩余空间 */
            gap: 15px; /* 设置图标之间的间距 */
            align-content: flex-start; /* 让图标从顶部开始排列 */
        }

        /* 单个App图标的样式 */
        .app-icon {
            display: flex;
            flex-direction: column; /* 图标和文字垂直排列 */
            align-items: center; /* 水平居中 */
            text-align: center;
        }

        /* 图标的占位符样式 */
        .app-icon .icon-placeholder {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7); /* 半透明的白色背景 */
            border-radius: 15px; /* 图标的圆角 */
            margin-bottom: 8px; /* 和下方文字的间距 */
            backdrop-filter: blur(10px); /* 毛玻璃效果，非常重要！ */
            -webkit-backdrop-filter: blur(10px); /* 兼容Safari浏览器 */
            border: 1px solid rgba(255, 255, 255, 0.2); /* 加一个细微的边框 */
        }
/* 图标的占位符样式 */
.app-icon .icon-placeholder {
    width: 60px;
    height: 60px;
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 15px;
    margin-bottom: 8px;
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/*  自定义图标的专属样式 */
.app-icon .icon-placeholder.custom-icon {
    background-size: cover !important;
    background-position: center !important;
    background-repeat: no-repeat !important;
    overflow: hidden;
}

.app-icon .icon-placeholder.custom-icon svg {
    display: none !important;
}

        /* App名字的样式 */
        .app-icon span {
            color: #333;
            font-size: 12px;
            font-weight: 500;
        }

        /* 底部Dock栏的样式 */
        .dock {
            width: calc(100% - 40px); /* 宽度比屏幕稍窄 */
            margin: 0 auto 20px auto; /* 底部外边距，并水平居中 */
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.7); /* 和图标一样的半透明背景 */
            backdrop-filter: blur(15px); /* 毛玻璃效果 */
            -webkit-backdrop-filter: blur(15px);
            border-radius: 25px; /* 更圆的圆角 */
            display: flex;
            justify-content: space-around; /* 让里面的App图标均匀分布 */
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

 /* 弹窗背景的样式 */
        .popup {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* 半透明的黑色遮罩 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100; /* 确保在最上层 */
        }

/* 弹窗内容的样式 */
       .popup-content {
            background-color: #ffffff; /* 【修改】1. 改成纯白色 */
            /* 【删除】2. 不再需要毛玻璃效果了 */
            /* backdrop-filter: blur(15px); */
            /* -webkit-backdrop-filter: blur(15px); */
            border: 1px solid #ccc; /* 【修改】3. 换成一个更清晰的灰色边框 */
            
            padding: 20px 25px; 
            border-radius: 25px; 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 290px; 
            text-align: center;
            position: relative;
            max-height: 300px; 
            overflow-y: auto;  
        }
        .popup-content h3 {
            margin-top: 0;
        }

        /* --- 为“添加联系人”弹窗添加新的“不透明”样式 --- */
        

        /* 1. 这是弹窗的黑色背景遮罩，我们把它改成不透明的深灰色 */
        .popup.solid-popup {
             background-color: rgba(0, 0, 0, 0.4); /* 一个普通的暗色遮罩 */
             z-index: 220; /* <-- 【修复Bug 1】添加这行，让它的层级高于 210 */
        }

        /* 2. 这是弹窗内容框的核心样式 */
        .popup-content.solid-popup-content {
            background-color: #ffffff;  /* 1. 明确的纯白色背景（不是半透明）*/
            backdrop-filter: none;      /* 2. 明确禁用毛玻璃 */
            -webkit-backdrop-filter: none;
            border: 1px solid #ccc;     /* 3. 加一个普通的边框 */
            width: 250px;               /* 4. 【修复Bug 2】把宽度改小 */
            max-height: 350px;          /* 5. 【修复Bug 2】把最大高度改小 */
            overflow-y: auto;           /* 6. 关键：如果内容超出，允许垂直滚动！ */
            padding: 20px 25px;
            text-align: left; /* 内容改为左对齐，更像表单 */
        }
        
        /* 7. 弹窗里的头像预览样式 */
        .avatar-preview-container {
            display: flex;
            justify-content: center; /* 居中预览图 */
            margin-bottom: 15px;
        }
        #contact-avatar-preview {
            width: 100px;
            height: 100px;
            border-radius: 50%; /* 圆形头像 */
            object-fit: cover;
            border: 3px solid #eee;
            background-color: #f9f9f9;
        }

        /* 8. 弹窗里的文本输入框（确保它们100%宽度）*/
        .solid-popup-content .setting-item input[type="text"] {
            width: calc(100% - 20px); /* 继承我们已有的输入框样式(有padding) */
        }
        
        /* 9. 弹窗里的人设文本域样式 */
        .solid-popup-content textarea {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            font-family: sans-serif; /* 确保字体统一 */
            font-size: 14px;
            resize: vertical; /* 只允许用户垂直调整大小 */
           overflow-y: auto; 
        }
        
        /* --- 新弹窗CSS添加结束 --- */

        /* 输入框和按钮的组合样式 */
        .input-group {
            display: flex;
            margin: 15px 0;
        }
        .input-group input {
            flex-grow: 1; /* 占据剩余空间 */
            border: 1px solid #ccc;
            border-radius: 5px 0 0 5px;
            padding: 8px;
        }
        .input-group button {
            border: none;
            background-color: #007aff;
            color: white;
            padding: 8px 12px;
            border-radius: 0 5px 5px 0;
            cursor: pointer;
        }
/* 按钮容器 - 固定在顶部，按钮靠右 */
#persona-buttons {
    flex-shrink: 0;
    padding: 10px 15px;
    border-bottom: 1px solid #e0e0e0; /* 改成浅灰色，不要用深色 */
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    /*  确保它不影响父容器 */
    width: 100%;
    box-sizing: border-box;
}

   /* 上传文件按钮的样式 */
        .file-label {
            display: block;
            width: 100%;
            padding: 10px 0;
            /* 修改这里：背景色更柔和，并增加过渡效果 */
            background-color: rgba(76, 217, 100, 0.8);
            color: white;
            border-radius: 8px; /* 圆角和输入框统一 */
            cursor: pointer;
            margin: 15px 0;
            transition: background-color 0.3s; /* 动画过渡效果 */
        }
        /* 添加一个鼠标悬停效果 */
        .file-label:hover {
            background-color: rgba(76, 217, 100, 1);
        }
        
        /* 关闭按钮的样式 */
        .close-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }

        /* 一个用来隐藏元素的万能样式 */
        .hidden {
            display: none !important;
        }

 /* 主题设置界面的主容器样式 */
        .theme-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(240, 240, 240, 0.9); /* 一个柔和的背景色 */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 200; /* 比弹窗层级更高 */
            display: flex;
            flex-direction: column;
        }
  /* --- 添加下面的新代码：为设置页面添加完全相同的样式 --- */
        .settings-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(240, 240, 240, 0.9); 
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 200; /* 和主题页层级一样高 */
            display: flex;
            flex-direction: column;
        }
        /* --- 添加结束 --- */
       /* --- 为“对话”功能添加全新的CSS样式 --- */
/* 【新添加】让设置页面的内容区可以滚动 */
.theme-content {
    padding: 20px;
    flex-grow: 1;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}
        /* 1. 为两个新屏幕设置和 theme/settings 一样的全屏基础样式 */
        .dialogue-list-screen,
        .chat-window-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f0f0; /* 对话页用一个浅灰色背景 */
            z-index: 210; /* 比设置页层级更高，确保能覆盖 */
            display: flex;
            flex-direction: column;
             /* 把背景换成白色，更像聊天软件 */
            background-color: #ffffff;
        }

        /* 2. 导航栏右上角的“新建”按钮 */
        .nav-action-btn {
            background: none;
            border: none;
            font-size: 32px; /* 字体放大，让加号更清晰 */
            font-weight: lighter; /* 用细一点的字体 */
            cursor: pointer;
            color: #007aff; /* 苹果蓝 */
            position: absolute;
            right: 15px; /* 把它钉在右上角 */
            top: 50%;
            transform: translateY(-50%); /* 垂直居中 */
        }
        .nav-action-btn:hover {
            opacity: 0.7;
        }
  /* --- 从这里添加新代码：专门缩小“联系人”页面的标题字体 --- */
        .dialogue-list-screen .theme-nav h2 {
            font-size: 16px; /* 默认的h2太大了，我们把它改小一点 */
        }
        /* --- 添加结束 --- */
      <!-- ======================================================= -->
<!-- 【新增】朋友圈页面 -->
<!-- ======================================================= -->
<div class="moments-screen hidden">
    <nav class="theme-nav">
     
        <h2>朋友圈</h2>
        <button id="moments-add-btn" class="nav-action-btn">+</button>
    </nav>
    
    <div class="moments-content" id="moments-content">
        <p class="empty-list-message">暂无动态，点击右上角 + 号发布第一条动态</p>
    </div>
    
    <!-- 复用底部标签栏 -->
    <div class="bottom-tab-bar">
        <button class="tab-btn" id="tab-contacts-2">
            <span>联系人</span>
        </button>
        <button class="tab-btn" id="tab-moments-2">
            <span>朋友圈</span>
        </button>
    </div>
</div>

/* 强制设置聊天窗口标题的字体大小 */
#chat-window-title {
    font-size: 16px !important; /* 改成你想要的大小 */
}
  /* 【强制修复】聊天窗口标题字体 */
.chat-window-screen .theme-nav h2 {
    font-size: 16px !important;
    font-weight: normal !important;
}    
         /* --- 从这里开始添加“联系人列表项”的新样式 --- */
        
        .contact-list-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0; /* 列表项之间的分隔线 */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .contact-list-item:hover {
            background-color: #f9f9f9; /* 鼠标悬停效果 */
        }

        /* 列表项的头像 */
        .contact-item-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%; /* 圆形头像 */
            object-fit: cover; /* 确保图片不变形 */
            margin-right: 15px;
            background-color: #eee;
        }
        
        /* 列表项的文字信息区 */
        .contact-item-info {
            flex-grow: 1;
            /* 下面三行是防止文字溢出的关键 */
            overflow: hidden;
            white-space: nowrap;
        }

        /* 列表项的名字 */
        .contact-item-name {
            margin: 0;
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        
        /* 列表项的预览文字 (放“最后消息”或“人设”的地方) */
        .contact-item-preview {
            margin: 0;
            margin-top: 4px;
            font-size: 14px;
            color: #666;
            /* 确保单行溢出时显示省略号 ... */
            overflow: hidden;
            text-overflow: ellipsis; 
        }

        /* --- 新样式添加结束 --- */
      
        /* 3. 对话列表的内容区 */
        .dialogue-list-content {
            flex-grow: 1; /* 占据所有剩余空间 */
            overflow-y: auto; /* 如果列表长了可以滚动 */
            padding: 10px;
        }
        
        /* 4. 列表为空时的提示文字 */
        .empty-list-message {
            text-align: center;
            margin-top: 50px;
            color: #999;
            font-size: 14px;
        }

        /* 5. 聊天消息容器 (最关键的区域) */
.message-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    background-color: #f9f9f9; /* 默认背景色 */
    position: relative;
    background-size: cover; /*   */
    background-position: center; /*   */
    background-attachment: fixed; /*  关键：背景固定不滚动 */
}

        /* 6. 底部输入框的容器 */
        .dialogue-input-area {
            display: flex;
            padding: 10px 15px;
            border-top: 1px solid #e0e0e0;
            background-color: #ffffff;
            gap: 10px;
        }

        /* 7. 底部输入框的样式 */
        .dialogue-input-area input {
            flex-grow: 1; /* 占据大部分空间 */
            border: 1px solid #ccc;
            border-radius: 18px; /* 圆角输入框 */
            padding: 8px 15px;
            font-size: 16px;
            outline: none;
        }
        /* 8. 底部“发送”按钮的样式 */
        .dialogue-input-area button {
            border: none;
            background-color: #007aff;
            color: white;
            padding: 8px 15px;
            border-radius: 18px;
            cursor: pointer;
            font-weight: bold;
        }
        .dialogue-input-area button:hover {
            opacity: 0.8;
        }

        /* 9. 聊天气泡的基础样式 */
.message-bubble {
    max-width: 80%;
    padding: 10px 15px;
    border-radius: 18px;
    word-wrap: break-word;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    position: relative;
    z-index: 1;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

        /* 10. 用户发出的消息 (右边, 蓝色) */
        .user-message {
            background-color: #007aff;
            color: white;
            align-self: flex-end; /* 关键：把自己对齐到右边 */
            border-bottom-right-radius: 5px; /* 一点点小造型 */
        }

        /* 11. 机器人回复的消息 (左边, 灰色) */
        .bot-message {
            background-color: #e5e5ea;
            color: #000;
            align-self: flex-start; /* 关键：把自己对齐到左边 */
            border-bottom-left-radius: 5px;
        }

        /* --- “对话”功能CSS样式添加结束 --- */
        /* 顶部导航栏 */
        .theme-nav {
            display: flex;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            position: relative; 
        }
        .theme-nav h2 {
            margin: 0;
            flex-grow: 1;
            text-align: center;
            color: #333;
        }
      /* 【新增】朋友圈页面标题字体大小 */
.moments-screen .theme-nav h2 {
    font-size: 16px !important;  /* 改成你想要的大小，比如 18px, 22px, 24px */
}

/* 【新增】用户主页标题字体大小 */
.user-profile-screen .theme-nav h2 {
    font-size: 16px !important;  /* 改成你想要的大小 */
}

        .back-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            color: #555;
            position: absolute; /* 确保标题能完美居中 */
        }
        
        /* 功能内容区 */
        .theme-content {
            padding: 20px;
        }

        /* 手风琴菜单样式 */
        .accordion-item {
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        .accordion-header {
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            color: #333;
        }
        .accordion-header .arrow {
            font-family: monospace; /* 让箭头更清晰 */
            transition: transform 0.3s; /* 箭头旋转动画 */
        }
.accordion-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
    display: flex;
    flex-direction: column;
    padding: 0; /* 【关键】确保没有内边距影响 */
}

.accordion-content.expanded {
    max-height: 500px;
    overflow: visible;
    padding: 15px; /*  只有展开时才有内边距 */
}



      
.accordion-content.expanded {
   max-height: none; /* 改成 none，不限制高度 */
    overflow: visible; /* 改成 visible，不滚动 */
}
/* ===== 【在这里添加】===== */

#accordion-content-3.expanded {
    max-height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
     padding: 15px;
}

/*  确保折叠时高度为0 */
#accordion-content-3 {
    max-height: 0;
    overflow: hidden;
}

}
/* ======================== */
      
        /* 当展开时，箭头旋转90度 */
        .accordion-header.expanded .arrow {
            transform: rotate(90deg);
        }

        /* 设置项的内部样式 */
        .setting-item {
            margin-bottom: 15px;
        }
        .setting-item label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
        }
        .setting-item input {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
        }

        /* 按钮组样式 */
        .button-group {
            display: flex;
            justify-content: flex-end; /* 按钮靠右 */
            gap: 10px; /* 按钮之间的间距 */
            margin-top: 20px;
        }
        .button-group button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.3s;
        }
        .button-group button:hover {
            opacity: 0.8;
        }
        .btn-clear {
            background-color: #eee;
            color: #555;
        }
        .btn-save {
            background-color: #007aff;
            color: white;
        }

        /* 用于隐藏主屏幕元素的样式 */
        .home-screen-hidden {
            display: none !important;
        }

      /* --- 在这里开始添加下面的新代码 --- */

        /* 滑块组合的样式 */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 15px; /* 滑块和文字的间距 */
        }
        .slider-group input[type="range"] {
            flex-grow: 1; /* 让滑块占据大部分空间 */
            cursor: pointer;
        }
        .slider-group span {
            font-weight: bold;
            color: #555;
            width: 40px; /* 固定宽度防止文字跳动 */
        }  
       /* --- 在这里开始添加下面的新代码 --- */

        /* 单独为顶部文字的span设置样式 */
        .status-bar span {
            /* 1. 设置一个浏览器不会抗拒的基准字体大小 */
            font-size: 15px;
            /* 2. 添加过渡效果，让缩放更平滑 */
            transition: transform 0.1s;
        }
        /* 设置左边文字的缩放中心点为左边 */
        #top-left-text {
            transform-origin: left center;
        }
        /* 设置右边文字的缩放中心点为右边 */
        #top-right-text {
            transform-origin: right center;
        }

   /* 小组件的通用样式 */
        .widget {
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            /* ↓↓↓ 修改这里：减少上下内边距，让它变矮 ↓↓↓ */
  
            box-sizing: border-box; /* 确保内边距不会撑大盒子 */
            color: #333;
            /* ↓↓↓ 添加这行：让它在自己的格子里垂直居中 ↓↓↓ */
     
        }

            /* 关键！让2x1的小组件占据2列宽度 */
        .widget-2x1 {
            grid-column: span 2; /* 这就是让它变胖的魔法指令！ */
        }

        /* --- 在这里开始添加下面的新代码 --- */

    /* 新增！让3x2的大组件占据3行高度 */
        .widget-3x2 {
            grid-column: span 2; 
            grid-row: span 3;    
            
            display: flex;
            flex-direction: column; /* 内部元素垂直排列 */
            padding: 2px; /* 调整整体内边距 */
          
        }

        /* 小组件内部文字的简单美化 */
        .widget h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        .widget p {
            margin: 0;
            font-size: 16px;
        }
      /* --- 在这里开始添加下面的新代码 --- */

        /* 组件背景图容器 */
        .widget-bg {
            flex-grow: 1; /* 占据组件内所有可用空间 */
            background-color: #eee; /* 默认背景色 */
            background-size: cover; /* 让背景图铺满 */
            background-position: center; /* 背景图居中 */
            border-radius: 15px; /* 圆角与组件整体风格保持一致 */
            margin-bottom: 10px; /* 和下方文字的间距 */
            position: relative; /* 为头像的绝对定位做准备 */
            display: flex; /* 让头像居中 */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* 防止背景图超出容器 */
        }

        /* 头像样式 */
        .widget-avatar {
            width: 95px; /* 头像大小 */
            height: 95px;
            border-radius: 50%; /* 变成圆形 */
            margin-top: 30px; 
            border: 3px solid rgba(255, 255, 255, 0.8); /* 白色描边 */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* 阴影 */
            object-fit: cover; /* 确保图片不变形铺满 */
            z-index: 1; /* 确保头像在背景图上方 */
        }

        /* 底部自定义文字样式 */
        .widget-text {
            margin: 0;
            font-size: 14px;
            color: #333;
            text-align: center;
            white-space: nowrap;      
            overflow: hidden;         
            text-overflow: ellipsis;  
        }
      /* --- 在这里开始添加下面的新代码 --- */

        /* 编辑器内部区域划分 */
        .editor-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        .editor-section:last-of-type {
            border-bottom: none; /* 最后一个区域不需要下划线 */
        }
        .editor-section h4 {
            margin: 0 0 10px 0;
            text-align: left;
            color: #333;
            font-size: 16px;
        }
        /* 让编辑器里的URL输入框和文字输入框宽度100% */
        .editor-section .input-group input {
            border-radius: 8px; /* 给它加上圆角 */
            width: 100%;
            box-sizing: border-box;
        }
      /* --- 在这里开始添加下面的新代码 --- */

        /* 黑夜模式的切换开关样式 */
        .toggle-switch {
            background-color: #e9e9eb;
            border-radius: 20px;
            padding: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .toggle-label {
            color: #8e8e93;
            font-weight: bold;
            padding: 0 15px;
        }
        .toggle-handle {
            background-color: white;
            width: 50%;
            height: 32px;
            border-radius: 18px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
            position: absolute;
            left: 4px;
            transition: left 0.3s ease; /* 滑动动画 */
        }
        /* 当开关被激活(切换到右边)时的样式 */
        .toggle-switch.active .toggle-handle {
            left: calc(50% - 4px);
        }

        /* 关键！黑夜模式的皮肤定义 */
               .phone-screen.dark-mode .status-bar,
        .phone-screen.dark-mode .time-widget,
        .phone-screen.dark-mode .app-grid .app-icon span 
        {
            color: white; /* 所有相关文字变白 */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5); /* 给白字加点阴影，更好看 */
        }
      
    
 /* --- 在这里开始添加下面的新代码 --- */

    /* 2x0.5 “半高”小卡片的样式 */
        .widget-2x1-slim {
            grid-column: span 2; 
            height: 35px; 
            align-self: center; 
            display: flex;
            justify-content: center;
            align-items: center;
            background-size: cover;
            background-position: center;
            cursor: pointer; 
            border-radius: 12px;
            /* --- 在这里添加下面这行新的内边距 --- */
            padding: 0 10px; /* 只给左右内边距，上下为0 */
        }

        /* 小卡片内部文字的样式 */
        .widget-2x1-slim .widget-text-slim {
            margin: 0;
            padding: 0 10px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        
            white-space: nowrap;      
            overflow: hidden;         
            text-overflow: ellipsis;  
        }
      /* --- 添加下面的新样式代码 --- */
        #widget-text-color-input {
            width: 50px;           /* 给它一个固定宽度，让它大一点 */
            height: 35px;          /* 给它一个固定高度 */
            padding: 0;            /* 移除浏览器默认的奇怪内边距 */
            border: 1px solid rgba(0, 0, 0, 0.1); /* 给它一个干净的细边框 */
            border-radius: 8px;    /* 把它也变成圆角，和我们App风格统一！ */
            cursor: pointer;       /* 鼠标悬停时显示小手 */
            background-color: transparent; /* 移除某些浏览器上默认的灰色背景 */
        }

   



      /* ============================================= */
/* 【新添加】"我"页面的样式 */
/* ============================================= */

/* 人设列表项 */
.persona-list-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    background-color: white;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}

.persona-list-item:hover {
    background-color: #f9f9f9;
}

.persona-item-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
    margin-right: 15px;
    background-color: #eee;
}

.persona-item-info {
    flex-grow: 1;
    overflow: hidden;
}

.persona-item-name {
    margin: 0;
    font-size: 16px;
    font-weight: bold;
    color: #333;
}

.persona-item-desc {
    margin: 4px 0 0 0;
    font-size: 14px;
    color: #666;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.persona-item-delete {
    background-color: #ff3b30;
    color: white;
    border: none;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    font-weight: bold;
    cursor: pointer;
}

      /* ============================================= */
/* 【新添加】世界书功能的 CSS 样式 */
/* ============================================= */

/* 1. 分类管理器页的列表项 (例如: "人物 [X]") */
.category-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 10px;
    background-color: #f9f9f9;
    border-radius: 8px;
    margin-bottom: 8px;
    font-weight: 500;
}

/* 2. 分类列表项的“删除 X”按钮 */
.category-delete-btn {
    background-color: #ff3b30; /* 红色 */
    color: white;
    border: none;
    border-radius: 50%; /* 圆形 */
    width: 24px;
    height: 24px;
    font-weight: bold;
    cursor: pointer;
    line-height: 24px; /* 辅助垂直居中 */
    text-align: center;
    padding: 0;
}

/* 3. 世界书主页的“条目”列表项 (我们复用联系人样式) */
.worldbook-entry-item {
    display: flex;
    align-items: center;
    padding: 10px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
    position: relative; /* 为“长按”做准备 */
}
.worldbook-entry-item:hover {
    background-color: #f9f9f9;
}

/* 4. 条目列表的“图标” (我们用分类的首字母) */
.entry-item-icon {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    margin-right: 15px;
    background-color: #007aff; /* 蓝色底 */
    color: white;
    font-size: 24px;
    font-weight: bold;
    /* Flex 居中 */
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0; /* 防止被压缩 */
}

/* 5. 条目列表的文字信息 (和联系人一样) */
.entry-item-info {
    flex-grow: 1;
    overflow: hidden;
    white-space: nowrap;
}
.entry-item-name {
    margin: 0;
    font-size: 16px;
    font-weight: bold;
    color: #333;
}
/* 我们把分类名显示在预览区 */
.entry-item-category {
    margin: 0;
    margin-top: 4px;
    font-size: 14px;
    color: #666;
    overflow: hidden;
    text-overflow: ellipsis; 
}
      /* ============================================= */
/* 【新添加】联系人设置 & 世界书关联页 CSS */
/* ============================================= */

/* 1. 让设置页的返回按钮和...按钮对齐 */
#contact-settings-btn {
    position: absolute;
    right: 15px;
    top: 50%;
    transform: translateY(-50%);
}

/* 2. 世界书关联页的列表项样式 */
.linker-item {
    display: flex;
    align-items: center;
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
}

/* 3. 关联项的“复选框”样式 (我们用 CSS 模拟) */
.linker-item-checkbox {
    width: 24px;
    height: 24px;
    border: 2px solid #ccc;
    border-radius: 50%; /* 圆形复选框 */
    margin-right: 15px;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.2s;
    flex-shrink: 0;
}

/* 4. 当被选中时，改变复选框样式 */
.linker-item-checkbox.checked {
    background-color: #007aff;
    border-color: #007aff;
}
/* 5. 选中时，中间的“对勾” (用 CSS 画) */
.linker-item-checkbox.checked::after {
    content: '';
    width: 6px;
    height: 12px;
    border: solid white;
    border-width: 0 3px 3px 0;
    transform: rotate(45deg) translate(-1px, -1px);
}

/* 6. 关联项的文字样式 (我们复用之前的) */
.linker-item-info {
    flex-grow: 1;
    overflow: hidden;
    white-space: nowrap;
}
.linker-item-name {
    margin: 0;
    font-size: 16px;
    font-weight: bold;
    color: #333;
}
.linker-item-category {
    margin: 0;
    margin-top: 4px;
    font-size: 14px;
    color: #666;
}

/* 导入表情包弹窗 - 完全修复版 */
#import-sticker-popup {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background-color: rgba(0, 0, 0, 0.5) !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    z-index: 9999 !important;
}

#import-sticker-popup.hidden {
    display: none !important;
}

#import-sticker-popup .popup-content {
    background-color: #ffffff !important;
    padding: 20px 25px !important;
    border-radius: 25px !important;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3) !important;
    max-width: 90% !important;
    max-height: 80% !important;
    overflow-y: auto !important;
    position: relative !important;
    z-index: 10000 !important;
}
/* 导入弹窗的预览网格 */
#sticker-preview-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
}

.preview-sticker-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 5px;
    border-radius: 6px;
    background-color: white;
    border: 1px solid #e0e0e0;
}

.preview-sticker-img {
    width: 60px;
    height: 60px;
    object-fit: cover;
    border-radius: 6px;
    margin-bottom: 4px;
}

.preview-sticker-text {
    font-size: 11px;
    color: #666;
    text-align: center;
    word-break: break-all;
    max-width: 70px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 查看表情库的网格 */
.sticker-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);  /* 【改】从4列改成3列 */
    gap: 10px;
}

.sticker-grid-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px;
    border-radius: 8px;
    background-color: white;
    border: 1px solid #e0e0e0;
    transition: all 0.2s;
    position: relative;  /*  为删除按钮定位 */
}

.sticker-grid-item:hover {
    background-color: #f0f0f0;
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/*  单个表情包的删除按钮 */
.sticker-item-delete {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 20px;
    height: 20px;
    background-color: #ff3b30;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;  /* 默认隐藏 */
    transition: opacity 0.2s;
}

.sticker-grid-item:hover .sticker-item-delete {
    opacity: 1;  /* 鼠标悬停时显示 */
}

.sticker-item-delete:hover {
    background-color: #ff1f1f;
    transform: scale(1.1);
}

.sticker-grid-img {
    width: 70px;  /* 【改】稍微放大一点 */
    height: 70px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 5px;
}

.sticker-grid-text {
    font-size: 11px;
    color: #666;
    text-align: center;
    word-break: break-all;
    max-width: 80px;  /* 【改】适配新的宽度 */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
/* 聊天页面的表情面板 */
.sticker-panel {
    position: absolute;
    bottom: 95px;
    left: 0;
    width: 100%;
    height: 300px;  /* 【改】固定高度，不用max-height */
    background-color: white;
    border-top: 1px solid #e0e0e0;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    z-index: 100;
    display: flex;
    flex-direction: column;
    overflow: hidden;  /*  防止内容溢出 */
}

.sticker-panel-header {
    padding: 10px 15px;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;  /*  防止被压缩 */
    box-sizing: border-box;  /*   */
}

.sticker-panel-search {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #ccc;
    border-radius: 8px;
    font-size: 14px;
    outline: none;
    box-sizing: border-box;  /* 【关键】防止被父容器压缩 */
}


.sticker-panel-tabs {
    display: flex;
    gap: 8px;
    padding: 10px 15px;
    overflow-x: auto;
    border-bottom: 1px solid #e0e0e0;
    white-space: nowrap;
    flex-shrink: 0;  /*  防止被压缩 */
    min-height: 45px;  /*  确保有足够高度 */
    align-items: center;  /*  垂直居中 */
    box-sizing: border-box;  /*   */
}

.sticker-tab {
    padding: 6px 12px;
    background-color: #f0f0f0;
    border: none;
    border-radius: 15px;
    font-size: 13px;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s;
    flex-shrink: 0;  /*  防止标签被压缩 */
}


.sticker-panel-tabs::-webkit-scrollbar {
    height: 4px;
}

.sticker-panel-tabs::-webkit-scrollbar-thumb {
    background-color: #ccc;
    border-radius: 2px;
}

.sticker-tab {
    padding: 6px 12px;
    background-color: #f0f0f0;
    border: none;
    border-radius: 15px;
    font-size: 13px;
    cursor: pointer;
    white-space: nowrap;
    transition: all 0.2s;
}

.sticker-tab:hover {
    background-color: #e0e0e0;
}

.sticker-tab.active {
    background-color: #007aff;
    color: white;
}

.sticker-panel-content {
    flex-grow: 1;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 10px 15px;  /* 【改】左右内边距改大一点 */
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap:0px;  /* 【改】间距改大一点 */
    align-content: start;
    box-sizing: border-box;
}


.sticker-panel-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    padding: 8px;
    border-radius: 8px;
    transition: background-color 0.2s;
}

.sticker-panel-item:hover {
    background-color: #f0f0f0;
}

.sticker-panel-img {
    width: 55px;  /* 【改】稍微缩小一点 */
    height: 55px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 4px;
}

.sticker-panel-text {
    font-size: 11px;
    color: #666;
    text-align: center;
    word-break: break-all;
    max-width: 70px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* 表情包在聊天气泡中的样式 */
.message-sticker {
    width: 120px;
    height: 120px;
    object-fit: cover;
    border-radius: 10px;
    display: block;  /*  确保图片正常显示 */
}

/* 【修复】调整包含表情包的气泡样式 */
.message-bubble:has(.message-sticker) {
    padding: 5px;
    background-color: transparent;
    box-shadow: none;
}

/*  确保表情包气泡保持原有的左右位置 */
.user-message:has(.message-sticker) {
    align-self: flex-end; /* 用户发的表情包靠右 */
}

.bot-message:has(.message-sticker) {
    align-self: flex-start; /* AI发的表情包靠左 */
}
/* 聊天输入框聚焦时的优化 */
.dialogue-input-area input:focus {
    /* iOS 自动滚动到输入框的视觉优化 */
    scroll-margin-bottom: 20px;
}

/* 消息容器在键盘弹出时的调整 */
.message-container {
    /* 添加过渡动画，让高度变化更平滑 */
    transition: max-height 0.3s ease;
}

/* 确保角色设置页面的内容区可以滚动 */
#contact-settings-screen .theme-content {
    flex-grow: 1;
    overflow-y: auto !important;
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch;
    height: auto;
    max-height: calc(100vh - 60px); /* 留出顶部导航栏的高度 */
}

/* 确保记忆设置页面的内容区也可以滚动 */
#memory-screen .theme-content {
    flex-grow: 1;
    overflow-y: auto !important;
    overflow-x: hidden;
    -webkit-overflow-scrolling: touch;
    padding: 15px;
    max-height: calc(100vh - 60px);
}
/* 消息编辑弹窗 */
#message-edit-popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000000; /* 比表情包弹窗还要高 */
}

#message-edit-popup .popup-content {
    background-color: #ffffff;
    padding: 20px 25px;
    border-radius: 25px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    width: 300px;
    max-height: 400px;
    position: relative;
}

#message-edit-popup textarea {
    width: calc(100% - 20px);
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    resize: vertical;
    font-size: 14px;
    min-height: 100px;
}
/* ============================================= */
/* 【新添加】字体设置的样式 */
/* ============================================= */

/* 字体预览区域 */
.font-preview-box {
    background-color: #f9f9f9;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 15px;
    margin-top: 10px;
    min-height: 60px;
}

.font-preview-label {
    font-size: 12px;
    color: #888;
    margin-bottom: 8px;
}

.font-preview-text {
    font-size: 16px;
    color: #333;
}

/* ============================================= */
/* 【iOS修复】防止输入框聚焦时页面放大 */
/* ============================================= */

/* 1. 确保所有输入框字体大小至少16px（iOS关键） */
input, textarea, select {
    font-size: 16px !important;
}

/* 2. 特殊处理密码输入框 */
input[type="password"] {
    font-size: 16px !important;
}

/* 3. 禁用iOS的自动缩放 */
input:focus, textarea:focus, select:focus {
    font-size: 16px !important;
}

/* 4. 确保body不会被缩放 */
body {
    -webkit-text-size-adjust: 100%;
    -moz-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    text-size-adjust: 100%;
}

/* 5. 特殊处理聊天输入框 */
#chat-input-box {
    font-size: 16px !important;
}

/* 6. 特殊处理弹窗中的输入框 */
.popup-content input,
.popup-content textarea {
    font-size: 16px !important;
}

/* 7. 设置页面的输入框 */
.setting-item input,
.setting-item textarea {
    font-size: 16px !important;
}
/* ============================================= */
/* 【新功能】多选删除消息模式 */
/* ============================================= */

/* 1. 删除按钮的样式 */
#batch-delete-btn {
    position: absolute;
    left: 15px;
    top: 50%;
    transform: translateY(-50%);
    background-color: #ff3b30;
    color: white;
    border: none;
    border-radius: 5px;
    padding: 5px 10px;
    font-size: 13px;
    cursor: pointer;
    display: none; /* 默认隐藏 */
    z-index: 10;
}

#batch-delete-btn:hover {
    background-color: #ff1f1f;
}

/* 2. 消息被选中时的样式 */
.message-bubble.selected {
    background-color: rgba(255, 59, 48, 0.2) !important;
    border: 2px solid #ff3b30 !important;
    box-shadow: 0 0 0 3px rgba(255, 59, 48, 0.1) !important;
}

/* ============================================= */
/* 【新增】朋友圈功能专属样式 */
/* ============================================= */

/* 1. 底部标签栏 */
.bottom-tab-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 60px;
    background-color: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    display: flex;
    justify-content: space-around;
    align-items: center;
    z-index: 50;
    box-sizing: border-box;
}

/* 2. 标签按钮 */
.bottom-tab-bar .tab-btn {
    flex: 1;
    height: 100%;
    background: none;
    border: none;
    font-size: 15px;
    color: #666;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: color 0.2s;
}

.bottom-tab-bar .tab-btn:hover {
    color: #333;
}

/* 3. 朋友圈页面容器 */
.moments-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f9f9f9;
    z-index: 210;
    display: flex;
    flex-direction: column;
}

/* 4. 朋友圈内容区域 */
.moments-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    padding-bottom: 70px; /* 留出底部标签栏的空间 */
    -webkit-overflow-scrolling: touch;
}

/* 5. 调整联系人列表的底部间距（避免被标签栏遮挡） */
.dialogue-list-content {
    padding-bottom: 70px !important; /* 只影响联系人列表 */
}


      /* ============================================= */
/* 【新增】朋友圈卡片样式 */
/* ============================================= */

/* 1. 单个朋友圈卡片 */
..moment-card {
    background-color: #ffffff;
    border-radius: 12px;
    padding: 15px;
    margin-bottom: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    transition: box-shadow 0.2s;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
}

.moment-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

/* 2. 卡片头部（头像 + 用户信息） */
.moment-header {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
}

.moment-avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    object-fit: cover;
    margin-right: 12px;
    border: 2px solid #f0f0f0;
}

.moment-user-info {
    flex-grow: 1;
}

.moment-username {
    font-size: 15px;
    font-weight: bold;
    color: #333;
    margin: 0 0 4px 0;
}

.moment-time {
    font-size: 12px;
    color: #999;
    margin: 0;
    display: flex;
    align-items: center;
    gap: 5px;
}

/* 3. 内容区域 */
.moment-content-text {
    font-size: 15px;
    line-height: 1.6;
    color: #333;
    margin-bottom: 10px;
    word-wrap: break-word;
}

/* 4. 话题标签 */
.moment-hashtag {
    color: #007aff;
    text-decoration: none;
    margin-right: 5px;
}

.moment-hashtag:hover {
    text-decoration: underline;
}

/* 5. 定位信息 */
.moment-location {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 13px;
    color: #666;
    margin-bottom: 10px;
}

.moment-location-icon {
    font-size: 14px;
}

/* 6. 图片网格（最多9张） */
.moment-images {
    display: grid;
    gap: 4px;
    margin-bottom: 12px;
    border-radius: 8px;
    overflow: hidden;
}

/* 1张图片 */
.moment-images.count-1 {
    grid-template-columns: 1fr;
    max-width: 200px;
}

/* 2张图片 */
.moment-images.count-2 {
    grid-template-columns: repeat(2, 1fr);
}

/* 3张图片 */
.moment-images.count-3 {
    grid-template-columns: repeat(3, 1fr);
}

/* 4张图片 */
.moment-images.count-4 {
    grid-template-columns: repeat(2, 1fr);
}

/* 6张图片 */
.moment-images.count-6 {
    grid-template-columns: repeat(3, 1fr);
}

/* 9张图片 */
.moment-images.count-9 {
    grid-template-columns: repeat(3, 1fr);
}

.moment-image {
    width: 100%;
    aspect-ratio: 1;
    object-fit: cover;
    cursor: pointer;
    transition: opacity 0.2s;
}

.moment-image:hover {
    opacity: 0.9;
}

/* 7. 互动区域 */
.moment-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0;
}

.moment-action-btn {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 5px;
    padding: 8px 0;
    background: none;
    border: none;
    color: #666;
    font-size: 14px;
    cursor: pointer;
    transition: color 0.2s;
}

.moment-action-btn:hover {
    color: #007aff;
}

.moment-action-btn.liked {
    color: #ff3b30;
}

.moment-action-icon {
    font-size: 18px;
}
/* ============================================= */
/* 【新增】发布动态弹窗样式 */
/* ============================================= */

/* 1. 弹窗遮罩层 */
.publish-moment-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;
}

/* 2. 弹窗主体 */
.publish-moment-modal {
    background-color: #ffffff;
    border-radius: 16px;
    width: 100%;
    max-width: 500px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    overflow: hidden;
}

/* 3. 弹窗头部 */
.publish-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border-bottom: 1px solid #e0e0e0;
}

.publish-header h3 {
    margin: 0;
    font-size: 17px;
    font-weight: bold;
    color: #333;
}

.publish-cancel-btn,
.publish-submit-btn {
    background: none;
    border: none;
    font-size: 16px;
    cursor: pointer;
    padding: 5px 10px;
}

.publish-cancel-btn {
    color: #666;
}

.publish-submit-btn {
    color: #007aff;
    font-weight: bold;
}

.publish-submit-btn:disabled {
    color: #ccc;
    cursor: not-allowed;
}

/* 4. 弹窗内容区 */
.publish-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px;
    -webkit-overflow-scrolling: touch;
}

/* 5. 文字输入框 */
#publish-textarea {
    width: 100%;
    min-height: 120px;
    padding: 10px;
    font-size: 15px;
    line-height: 1.6;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    resize: none;
    margin-bottom: 15px;
    font-family: inherit;
    box-sizing: border-box;
}

#publish-textarea:focus {
    outline: none;
    border-color: #007aff;
}

/* 6. 话题标签输入 */
.publish-hashtags {
    margin-bottom: 15px;
}

#publish-hashtag-input {
    width: 100%;
    padding: 10px;
    font-size: 14px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-sizing: border-box;
}

#publish-hashtag-input:focus {
    outline: none;
    border-color: #007aff;
}

/* 7. 定位输入 */
.publish-location {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 15px;
}

.location-icon {
    font-size: 18px;
}

#publish-location-input {
    flex-grow: 1;
    padding: 10px;
    font-size: 14px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    box-sizing: border-box;
}

#publish-location-input:focus {
    outline: none;
    border-color: #007aff;
}

/* 8. 图片预览区 */
.publish-images-preview {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 15px;
}

.preview-image-wrapper {
    position: relative;
    aspect-ratio: 1;
    border-radius: 8px;
    overflow: hidden;
    background-color: #f0f0f0;
}

.preview-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.remove-image-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.6);
    border: none;
    border-radius: 50%;
    color: white;
    font-size: 16px;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* 9. 添加图片按钮 */
.publish-add-image {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.add-image-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 15px;
    background-color: #f0f0f0;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.add-image-btn:hover {
    background-color: #e0e0e0;
}
/* 【新增】让两个切换按钮和"添加图片"按钮样式完全一致 */
#image-mode-real,
#image-mode-text {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 10px 15px;
    background-color: #f0f0f0;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.2s;
    font-size: 14px;
    color: #333;
}

#image-mode-real:hover,
#image-mode-text:hover {
    background-color: #e0e0e0;
}

.add-image-icon {
    font-size: 20px;
}

.image-count-hint {
    font-size: 12px;
    color: #999;
}
/* ============================================= */
/* 【新增】用户主页样式 */
/* ============================================= */

.user-profile-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background-color: #f5f5f5 !important;
    z-index: 999999 !important;
    display: flex !important;
    flex-direction: column !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important;
}

.user-profile-screen.hidden {
    display: none !important;
}

/* 2. 背景墙区域 */
.profile-header {
    position: relative;
    width: 100%;
}

.profile-cover {
    width: 100%;
    height: 200px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    background-size: cover;
    background-position: center;
}

/* 3. 头像区域 */
.profile-avatar-section {
    position: relative;
    text-align: center;
    margin-top: -50px;
    padding-bottom: 15px;
    background-color: #ffffff;
    border-radius: 20px 20px 0 0;
}

.profile-avatar {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: 5px solid #ffffff;
    object-fit: cover;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    transition: transform 0.2s;
}

.profile-avatar:hover {
    transform: scale(1.05);
}

.profile-nickname {
    margin: 10px 0 0 0;
    font-size: 20px;
    font-weight: bold;
    color: #333;
}
.profile-signature {
    margin: 5px 0 0 0;
    font-size: 14px;
    color: #999;
    min-height: 20px;
}

/* 4. 统计信息栏 */
.profile-stats {
    display: flex;
    justify-content: space-around;
    padding: 20px 0;
    background-color: #ffffff;
    border-bottom: 8px solid #f5f5f5;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.stat-number {
    font-size: 24px;
    font-weight: bold;
    color: #333;
    margin-bottom: 5px;
}

.stat-label {
    font-size: 14px;
    color: #999;
}

/* 5. 九宫格动态列表 */
.profile-moments-grid {
    background-color: #f5f5f5;
    padding: 10px;
    min-height: 300px;
}


/* 7. 空状态提示 */
.profile-moments-grid .empty-list-message {
    grid-column: 1 / -1;
    text-align: center;
    padding: 60px 20px;
    color: #999;
    font-size: 14px;
}
/* ============================================= */
/* 【新增】用户主页设置页面样式 */
/* ============================================= */

.user-profile-settings-screen {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    background-color: #f0f0f0 !important;
    z-index: 99999999 !important;
    display: flex !important;
    flex-direction: column !important;
    overflow-y: auto !important;
}

.user-profile-settings-screen.hidden {
    display: none !important;
}
      /* ============================================= */
/* 【新增】朋友圈点赞功能样式 */
/* ============================================= */

/* 1. 点赞者列表容器 */
.moment-likes-list {
    padding: 10px 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    margin-top: 10px;
    font-size: 13px;
    color: #666;
    line-height: 1.6;
}

.moment-likes-list .likes-icon {
    color: #ff3b30;
    margin-right: 5px;
}

.moment-likes-list .liker-name {
    color: #007aff;
    margin-right: 5px;
}

/* 2. 爱心飞出动画 */
@keyframes heart-fly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    50% {
        transform: translate(0, -30px) scale(1.5);
        opacity: 0.8;
    }
    100% {
        transform: translate(0, -60px) scale(0.5);
        opacity: 0;
    }
}

.flying-heart {
    position: absolute;
    font-size: 24px;
    color: #ff3b30;
    pointer-events: none;
    animation: heart-fly 1s ease-out forwards;
    z-index: 1000;
}
/* ======================================================= */
/* 【新增】朋友圈评论功能样式 */
/* ======================================================= */

/* 评论区容器 */
.moment-comments-section {
    padding: 10px 15px;
    border-top: 1px solid #f0f0f0;
    background-color: #fafafa;
}

/* 生成评论按钮 */
/* 评论区头部 */
.comments-header {
    display: flex;
    justify-content: flex-start;
    padding: 8px 0;
    margin-bottom: 8px;
}

.generate-comments-link {
    font-size: 13px;
    color: #999;           
    font-style: italic;  
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
}


.generate-comments-link:hover {
    background-color: #f0f0f0;
}

.generate-comments-link:active {
    background-color: #e0e0e0;
}

/* 生成中状态 */
.generate-comments-link.loading {
    color: #999;
    cursor: not-allowed;
    pointer-events: none;
}


/* 评论列表 */
.comments-list {
    margin-bottom: 10px;
}

/* 单条评论 */
.comment-item {
    display: flex;
    gap: 10px;
    margin-bottom: 12px;
    padding: 8px;
    background-color: white;
    border-radius: 8px;
}

.comment-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-content {
    flex-grow: 1;
}

.comment-user {
    font-size: 14px;
    font-weight: bold;
    color: #333;
    margin: 0 0 4px 0;
}

.comment-text {
    font-size: 14px;
    color: #555;
    margin: 0 0 4px 0;
    word-wrap: break-word;
}

.comment-time {
    font-size: 12px;
    color: #999;
    margin: 0;
}

/* 评论输入区 */
.comment-input-area {
    display: flex;
    gap: 8px;
    margin-top: 10px;
}

.comment-input {
    flex-grow: 1;
    padding: 8px 12px;
    border: 1px solid #ddd;
    border-radius: 18px;
    font-size: 14px;
    outline: none;
}

.send-comment-btn {
    padding: 8px 16px;
    background-color: #007aff;
    color: white;
    border: none;
    border-radius: 18px;
    font-size: 14px;
    cursor: pointer;
}

.send-comment-btn:hover {
    background-color: #0056b3;
}
/* 如果有自定义删除确认弹窗 */
.delete-confirm-popup {
    z-index: 9999999999 !important;
}
        /*这里是CSS末尾，style的末尾，最底下*/ 

    </style>
  <script src="https://unpkg.com/dexie@4/dist/dexie.js"></script>
</head>
<body>

    <div class="phone-screen">
        
       <div class="status-bar">
             <span id="top-left-text"></span>
            <span id="top-right-text"></span>
            </div>

         <div class="time-widget">
            <p id="date-display">9月9日 星期二</p>
            <h1 id="time-display">02:33</h1>
        </div>
 <div class="theme-screen hidden">
            <nav class="theme-nav">
                <button id="back-to-home-btn" class="back-btn">&lt;</button>
                <h2>主题</h2>
              
            </nav>

            <div class="theme-content">
                <div class="accordion-item">
                    <div class="accordion-header" id="accordion-header-1">
                        <span>顶部文字</span>
                        <span class="arrow">&gt;</span>
                    </div>
                    <div class="accordion-content" id="accordion-content-1">
                        <div class="setting-item">
                            <label for="left-text-input">左边文字</label>
                            <input type="text" id="left-text-input" placeholder="输入左上角文字">
                        </div>
                    <div class="setting-item">
                            <label for="right-text-input">右边文字</label>
                            <input type="text" id="right-text-input" placeholder="输入右上角文字">
                        </div>

                        <div class="setting-item">
                            <label for="font-size-slider">大小</label>
                            <div class="slider-group">
                                <input type="range" id="font-size-slider" min="0" max="15" value="15">
                                <span id="font-size-value">15px</span>
                            </div>
                        </div>
                        <div class="button-group">
                            <button class="btn-clear" id="clear-text-btn">清除</button>
                            <button class="btn-save" id="save-text-btn">保存</button>
                        </div>
                    </div>
                </div>    <div class="accordion-item">
                    <div class="accordion-header" id="accordion-header-2">
                        <span>黑夜模式切换</span>
                        <span class="arrow">&gt;</span>
                    </div>
                    <div class="accordion-content" id="accordion-content-2">
                        <div class="setting-item">
                            <div class="toggle-switch" id="dark-mode-toggle">
                                <div class="toggle-label">白</div>
                                <div class="toggle-handle"></div>
                                <div class="toggle-label">黑</div>
                            </div>
                        </div>
                    </div>
                </div>    

               <div class="accordion-item">
                    <div class="accordion-header" id="accordion-header-3">
                        <span>自定义图标 (URL)</span>
                        <span class="arrow">&gt;</span>
                    </div>
                    <div class="accordion-content" id="accordion-content-3">
                        
                     <!-- 对话 -->
<div class="setting-item">
    <label for="icon-url-dialogue">对话</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-dialogue" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-dialogue" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-dialogue" accept="image/*" style="display: none;">
        <img id="icon-preview-dialogue" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>

<!-- 世界书 -->
<div class="setting-item">
    <label for="icon-url-worldbook">世界书</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-worldbook" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-worldbook" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-worldbook" accept="image/*" style="display: none;">
        <img id="icon-preview-worldbook" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>

<!-- 论坛 -->
<div class="setting-item">
    <label for="icon-url-forum">论坛</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-forum" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-forum" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-forum" accept="image/*" style="display: none;">
        <img id="icon-preview-forum" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>

<!-- 我 -->
<div class="setting-item">
    <label for="icon-url-me">我</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-me" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-me" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-me" accept="image/*" style="display: none;">
        <img id="icon-preview-me" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>

<!-- 设置 -->
<div class="setting-item">
    <label for="icon-url-settings">设置</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-settings" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-settings" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-settings" accept="image/*" style="display: none;">
        <img id="icon-preview-settings" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>

<!-- 主题 -->
<div class="setting-item">
    <label for="icon-url-theme">主题</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-theme" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-theme" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-theme" accept="image/*" style="display: none;">
        <img id="icon-preview-theme" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>

<!-- 记忆 -->
<div class="setting-item">
    <label for="icon-url-memory">记忆</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="url" id="icon-url-memory" placeholder="粘贴URL 或 点击右侧上传" style="flex-grow: 1;">
        <label for="icon-file-memory" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
        <input type="file" id="icon-file-memory" accept="image/*" style="display: none;">
        <img id="icon-preview-memory" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
    </div>
</div>


                        <div class="button-group">
                            <button class="btn-clear" id="clear-icons-btn">全部清除</button>
                            <button class="btn-save" id="save-icons-btn">保存图标</button>
                        </div>
                    </div>
                </div>

<!--  聊天界面美化手风琴 -->
<div class="accordion-item">
    <div class="accordion-header" id="accordion-header-4">
        <span>聊天界面美化</span>
        <span class="arrow">&gt;</span>
    </div>
    <div class="accordion-content" id="accordion-content-4">
        
        <!-- 4.1 导航栏样式 -->
        <div class="editor-section">
           <h4>顶部导航栏（标题栏）</h4>
            
            <div class="setting-item">
                <label>背景颜色</label>
                <input type="color" id="chat-nav-bg-color" value="#ffffff">
            </div>
            
            <div class="setting-item">
                <label>文字颜色</label>
                <input type="color" id="chat-nav-text-color" value="#333333">
            </div>
            
            <div class="setting-item">
                <label>背景图片（URL）</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="url" id="chat-nav-bg-url" placeholder="粘贴图片URL" style="flex-grow: 1;">
                    <label for="chat-nav-bg-file" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
                    <input type="file" id="chat-nav-bg-file" accept="image/*" style="display: none;">
                    <img id="chat-nav-bg-preview" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
                </div>
            </div>
          
        </div>
        
        <!-- 4.2 聊天壁纸 -->
        <div class="editor-section">
            <h4>聊天壁纸</h4>
            
            <div class="setting-item">
                <label>壁纸图片（URL）</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="url" id="chat-wallpaper-url" placeholder="粘贴图片URL" style="flex-grow: 1;">
                    <label for="chat-wallpaper-file" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
                    <input type="file" id="chat-wallpaper-file" accept="image/*" style="display: none;">
                    <img id="chat-wallpaper-preview" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
                </div>
            </div>
            
            <div class="setting-item">
                <label for="chat-wallpaper-blur">模糊程度</label>
                <div class="slider-group">
                    <input type="range" id="chat-wallpaper-blur" min="0" max="20" value="0">
                    <span id="chat-wallpaper-blur-value">0px</span>
                </div>
            </div>
            
            <div class="setting-item">
                <label for="chat-wallpaper-opacity">透明度</label>
                <div class="slider-group">
                    <input type="range" id="chat-wallpaper-opacity" min="0" max="100" value="100">
                    <span id="chat-wallpaper-opacity-value">100%</span>
                </div>
            </div>
        </div>
        
  <!-- 4.3 底部导航栏样式 -->
<div class="editor-section">
    <h4>底部导航栏（输入区域）</h4>
    
    <div class="setting-item">
        <label>背景颜色</label>
        <input type="color" id="chat-bottom-bg-color" value="#ffffff">
    </div>
    
    <div class="setting-item">
        <label>背景图片（URL）</label>
        <div style="display: flex; gap: 10px; align-items: center;">
            <input type="url" id="chat-bottom-bg-url" placeholder="粘贴图片URL" style="flex-grow: 1;">
            <label for="chat-bottom-bg-file" style="background-color: #007aff; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; white-space: nowrap;">📁 本地</label>
            <input type="file" id="chat-bottom-bg-file" accept="image/*" style="display: none;">
            <img id="chat-bottom-bg-preview" src="" alt="" style="width: 40px; height: 40px; object-fit: cover; border-radius: 5px; border: 1px solid #ccc; display: none;">
        </div>
    </div>
</div>

<!-- 4.4 输入框样式 -->
<div class="editor-section">
    <h4>输入框本身</h4>

            
            <div class="setting-item">
                <label>背景颜色</label>
                <input type="color" id="chat-input-bg-color" value="#ffffff">
            </div>
            
            <div class="setting-item">
                <label>文字颜色</label>
                <input type="color" id="chat-input-text-color" value="#333333">
            </div>
            
            <div class="setting-item">
                <label>边框颜色</label>
                <input type="color" id="chat-input-border-color" value="#cccccc">
            </div>
            
            <div class="setting-item">
                <label for="chat-input-radius">圆角大小</label>
                <div class="slider-group">
                    <input type="range" id="chat-input-radius" min="0" max="30" value="18">
                    <span id="chat-input-radius-value">18px</span>
                </div>
            </div>
        </div>
        
        <!-- 按钮组 -->
        <div class="button-group">
            <button class="btn-clear" id="clear-chat-style-btn">清除</button>
            <button class="btn-save" id="save-chat-style-btn">保存</button>
        </div>
        
    </div>
</div>

              <!---在这里添加主题里面的内容--->
                    </div>
   
                </div>
      
       <div class="settings-screen hidden">
            <nav class="theme-nav">
                <button id="settings-back-btn" class="back-btn">&lt;</button>
                <h2>设置</h2>
            </nav>
         

            <div class="theme-content">
                
                <div class="accordion-item">
                    <div class="accordion-header" id="api-accordion-header">
                        <span>API 设置</span>
                        <span class="arrow">&gt;</span>
                    </div>
            <div class="accordion-content" id="api-accordion-content">
                        
                        <div class="editor-section">
                            <h4>我的预设</h4>
                            <div class="setting-item">
                                <label for="api-preset-selector">聊天所用api必须点下面的保存此预设</label>
                                <select id="api-preset-selector" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;">
                                    </select>
                            </div>
                            <div class="button-group" style="margin-top: 10px; justify-content: space-between;">
                                <button id="api-preset-delete-btn" class="btn-clear" style="background-color: #ff3b30; color: white;">删除选中</button>
                                <button id="api-preset-new-btn" class="btn-save" style="background-color: #4cd964;">+ 新建预设</button>
                            </div>
                        </div>
<div class="setting-item" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
    <label for="api-summary-preset-selector">总结 API (可选)</label>
    <select id="api-summary-preset-selector" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;">
        </select>
    <p style="font-size: 12px; color: #777; margin-top: 5px;">
        默认跟随主API，修改直接选择保存过的预设既可。
    </p>
</div>
                        <div id="preset-edit-form" class="editor-section">
                            <h4 id="preset-form-title">编辑预设</h4>
                            
                            <div class="setting-item">
                                <label for="api-preset-name-input">预设名称</label>
                                <input type="text" id="api-preset-name-input" placeholder="例如: 我的 OpenAI">
                            </div>
                            
                            <div class="setting-item">
                                <label for="api-key-input">API Key (密钥)</label>
                                <input type="password" id="api-key-input" placeholder="sk-...">
                            </div>
                            
                            <div class="setting-item">
                                <label for="api-base-url-input">API 基础 URL (接入点)</label>
                                <input type="text" id="api-base-url-input" placeholder="https://api.openai.com/v1">
                            </div>

                            <div class="setting-item">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                    <label for="api-model-input">模型名称 (Model)</label>
                                    <button id="fetch-models-btn" style="padding: 4px 10px; font-size: 12px; background-color: #007aff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                        拉取
                                    </button>
                                </div>
                                <input type="text" id="api-model-input" placeholder="例如: gpt-4o">
                                <div id="model-selector-container" style="margin-top: 10px;"></div>
                            </div>
                            
                            <div class="button-group" style="margin-top: 10px;">
                                <button class="btn-save" id="api-preset-save-btn">保存此预设</button>
                            </div>
                        </div>

                    </div>
                </div>  
             <!-- 【新添加】字体设置手风琴 -->
<div class="accordion-item">
    <div class="accordion-header" id="font-accordion-header">
        <span>字体设置</span>
        <span class="arrow">&gt;</span>
    </div>
    <div class="accordion-content" id="font-accordion-content">
        
        <!-- 1. 字体预设 -->
        <div class="editor-section">
            <h4>字体预设</h4>
            <select id="font-preset-select" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;">
                <option value="default">默认</option>
                <option value="serif">衬线</option>
                <option value="monospace">等宽</option>
                <option value="custom">自定义</option>
            </select>
        </div>
        
        <!-- 2. 全局字体 -->
        <div class="editor-section">
            <h4>全局字体</h4>
            
            <div class="setting-item">
                <label>字体链接 (URL)</label>
                <input type="url" id="global-font-url" placeholder="例如：https://fonts.googleapis.com/...">
            </div>
            
            <div class="setting-item">
                <label>字体名称</label>
                <input type="text" id="global-font-name" placeholder="例如：Noto Sans SC">
            </div>
            
            <div class="setting-item">
                <label>字体大小</label>
                <div class="slider-group">
                    <input type="range" id="global-font-size" min="12" max="24" value="16">
                    <span id="global-font-size-value">16px</span>
                </div>
            </div>
            
            <!-- 全局字体预览 -->
            <div class="font-preview-box">
                <p class="font-preview-label">全局字体预览：</p>
                <p class="font-preview-text" id="global-font-preview">这是全局字体的效果</p>
            </div>
        </div>
        
        <!-- 3. 聊天字体 -->
        <div class="editor-section">
            <h4>聊天字体（覆盖全局）</h4>
            
            <div class="setting-item">
                <label>字体链接 (URL)</label>
                <input type="url" id="chat-font-url" placeholder="留空则使用全局字体">
            </div>
            
            <div class="setting-item">
                <label>字体名称</label>
                <input type="text" id="chat-font-name" placeholder="留空则使用全局字体">
            </div>
            
            <div class="setting-item">
                <label>字体大小</label>
                <div class="slider-group">
                    <input type="range" id="chat-font-size" min="12" max="24" value="16">
                    <span id="chat-font-size-value">16px</span>
                </div>
            </div>
            
            <!-- 聊天字体预览 -->
            <div class="font-preview-box">
                <p class="font-preview-label">聊天字体预览：</p>
                <p class="font-preview-text" id="chat-font-preview">这是聊天字体的效果</p>
            </div>
        </div>
        
        <!-- 5. 按钮组 -->
        <div class="button-group" style="margin-top: 20px;">
            <button class="btn-clear" id="font-reset-btn">恢复默认</button>
            <button class="btn-save" id="font-save-btn">保存字体设置</button>
        </div>
        
    </div>
</div>
   <!-- 【新添加】数据设置手风琴 -->
<div class="accordion-item">
    <div class="accordion-header" id="data-accordion-header">
        <span>数据设置</span>
        <span class="arrow">&gt;</span>
    </div>
    <div class="accordion-content" id="data-accordion-content">
        
        <!-- 1. Token 统计 -->
        <div class="editor-section">
            <h4>📊 数据统计</h4>
            <div style="background-color: #f9f9f9; padding: 15px; border-radius: 8px; margin-top: 10px;">
                <p style="margin: 5px 0; font-size: 14px; color: #555;">
                    <strong>联系人数量：</strong><span id="stat-contacts-count">计算中...</span>
                </p>
                <p style="margin: 5px 0; font-size: 14px; color: #555;">
                    <strong>聊天消息数：</strong><span id="stat-messages-count">计算中...</span>
                </p>
                <p style="margin: 5px 0; font-size: 14px; color: #555;">
                    <strong>世界书条目：</strong><span id="stat-worldbook-count">计算中...</span>
                </p>
                <p style="margin: 5px 0; font-size: 14px; color: #555;">
                    <strong>预估 Token 数：</strong><span id="stat-token-count">计算中...</span>
                </p>
                <button id="refresh-stats-btn" class="btn-save" style="width: 100%; margin-top: 10px;">刷新统计</button>
            </div>
        </div>
        
        <!-- 2. 数据备份 -->
        <div class="editor-section">
            <h4>💾 数据备份</h4>
            <p style="font-size: 12px; color: #777; margin-bottom: 10px;">
                将所有数据（联系人、聊天记录、世界书等）备份到本地文件
            </p>
            <button id="backup-data-btn" class="btn-save" style="width: 100%; background-color: #4cd964;">
                📥 备份所有数据
            </button>
        </div>
        
        <!-- 3. 数据恢复 -->
        <div class="editor-section">
            <h4>📂 数据恢复</h4>
            <p style="font-size: 12px; color: #ff3b30; margin-bottom: 10px;">
                ⚠️ 警告：恢复数据会覆盖当前所有数据！
            </p>
            <label for="restore-data-input" class="file-label" style="background-color: rgba(255, 149, 0, 0.8); margin: 0;">
                📤 选择备份文件恢复
            </label>
            <input type="file" id="restore-data-input" accept=".json" style="display: none;">
        </div>
        
    </div>
</div>

                </div>         
        </div>
        <div class="dialogue-list-screen hidden">
            <nav class="theme-nav">
                <button id="dialogue-list-back-btn" class="back-btn">&lt;</button>
                <h2>联系人</h2>
                <button id="new-chat-btn" class="nav-action-btn">+</button>
            </nav>
            <div class="dialogue-list-content">
                <p class="empty-list-message">暂无对话，点击右上角 + 号开始新聊天</p>
                </div>
       <!-- ======================================================= -->
<!-- 【新增】底部标签栏（联系人 / 朋友圈切换） -->
<!-- ======================================================= -->
<div class="bottom-tab-bar">
    <button class="tab-btn" id="tab-contacts">
        <span>联系人</span>
    </button>
    <button class="tab-btn" id="tab-moments">
        <span>朋友圈</span>
    </button>
</div>

        </div>
<!-- 【新增】朋友圈页面 -->
<div class="moments-screen hidden">
    <nav class="theme-nav">
     
        <h2>朋友圈</h2>
        <button id="moments-add-btn" class="nav-action-btn">+</button>
    </nav>
    
    <div class="moments-content" id="moments-content">
        <p class="empty-list-message">暂无动态，点击右上角 + 号发布第一条动态</p>
    </div>
    
    <div class="bottom-tab-bar">
        <button class="tab-btn" id="tab-contacts-2">
            <span>联系人</span>
        </button>
        <button class="tab-btn" id="tab-moments-2">
            <span>朋友圈</span>
        </button>
    </div>


</div>
 <!-- 【在这里添加】发布动态弹窗 -->
    <div class="publish-moment-overlay hidden" id="publish-moment-overlay">
        <div class="publish-moment-modal">
            <div class="publish-header">
                <button class="publish-cancel-btn" id="publish-cancel-btn">取消</button>
                <h3>发布动态</h3>
                <button class="publish-submit-btn" id="publish-submit-btn">发布</button>
            </div>
            
            <div class="publish-content">
                <!-- 文字输入 -->
                <textarea 
                    id="publish-textarea" 
                    placeholder="分享生活点滴，记录美好瞬间..." 
                    maxlength="2000"
                ></textarea>
                
                <!-- 话题标签输入 -->
                <div class="publish-hashtags">
                    <input 
                        type="text" 
                        id="publish-hashtag-input" 
                        placeholder="添加话题标签（用空格分隔，如：美食 旅行）"
                    >
                </div>
                
                <!-- 定位输入 -->
                <div class="publish-location">
                    <span class="location-icon">📍</span>
                    <input 
                        type="text" 
                        id="publish-location-input" 
                        placeholder="添加定位（可选）"
                    >
                </div>
                
                <!-- 图片预览区 -->
                <div class="publish-images-preview" id="publish-images-preview">
                    <!-- 图片缩略图会动态添加到这里 -->
                </div>
                
                <!-- 添加图片按钮 -->
          <!-- 配图方式选择 -->
<div class="setting-item" style="margin-top: 15px;">
    <label>配图方式</label>
    <div style="display: flex; gap: 10px; margin-top: 5px;">
        <button id="image-mode-real" class="btn-save" style="flex: 1; padding: 8px; background-color: #;">真实图片</button>
        <button id="image-mode-text" class="btn-clear" style="flex: 1; padding: 8px;">文字描述</button>
    </div>
</div>

<!-- 真实图片上传（默认显示） -->
<div id="real-image-container" class="publish-add-image">
    <label for="publish-image-input" class="add-image-btn">
        <span class="add-image-icon">📷</span>
        <span>上传图片</span>
    </label>
    <input type="file" id="publish-image-input" accept="image/*" multiple style="display: none;">
    <span class="image-count-hint" id="image-count-hint">最多9张</span>
</div>

<!-- 文字描述输入（默认隐藏） -->
<div id="text-image-container" class="setting-item hidden">
    <label>配图描述（每行一个）</label>
    <textarea id="publish-image-descriptions" rows="4" placeholder="例如：&#10;配图：一杯咖啡和一本书&#10;配图：窗外的街景" style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
</div>
            </div>
        </div>
    </div>
  
          <div class="chat-window-screen hidden">
    <nav class="theme-nav">
        <button id="chat-window-back-btn" class="back-btn">&lt;</button>
        <button id="batch-delete-btn">删除</button>
        <h2 id="chat-window-title">AI 助手</h2>
        <button id="contact-settings-btn" class="nav-action-btn" style="font-size: 24px; font-weight: bold;">...</button>
    </nav>

             </nav>
            
            <div class="message-container" id="message-container">
                </div>
        

<!--  表情按钮区域（在输入框上方） -->
<div style="padding: 5px 15px; border-top: 1px solid #e0e0e0; background-color: #ffffff; display: flex; justify-content: flex-start; gap: 10px;">
    <button id="sticker-toggle-btn" style="background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; cursor: pointer; padding: 4px 10px; color: #555;">😊 表情</button>
    <button id="retract-btn" style="background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; cursor: pointer; padding: 4px 10px; color: #555; ">🔄 撤回</button>
</div>

    <!--  表情面板 -->
    <div id="sticker-panel" class="sticker-panel hidden">
        <div class="sticker-panel-header">
            <input type="text" id="sticker-search-input" class="sticker-panel-search" placeholder="搜索表情包...">
        </div>
        <div class="sticker-panel-tabs" id="sticker-panel-tabs">
            <!-- 动态生成表情库标签 -->
        </div>
        <div class="sticker-panel-content" id="sticker-panel-content">
            <!-- 动态生成表情包网格 -->
        </div>
    </div>
            <div class="dialogue-input-area">
                <input type="text" id="chat-input-box" placeholder="输入消息...">
                <button id="send-message-btn">接收</button>
            </div>
        </div>
        <main class="app-grid">
         <div class="widget widget-3x2">
                <div class="widget-bg" id="widget-bg-image">
                    <img src="./assets/default-avatar.png" alt="Avatar" class="widget-avatar" id="widget-avatar-image">
                </div>
                <p class="widget-text" id="widget-bottom-text">大胆，朕是皇帝！</p>
            </div>
            
            <div class="widget widget-2x1">
                <h4>🌤️ 天气</h4>
                <p>晴天, 25°C</p>
            </div>
          <div class="app-icon" id="icon-dialogue">
           
        
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.5a1 1 0 0 0-.8.4l-1.9 2.533a1 1 0 0 1-1.6 0L5.3 12.4a1 1 0 0 0-.8-.4H2a2 2 0 0 1-2-2V2zm3.5 1a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1h-9zm0 2.5a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1h-9zm0 2.5a.5.5 0 0 0 0 1h5a.5.5 0 0 0 0-1h-5z"/></svg>
                <span>对话</span>
            </div>
        <div class="app-icon" id="icon-worldbook">
             
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M8.5 2.687c.654-.689 1.782-.886 3.112-.752 1.234.124 2.503.523 3.388 1.175.884.652 1.303 1.527 1.303 2.456 0 .98-.45 1.928-1.384 2.675-.801.645-1.902.802-3.122.684a.5.5 0 0 1-.45-.498V5.15a.5.5 0 0 1 .45-.498c1.134-.11 2.291-.322 3.292-.752.992-.422 1.722-1.027 1.722-1.727 0-.54-.342-1.033-.82-1.42-.453-.374-1.156-.62-2.09-.722-1.024-.11-2.046.015-2.822.534L8.5 2.687zM8 1.5C7.346.811 6.218.614 4.888.752 3.654.876 2.385 1.275 1.5 1.928.614 2.58.196 3.455.196 4.382c0 .98.45 1.928 1.384 2.675.801.645 1.902.802 3.122.684a.5.5 0 0 0 .45-.498V5.15a.5.5 0 0 0-.45-.498c-1.134-.11-2.291-.322-3.292-.752-.992-.422-1.722-1.027-1.722-1.727 0-.54.342-1.033.82-1.42.453-.374 1.156-.62-2.09-.722-1.024-.11-2.046.015-2.822.534L8 1.5z"/><path d="M8 4v7.75a.25.25 0 0 0 .25.25h.5a.25.25 0 0 0 .25-.25V4a.25.25 0 0 0-.25-.25h-.5A.25.25 0 0 0 8 4z"/></svg>
                <span>世界书</span>
            </div>
         <div class="app-icon" id="icon-forum">
           
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M16 8c0 3.866-3.582 7-8 7a9.06 9.06 0 0 1-2.347-.306c-.584.296-1.925.864-4.181 1.234-.2.032-.352-.176-.273-.362.354-.836.674-1.95.77-2.966C.744 11.37 0 9.76 0 8c0-3.866 3.582-7 8-7s8 3.134 8 7zM4.5 5a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7zm0 2.5a.5.5 0 0 0 0 1h7a.5.5 0 0 0 0-1h-7zm0 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4z"/></svg>
                <span>论坛</span>
            </div>
<div class="app-icon" id="icon-me">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0zm4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4zm-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10c-2.29 0-3.516.68-4.168 1.332-.678.678-.83 1.418-.832 1.664h10z"/></svg>
    <span>我</span>
</div>
            
            <div style="grid-column: span 2;"></div>

            <div class="widget widget-2x1-slim" data-widget-id="card2">
                <p class="widget-text-slim"></p>
            </div>

            <div style="grid-column: span 2;"></div>

            <div class="widget widget-2x1-slim" data-widget-id="card1">
                <p class="widget-text-slim"></p>
            </div>
        </main>

        <nav class="dock">
         <div class="app-icon" id="icon-settings">
              
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M9.405 1.05c-.413-1.4-2.397-1.4-2.81 0l-.1.34a1.464 1.464 0 0 1-2.105.872l-.31-.17c-1.283-.698-2.686.705-1.987 1.987l.169.311a1.464 1.464 0 0 1-.872 2.105l-.34.1c-1.4.413-1.4 2.397 0 2.81l.34.1a1.464 1.464 0 0 1 .872 2.105l-.17.31c-.698 1.283.705 2.686 1.987 1.987l.311-.169a1.464 1.464 0 0 1 2.105.872l.1.34c.413 1.4 2.397 1.4 2.81 0l.1-.34a1.464 1.464 0 0 1 2.105-.872l.31.17c1.283.698 2.686-.705 1.987-1.987l-.169-.311a1.464 1.464 0 0 1 .872-2.105l.34-.1c1.4-.413 1.4-2.397 0-2.81l-.34-.1a1.464 1.464 0 0 1-.872-2.105l.17-.31c.698-1.283-.705-2.686-1.987-1.987l-.311.169a1.464 1.464 0 0 1-2.105-.872l-.1-.34zM8 10.93a2.929 2.929 0 1 1 0-5.86 2.929 2.929 0 0 1 0 5.858z"/></svg>
                <span>设置</span>
            </div>
                <div class="app-icon" id="theme-app-icon">
              
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M8 16a2 2 0 0 0 2-2H6a2 2 0 0 0 2 2zM8 1.918l-.797.161A4.002 4.002 0 0 0 4 6c0 .628-.134 2.197-.459 3.742-.16.767-.376 1.566-.663 2.258h10.244c-.287-.692-.502-1.49-.663-2.258C12.134 8.197 12 6.628 12 6a4.002 4.002 0 0 0-3.203-3.92L8 1.917zM14.22 12c.223.447.481.801.78 1H1c.299-.199.557-.553.78-1C2.68 10.2 3 6.88 3 6c0-2.42 1.72-4.44 4.005-4.901a1 1 0 1 1 1.99 0A5.002 5.002 0 0 1 13 6c0 .88.32 4.2 1.22 6z"/></svg>
                <span>主题</span>
            </div>
         <div class="app-icon" id="icon-memory">
              
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16"><path d="M8 5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5z"/><path d="M4.246 1.126C3.201 1.631 2 2.95 2 4.5s1.201 2.869 2.246 3.374c1.118.536 2.329.626 3.29.283.192-.07.393-.157.6-.253.314-.148.642-.358.915-.624.273-.266.48-.593.618-.948.139-.355.195-.75.195-1.153 0-.403-.056-.798-.195-1.153-.138-.355-.345-.682-.618-.948-.273-.266-.601-.476-.915-.624a6.437 6.437 0 0 0-.6-.253c-.96-.343-2.172-.253-3.29.283zm-3.065 6.352c-.655-.49-.93-1.246-.93-2.028 0-.782.275-1.538.93-2.028C1.73 3.333 2.92 2.5 4.5 2.5c1.58 0 2.77.833 3.423 1.48C8.583 4.537 9.27 5.5 8.5 7.027c-.772 1.527-1.46 2.49-2.077 2.49-.618 0-1.306-.963-2.077-2.49z"/></svg>
                <span>记忆</span>
            </div>
          
        </nav>
 <div id="theme-popup" class="popup hidden">
            <div class="popup-content">
                <h3>更换壁纸</h3>
                <div class="input-group">
                    <input type="url" id="image-url-input" placeholder="请在这里粘贴图片URL">
                    <button id="url-submit-btn">确定</button>
                </div>
                <p>或者</p>
                <label for="local-file-input" class="file-label">
                    从本地选择图片
                </label>
                <input type="file" id="local-file-input" accept="image/*" style="display: none;">
                <button id="close-popup-btn" class="close-btn">×</button>
            </div>
        </div>

    <div id="widget-editor-popup" class="popup hidden">
            <div class="popup-content">
                <h3>组件编辑器</h3>
                
                <div class="editor-section">
                    <h4>背景图</h4>
                    <div class="input-group">
                        <input type="url" id="widget-bg-url-input" placeholder="粘贴背景图URL">
                    </div>
                 <div style="display: flex; align-items: center; gap: 10px;">
    <label for="widget-bg-file-input" class="file-label" style="flex-grow: 1; margin: 0;">
        或 从本地上传背景
    </label>
    <img id="widget-bg-preview" src="" alt="背景预览" style="width: 50px; height: 50px; border-radius: 8px; object-fit: cover; background-color: #eee; display: none;">
</div>
<input type="file" id="widget-bg-file-input" accept="image/*" style="display: none;">
                </div>
 <div class="editor-section"id="avatar-editor-section">
                    <h4>头像</h4>
                    <div class="input-group">
                        <input type="url" id="widget-avatar-url-input" placeholder="粘贴头像图片URL">
                    </div>
                   <div style="display: flex; align-items: center; gap: 10px;">
    <label for="widget-avatar-file-input" class="file-label" style="background-color: rgba(0, 122, 255, 0.8); flex-grow: 1; margin: 0;">
        或 从本地上传头像
    </label>
    <img id="widget-avatar-preview" src="" alt="头像预览" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; display: none;">
</div>
<input type="file" id="widget-avatar-file-input" accept="image/*" style="display: none;">
                </div>
               <div class="editor-section">
                    <h4>文字</h4>
                    <div class="input-group">
                        <input type="text" id="widget-text-input" placeholder="输入自定义文字 (可选)">
                    </div>
                    <div class="input-group" style="justify-content: space-between; align-items: center; margin-top: 10px;">
                        <label for="widget-text-color-input" style="font-weight: bold; color: #555;">文字颜色:</label>
                        <input type="color" id="widget-text-color-input" value="#333333">
                    </div>
                    </div>

                <div class="button-group">

                    <button class="btn-clear" id="widget-clear-btn">清除</button>
                    <button class="btn-save" id="widget-save-btn">保存</button>
                </div>

                <button id="widget-editor-close-btn" class="close-btn">×</button>
            </div>
        </div>
        </div>



        <div id="add-contact-popup" class="popup solid-popup hidden">
            
            <div class="popup-content solid-popup-content">
                <h3>添加新联系人</h3>
                
                <div class="avatar-preview-container">
                    <img id="contact-avatar-preview" src="./assets/default-avatar.png" alt="头像预览">
                </div>
                
                <label for="contact-avatar-file-input" class="file-label" style="background-color: rgba(0, 122, 255, 0.8);">
                    上传头像
                </label>
                <input type="file" id="contact-avatar-file-input" accept="image/*" style="display: none;">

                <div class="setting-item">
                    <label for="contact-name-input">姓名</label>
                    <input type="text" id="contact-name-input" placeholder="输入联系人姓名">
                </div>
                
                <div class="setting-item">
                    <label for="contact-persona-input">人设 (Persona)</label>
                    <textarea id="contact-persona-input" rows="5" placeholder="输入对方的人设或背景故事..."></textarea>
                </div>
<div class="setting-item">
                <label for="contact-mypersona-preset-select">与 Ta 聊天时，使用哪个人设？</label>
                <select id="contact-mypersona-preset-select" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;">
                    <option value="">--- 请选择一个人设预设 ---</option>
                </select>
            </div>
                <div class="button-group" style="margin-top: 10px;">
                    <button class="btn-save" id="save-contact-btn">保存联系人</button>
                </div>

                <button id="add-contact-close-btn" class="close-btn">×</button>
            </div>
        </div>
        
        </div>
  <div id="worldbook-list-screen" class="dialogue-list-screen hidden">
    <nav class="theme-nav">
        <button id="worldbook-back-btn" class="back-btn">&lt;</button>
        <h2>世界书</h2>
        <button id="worldbook-add-btn" class="nav-action-btn">+</button>
    </nav>
    
    <div style="padding: 10px 15px; border-bottom: 1px solid #f0f0f0;">
        <label for="worldbook-category-filter" style="font-size: 14px; color: #555;">筛选分类:</label>
        <select id="worldbook-category-filter" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc; margin-top: 5px;">
            <option value="all">--- 全部 ---</option>
            </select>
    </div>
    
    <div id="worldbook-list-content" class="dialogue-list-content">
        <p class="empty-list-message">暂无条目，点击右上角 + 号开始添加</p>
    </div>
</div>


<div id="entry-editor-screen" class="dialogue-list-screen hidden">
    <nav class="theme-nav">
        <button id="entry-editor-back-btn" class="back-btn">&lt;</button>
        <h2 id="entry-editor-title">添加新条目</h2>
    </nav>
    
    <div class="theme-content">
        <div class="setting-item">
            <label for="entry-name-input">条目名称</label>
            <input type="text" id="entry-name-input" placeholder="例如：月光森林">
        </div>
        
        <div class="setting-item">
            <label for="entry-category-select">选择分类</label>
            <select id="entry-category-select" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;">
                <option value="">--- 请先去“管理分类”中添加分类 ---</option>
                </select>
        </div>
        
        <div class="setting-item">
            <label for="entry-content-textarea">条目内容</label>
            <textarea id="entry-content-textarea" rows="10" placeholder="输入关于这个条目的详细描述..." style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
        </div>
        
        <div class="button-group" style="margin-top: 10px;">
            <button class="btn-save" id="entry-save-btn">保存条目</button>
        </div>
    </div>
</div>


<div id="category-manager-screen" class="dialogue-list-screen hidden">
    <nav class="theme-nav">
        <button id="category-manager-back-btn" class="back-btn">&lt;</button>
        <h2>管理分类</h2>
    </nav>
    
    <div class="theme-content">
        <div class="editor-section">
            <div class="input-group">
                <input type="text" id="category-name-input" placeholder="输入新分类名称 (例如: 人物)" style="border-radius: 8px;">
                <button id="category-add-btn" class="btn-save" style="margin-left: 10px;">添加</button>
            </div>
        </div>
        
        <div class="editor-section">
            <h4>我的分类</h4>
            <div id="category-list-container" style="max-height: 300px; overflow-y: auto;">
                <p style="font-size: 12px; color: #777; text-align: center;">暂无分类</p>
                </div>
        </div>
    </div>
</div>


<div id="worldbook-add-menu" class="popup hidden" style="background-color: rgba(0,0,0,0.3); z-index: 250;">
    <div class="popup-content" style="width: 200px; max-height: 200px; padding: 15px;">
        <button id="worldbook-menu-add-entry" class="file-label" style="margin: 0 0 10px 0;">
            + 添加新条目
        </button>
        <button id="worldbook-menu-manage-categories" class="file-label" style="margin: 0; background-color: rgba(88, 86, 214, 0.8);">
            🏷️ 管理分类
        </button>
        </div>
</div>
  <div id="contact-settings-screen" class="dialogue-list-screen hidden" style="background-color: #f0f0f0;">
    <nav class="theme-nav">
        <button id="contact-settings-back-btn" class="back-btn">&lt;</button>
        <h2 id="contact-settings-title">角色设置</h2>
    </nav>
    
    <div class="theme-content">
        <div class="accordion-item">
            <div class="accordion-content expanded" style="padding-top: 15px;">
                <div class="setting-item" style="text-align: center;">
                    <img id="contact-settings-avatar" src="./assets/default-avatar.png" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid #eee;">
                    <label for="contact-settings-avatar-input" class="file-label" style="background-color: rgba(0, 122, 255, 0.8); width: 150px; margin: 10px auto 0 auto; padding: 8px 0;">
                        修改头像
                    </label>
                    <input type="file" id="contact-settings-avatar-input" accept="image/*" style="display: none;">
                </div>
                
                <div class="setting-item">
                    <label for="contact-settings-name-input">角色名字</label>
                    <input type="text" id="contact-settings-name-input" placeholder="例如: 夏洛克·福尔摩斯">
                </div>
                
                <div class="setting-item">
                    <label for="contact-settings-remark-input">备注 (你自己看的)</label>
                    <input type="text" id="contact-settings-remark-input" placeholder="例如: 宝宝、宝贝">
                </div>
                
           <div class="setting-item">
    <label for="contact-settings-persona-input">人设 (Persona)</label>
    <textarea id="contact-settings-persona-input" rows="5" style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
</div>

<!-- 【新添加】选择"我的人设" -->
<div class="setting-item">
    <label for="contact-settings-mypersona-preset-select">更换与 Ta 聊天时使用的人设</label>
    <select id="contact-settings-mypersona-preset-select" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;">
        <option value="">--- 请选择一个人设预设 ---</option>
    </select>
</div>
              <!-- 【新添加】我的人设补充 -->
<div class="setting-item">
    <label for="contact-settings-mypersona-supplement-input">我的人设补充（专属于此角色）</label>
    <textarea id="contact-settings-mypersona-supplement-input" rows="4" placeholder="例如：在和这个角色聊天时，我是一个对魔法感兴趣的初学者..." style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
    <p style="font-size: 12px; color: #777; margin-top: 5px;">
        这段描述会和你选择的人设合并，让角色更了解你在这段关系中的角色
    </p>
</div>
            </div>
        </div>
     
        <div class="accordion-item">
            <div class="accordion-content expanded" style="padding-top: 15px;">
                <div class="setting-item">
                    <label>AI 是否能读取本地时间?</label>
                    <div class="toggle-switch" id="contact-settings-time-toggle">
                        <div class="toggle-label">否</div>
                        <div class="toggle-handle"></div>
                        <div class="toggle-label">是</div>
                    </div>
                </div>
              <div class="setting-item">
    <label>是否显示头像?</label>
    <div class="toggle-switch" id="contact-settings-avatar-toggle">
        <div class="toggle-label">否</div>
        <div class="toggle-handle"></div>
        <div class="toggle-label">是</div>
    </div>
                <div class="setting-item">
    <label>是否启用情侣头像?</label>
    <div class="toggle-switch" id="contact-settings-couple-avatar-toggle">
        <div class="toggle-label">否</div>
        <div class="toggle-handle"></div>
        <div class="toggle-label">是</div>
    </div>
</div>

</div>

<!-- 【修改】自动发朋友圈功能 -->
<div class="setting-item">
    <label>自动发朋友圈</label>
    <div class="toggle-switch" id="contact-settings-auto-moment-toggle">
        <div class="toggle-label">否</div>
        <div class="toggle-handle"></div>
        <div class="toggle-label">是</div>
    </div>
</div>

<!-- 【新增】发布间隔时间（默认隐藏） -->
<div class="setting-item hidden" id="moment-interval-container">
    <label for="contact-settings-moment-interval">发布间隔（分钟）</label>
    <div class="slider-group">
        <input type="range" id="contact-settings-moment-interval" min="1" max="60" value="5" step="1">
        <input type="number" id="contact-settings-moment-interval-value" min="1" max="60" value="5" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 5px; text-align: center;">
        <span style="margin-left: 5px;">分钟</span>
    </div>
    <p style="font-size: 12px; color: #777; margin-top: 5px;">
        每隔多久自动发一次朋友圈
    </p>
</div>

<!-- 【新增】冷却时间（默认隐藏） -->
<div class="setting-item hidden" id="moment-cooldown-container">
    <label for="contact-settings-moment-cooldown">冷却时间（分钟，最多10小时）</label>
    <div class="slider-group">
        <input type="range" id="contact-settings-moment-cooldown" min="1" max="6000" value="10" step="1">
        <input type="number" id="contact-settings-moment-cooldown-value" min="1" max="600" value="10" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 5px; text-align: center;">
        <span style="margin-left: 5px;">分钟</span>
    </div>
    <p style="font-size: 12px; color: #777; margin-top: 5px;">
        发布后必须等待的冷却时间
    </p>
</div>

              
<!-- 【新添加】上下文参考轮数 -->
<div class="setting-item">
    <label for="contact-settings-context-slider">上下文参考</label>
    <div class="slider-group">
        <input type="range" id="contact-settings-context-slider" min="5" max="200" value="10" step="1">
        <input type="number" id="contact-settings-context-value" min="5" max="200" value="10" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 5px; text-align: center;">
    </div>
    <p style="font-size: 12px; color: #777; margin-top: 5px;">
        设置越大，AI 记得越多，但响应可能变慢。建议：10-30轮
    </p>
</div>
                <div class="setting-item">
                    <label>聊天背景</label>
                    <label for="contact-settings-bg-input" class="file-label" style="background-color: rgba(76, 217, 100, 0.8); margin: 0;">
                        上传自定义背景
                    </label>
                    <input type="file" id="contact-settings-bg-input" accept="image/*" style="display: none;">
                <button id="contact-settings-bg-clear-btn" class="btn-clear" style="width: 100%; margin-top: 10px; padding: 8px;">清除背景</button>
                </div>
                
                <div class="setting-item">
                    <label>关联世界书 (专属记忆)</label>
             <button id="contact-settings-link-worldbook-btn" class="btn-save" style="width: 100%; background-color: #5856d6; padding: 10px;">
                        管理关联条目
                    </button>
                </div>
            </div>
        </div>

        <div class="button-group" style="margin-top: 10px;">
            <button class="btn-save" id="contact-settings-save-btn" style="width: 100%; padding: 12px; font-size: 16px;">保存更改</button>
        </div>
    </div>
</div>

<div id="worldbook-linker-screen" class="dialogue-list-screen hidden">
    <nav class="theme-nav">
        <button id="worldbook-linker-back-btn" class="back-btn">&lt;</button>
        <h2 id="worldbook-linker-title">关联世界书</h2>
    </nav>
    
    <div id="worldbook-linker-list" class="dialogue-list-content" style="padding: 0;">
        </div>
</div>
 <div id="me-screen" class="dialogue-list-screen hidden" style="background-color: #f9f9f9;">
    <nav class="theme-nav">
        <button id="me-back-btn" class="back-btn">&lt;</button>
        <h2>个人中心</h2>
    </nav>
    
    <div class="theme-content">
        <!-- 人设切换手风琴 -->
        <div class="accordion-item">
            <div class="accordion-header" id="persona-accordion-header">
                <span>人设切换</span>
                <span class="arrow">&gt;</span>
            </div>
            <div class="accordion-content" id="persona-accordion-content">
              <!-- 顶部按钮区 -->
<div id="persona-buttons" style="margin-bottom: 15px;">
    <button id="persona-add-btn" class="btn-save" style="background-color: #4cd964;">新增</button>
    <button id="persona-manage-btn" class="btn-clear">管理</button>
</div>

                
                <!-- 人设列表容器 -->
                <div id="my-persona-list-container" style="max-height: 300px; overflow-y: auto;">
                    <p style="font-size: 12px; color: #777; text-align: center;">暂无人设</p>
                </div>
            </div>
        </div>
      
<!-- 【新添加】表情包库手风琴 -->

<div class="accordion-item">
    <div class="accordion-header" id="sticker-accordion-header">
        <span>表情包设置</span>
        <span class="arrow">&gt;</span>
    </div>
 <div class="accordion-content" id="sticker-accordion-content">
    
    <!-- 批量导入 -->
    <div class="setting-item" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <span style="font-weight: 500; font-size: 15px;">批量导入表情包</span>
        <button class="sticker-select-btn" id="import-sticker-btn">导入</button>
    </div>
    
    <!-- 删除这一段（不再需要"角色选择"）-->
    <!-- 已导入的表情包库 -->
    <div class="setting-item" style="margin-top: 20px;">
        <p style="font-size: 13px; color: #888; text-align: center; margin-bottom: 10px;">─── 已导入的表情包库 ───</p>
        <div id="sticker-libraries-container">
            <p style="font-size: 12px; color: #777; text-align: center;">暂无表情包库</p>
        </div>
    </div>
    
</div>

</div>

<!-- 情侣头像设置弹窗 -->
<div id="couple-avatar-popup" class="popup solid-popup hidden">
    <div class="popup-content solid-popup-content" style="width: 320px; max-height: 600px;">
        <h3>设置情侣头像</h3>
        
        <!-- 用户头像 -->
        <div class="setting-item">
            <label>我的头像</label>
            <div class="avatar-preview-container">
                <img id="couple-user-avatar-preview" src="./assets/default-avatar.png" alt="我的头像" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid #007aff;">
            </div>
            <label for="couple-user-avatar-input" class="file-label" style="background-color: rgba(0, 122, 255, 0.8);">
                上传我的头像
            </label>
            <input type="file" id="couple-user-avatar-input" accept="image/*" style="display: none;">
        </div>
        
        <!-- AI头像 -->
        <div class="setting-item">
            <label>对方头像</label>
            <div class="avatar-preview-container">
                <img id="couple-bot-avatar-preview" src="./assets/default-avatar.png" alt="对方头像" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid #ff3b30;">
            </div>
            <label for="couple-bot-avatar-input" class="file-label" style="background-color: rgba(255, 59, 48, 0.8);">
                上传对方头像
            </label>
            <input type="file" id="couple-bot-avatar-input" accept="image/*" style="display: none;">
        </div>
        
        <div class="button-group" style="margin-top: 20px;">
            <button class="btn-clear" id="couple-avatar-cancel-btn">取消</button>
            <button class="btn-save" id="couple-avatar-save-btn">保存</button>
        </div>
        
        <button id="couple-avatar-close-btn" class="close-btn">×</button>
    </div>
</div>


        <!-- 未来可以在这里添加其他手风琴项 -->
    </div>
</div>


<div id="persona-editor-popup" class="popup solid-popup hidden" style="z-index: 270;">
    <div class="popup-content solid-popup-content" style="width: 320px; max-height: 550px; text-align: left;">
        <h3 id="persona-editor-title">编辑人设</h3>
        
        <div class="avatar-preview-container">
            <img id="persona-avatar-preview" src="./assets/default-avatar.png" alt="头像预览" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover;">
        </div>
        
        <label for="persona-avatar-input" class="file-label" style="background-color: rgba(0, 122, 255, 0.8);">
            上传头像
        </label>
        <input type="file" id="persona-avatar-input" accept="image/*" style="display: none;">

        <div class="setting-item">
            <label for="persona-name-input">人设名称</label>
            <input type="text" id="persona-name-input" placeholder="例如：职场精英的我">
        </div>
        
        <div class="setting-item">
            <label for="persona-desc-input">人设描述</label>
            <textarea id="persona-desc-input" rows="6" placeholder="输入详细描述..." style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
        </div>

        <div class="button-group" style="margin-top: 10px;">
            <button class="btn-save" id="save-persona-btn">保存</button>
        </div>

        <button id="persona-editor-close-btn" class="close-btn">×</button>
    </div>
</div>
  <div id="memory-screen" class="dialogue-list-screen hidden" style="background-color: #f9f9f9;">
    <nav class="theme-nav">
        <button id="memory-back-btn" class="back-btn">&lt;</button>
        <h2>记忆 & 总结</h2>
    </nav>

  <div class="setting-item" id="summary-character-selector-btn" style="background-color: white; padding: 20px 15px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05); cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
    <span id="summary-selected-character-name" style="font-size: 16px; color: #777;">请选择要管理的角色...</span>
    <span style="font-size: 20px; font-family: monospace; color: #777;">&gt;</span>
</div>

<div id="summary-settings-container" class="hidden">

    <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 12px; margin-top: 15px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);">
        <h4 style="margin: 0 0 15px 0; font-size: 16px;">自动总结</h4>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <label style="margin: 0; font-weight: 500;">开启自动总结</label>
            <div class="toggle-switch" id="summary-auto-toggle" style="transform: scale(0.9);">
                <div class="toggle-label">否</div>
                <div class="toggle-handle"></div>
                <div class="toggle-label">是</div>
            </div>
        </div>

        <label for="summary-rounds-slider">总结频率</label>
        <div class="slider-group">
         <input type="range" id="summary-rounds-slider" min="0" max="200" value="20" step="1">
         <input type="number" id="summary-rounds-value" min="0" max="200" value="20" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 5px; text-align: center;">

        </div>
    </div>

    <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 12px; margin-top: 15px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);">
        <h4 style="margin: 0 0 15px 0; font-size: 16px;">手动总结</h4>
        <label>聊天统计</label>
        <p id="summary-stats-display" style="font-size: 14px; color: #555; margin: 5px 0 15px 0;">请先选择一个角色</p>
        <button id="summary-manual-btn" class="btn-save" style="width: 100%; background-color: #4cd964;">立即手动总结 (未总结部分)</button>
    </div>

    <div class="setting-item" style="background-color: white; padding: 15px; border-radius: 12px; margin-top: 15px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);">
        <h4 style="margin: 0 0 15px 0; font-size: 16px;">AI 总结内容 (可编辑)</h4>
        <textarea id="summary-textarea" rows="10" placeholder="AI 总结将显示在这里..." style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
        <button id="summary-save-text-btn" class="btn-save" style="width: 100%; margin-top: 10px;">保存修改</button>
    </div>

</div>
    <div id="character-selector-screen" class="dialogue-list-screen hidden" style="background-color: #f9f9f9;">

    <nav class="theme-nav">
        <button id="character-selector-back-btn" class="back-btn">&lt;</button>
        <h2>选择角色</h2>
    </nav>

    <div class="theme-content">

        <div class="setting-item" style="margin-bottom: 0;">
            <input type="text" id="character-search-input" placeholder="输入角色名搜索..." style="width: calc(100% - 20px);">
        </div>

        <div id="character-selector-list" class="dialogue-list-content" style="padding: 0; margin-top: 15px;">
            <p class="empty-list-message" style="margin-top: 20px;">正在加载联系人...</p>
        </div>

    </div>
</div>

<!-- 【新添加】导入表情包弹窗 -->
<div id="import-sticker-popup" class="popup solid-popup hidden" style="z-index: 280;">
    <div class="popup-content solid-popup-content" style="width: 320px; max-height: 600px;">
        <h3>导入表情包</h3>
        
        <div class="setting-item">
            <label for="sticker-library-name-input">表情包库名称</label>
            <input type="text" id="sticker-library-name-input" placeholder="例如：日常表情">
        </div>
        
        <div class="setting-item">
            <label for="sticker-batch-input">批量粘贴链接</label>
            <textarea id="sticker-batch-input" rows="6" placeholder="每行一个表情包，支持格式：&#10;笑哭+https://example.com/1.png&#10;笑哭：https://example.com/1.png&#10;笑哭,https://example.com/1.png" style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical; font-size: 12px;"></textarea>
        </div>
        
        <div style="background-color: #f9f9f9; padding: 10px; border-radius: 8px; margin-top: 10px;">
            <p style="font-size: 11px; color: #666; margin: 0 0 5px 0; font-weight: bold;">格式说明：</p>
            <p style="font-size: 11px; color: #666; margin: 0;">• 文本+URL</p>
            <p style="font-size: 11px; color: #666; margin: 0;">• 文本：URL</p>
            <p style="font-size: 11px; color: #666; margin: 0;">• 文本,URL</p>
        </div>
        
        <!--  预览区域 -->
        <div class="setting-item" style="margin-top: 15px;">
            <label>预览 (<span id="preview-count">0</span> 个表情包)</label>
            <div id="sticker-preview-grid" style="max-height: 200px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 8px; padding: 10px; background-color: #fafafa;">
                <p style="font-size: 12px; color: #999; text-align: center;">输入链接后自动预览</p>
            </div>
        </div>
        
        <div class="button-group" style="margin-top: 15px;">
            <button class="btn-clear" id="import-sticker-cancel-btn">取消</button>
            <button class="btn-save" id="import-sticker-confirm-btn">确认导入</button>
        </div>
        
        <button id="import-sticker-close-btn" class="close-btn">×</button>
    </div>
</div>


<!-- 【新添加】选择表情库弹窗 -->
<div id="select-sticker-popup" class="popup solid-popup hidden" style="z-index: 280;">
    <div class="popup-content solid-popup-content" style="width: 300px; max-height: 450px;">
        <h3 id="select-sticker-popup-title">选择表情包库</h3>
        
        <div id="sticker-checkbox-list" style="max-height: 300px; overflow-y: auto;">
            <p style="font-size: 12px; color: #777; text-align: center; padding: 20px;">暂无可选的表情包库</p>
        </div>
        
        <div class="button-group" style="margin-top: 15px;">
            <button class="btn-clear" id="select-sticker-cancel-btn">取消</button>
            <button class="btn-save" id="select-sticker-confirm-btn">确认</button>
        </div>
        
        <button id="select-sticker-close-btn" class="close-btn">×</button>
    </div>
</div>
<!-- 【新添加】查看表情库弹窗 -->
<div id="view-sticker-popup" class="popup solid-popup hidden" style="z-index: 280;">
    <div class="popup-content solid-popup-content" style="width: 340px; max-height: 600px;">
        <h3 id="view-sticker-popup-title">查看表情包库</h3>
        
        <div style="padding: 10px; background-color: #f9f9f9; border-radius: 8px; margin-bottom: 15px;">
            <p style="margin: 0; font-size: 14px; color: #555;">
                📦 <strong id="view-library-name">库名称</strong>
            </p>
            <p style="margin: 5px 0 0 0; font-size: 13px; color: #888;">
                共 <span id="view-sticker-count">0</span> 个表情包
            </p>
        </div>
        
        <div id="view-sticker-grid" class="sticker-grid" style="max-height: 400px; overflow-y: auto; padding: 10px; border: 1px solid #e0e0e0; border-radius: 8px; background-color: #fafafa;">
            <p style="font-size: 12px; color: #999; text-align: center;">加载中...</p>
        </div>
        
        <div class="button-group" style="margin-top: 15px;">
            <button class="btn-clear" id="view-sticker-close-btn2">关闭</button>
        </div>
        
        <button id="view-sticker-close-btn" class="close-btn">×</button>
    </div>
</div>
<!-- 消息编辑弹窗 -->
<div id="message-edit-popup" class="popup hidden">
    <div class="popup-content">
        <h3>编辑消息</h3>
        <div class="setting-item">
            <label for="message-edit-textarea">修改内容</label>
            <textarea id="message-edit-textarea" rows="5" placeholder="编辑消息内容..."></textarea>
        </div>
        <div class="button-group" style="margin-top: 15px;">
            <button class="btn-clear" id="message-edit-cancel-btn">取消</button>
            <button class="btn-save" id="message-edit-save-btn">保存</button>
        </div>
        <button id="message-edit-close-btn" class="close-btn">×</button>
    </div>
</div>




    <script>
      // ======================================================
// 【iOS修复】防止键盘弹出时的缩放问题
// ======================================================

// 禁用双击缩放
let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
        event.preventDefault();
    }
    lastTouchEnd = now;
}, false);

// 禁用手势缩放
document.addEventListener('gesturestart', function (e) {
    e.preventDefault();
});

      // ======================================================
//  移动端浏览器视口高度修复（兼容 iOS 和 Android）
// ======================================================
// ======================================================
// 【改进版】移动端浏览器视口高度修复（兼容 iOS 键盘）
// ======================================================

// ======================================================
// 【改进版】移动端浏览器视口高度修复（兼容所有输入框）
// ======================================================

// 1. 定义全局变量
let originalViewportHeight = window.innerHeight;
let isKeyboardOpen = false;

// 2. 修改后的视口高度计算函数
function setRealViewportHeight() {
    const currentHeight = window.innerHeight;
    
    // 【关键】检测键盘是否弹出（高度显著减少）
    if (originalViewportHeight - currentHeight > 150) {
        isKeyboardOpen = true;
        return; // 键盘弹出时，不更新 --vh 变量
    }
    
    // 【关键】检测键盘是否收起（高度恢复）
    if (isKeyboardOpen && Math.abs(originalViewportHeight - currentHeight) < 50) {
        isKeyboardOpen = false;
        originalViewportHeight = currentHeight;
    }
    
    // 正常情况下更新 CSS 变量
    const vh = currentHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
}

// 3. 页面加载时执行
setRealViewportHeight();

// 4. 监听窗口大小变化（使用防抖）
window.addEventListener('resize', () => {
    clearTimeout(window.resizeTimer);
    window.resizeTimer = setTimeout(setRealViewportHeight, 100);
});

// 5. 监听屏幕方向变化
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        originalViewportHeight = window.innerHeight;
        isKeyboardOpen = false;
        setRealViewportHeight();
    }, 200);
});

// 6. visualViewport API（现代浏览器）
if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => {
        clearTimeout(window.viewportTimer);
        window.viewportTimer = setTimeout(setRealViewportHeight, 100);
    });
}

// 7. 【核心修复】监听所有输入框的聚焦/失焦
document.addEventListener('focusin', (e) => {
    const target = e.target;
    
    // 检查是否是输入元素
    if (target.tagName === 'INPUT' || 
        target.tagName === 'TEXTAREA' || 
        target.isContentEditable) {
        
        console.log('输入框获得焦点:', target.id || target.className);
        
        // 延迟检测键盘
        setTimeout(() => {
            const currentHeight = window.innerHeight;
            if (originalViewportHeight - currentHeight > 150) {
                isKeyboardOpen = true;
                console.log('键盘已弹出');
            }
        }, 300);
    }
});

document.addEventListener('focusout', (e) => {
    const target = e.target;
    
    // 检查是否是输入元素
    if (target.tagName === 'INPUT' || 
        target.tagName === 'TEXTAREA' || 
        target.isContentEditable) {
        
     //   console.log('输入框失去焦点:', target.id || target.className);
        
        // 延迟检测键盘收起
        setTimeout(() => {
            if (isKeyboardOpen) {
                isKeyboardOpen = false;
                setRealViewportHeight();
                console.log('键盘已收起');
            }
        }, 300);
    }
});



// 2. 页面加载时立即执行
setRealViewportHeight();

// 3. 监听窗口大小变化（例如横竖屏切换、键盘弹出）
window.addEventListener('resize', setRealViewportHeight);

// 4. 监听屏幕方向变化（移动端特有）
window.addEventListener('orientationchange', setRealViewportHeight);

// 5. 【iOS Safari 特殊处理】监听滚动事件
// iOS 在滚动时地址栏会隐藏/显示，导致视口高度变化
let scrollTimeout;
window.addEventListener('scroll', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(setRealViewportHeight, 100);
});

// 6. 【Android Chrome 特殊处理】监听 visualViewport 变化
if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', setRealViewportHeight);
}

    // ======================================================
    // 数据库定义
    // ======================================================
    const db = new Dexie('MyPhoneDatabase');
    db.version(1).stores({
        settings: '&key', 
        files: '&key',
        contacts: '++id, name',
        chatMessages: '++id, contactId',
        apiPresets: '++id, name',
        worldbook_categories: '++id, name',
        worldbook_entries: '++id, categoryId, name'
    });
db.version(6).stores({
    contacts: '++id, name, remark, summarySettings, aiSummaryText, myPersonaSupplement, contextRounds',
    contact_worldbook_links: '[contactId+worldbookEntryId], contactId',
    my_persona_presets: '++id, name',
    sticker_libraries: '++id, name',
    stickers: '++id, libraryId, text, url',
    user_sticker_selection: 'key, libraryIds',
    role_sticker_selection: 'key, libraryIds',
    
    // 【新增】朋友圈相关的表
    moments: '++id, contactId, timestamp',           // 朋友圈动态
    moment_comments: '++id, momentId, contactId, timestamp'  // 评论
});
    
    // ======================================================
    // 全局变量
    // ======================================================
    let defaultIconSvgData = {};
    let currentEditingWidgetId = null; 
      let currentEditingMessageId = null; // 当前正在编辑的消息ID
      let currentImageMode = 'real'; // 'real' 或 'text'


    let currentOpenContactId = null; 
    let currentSelectedPresetId = null; 
let currentSummaryContactId = null; // 跟踪当前正在编辑总结的角色
let summarySearchTimeout = null; // 用于搜索防抖
    // ======================================================
    // 元素抓取 (Query Selectors)
    // ======================================================
  
    const phoneScreen = document.querySelector('.phone-screen');
    const appGrid = document.querySelector('.app-grid');
    const dock = document.querySelector('.dock');
    const topLeftText = document.querySelector('#top-left-text');
    const topRightText = document.querySelector('#top-right-text');
    const dateDisplay = document.querySelector('#date-display');
    const timeDisplay = document.querySelector('#time-display');
    const largeWidget = document.querySelector('.widget-3x2');
    const editableSlimWidgets = document.querySelectorAll('.widget-2x1-slim');
    const themeAppIcon = document.querySelector('#theme-app-icon');
    const themeScreen = document.querySelector('.theme-screen');
    const backToHomeBtn = document.querySelector('#back-to-home-btn');
    const accordionHeader1 = document.querySelector('#accordion-header-1');
    const accordionContent1 = document.querySelector('#accordion-content-1');
    const leftTextInput = document.querySelector('#left-text-input');
    const rightTextInput = document.querySelector('#right-text-input');
    const saveTextBtn = document.querySelector('#save-text-btn');
    const clearTextBtn = document.querySelector('#clear-text-btn');
    const fontSizeSlider = document.querySelector('#font-size-slider');
    const fontSizeValue = document.querySelector('#font-size-value');
    const accordionHeader2 = document.querySelector('#accordion-header-2');
    const accordionContent2 = document.querySelector('#accordion-content-2');
    const darkModeToggle = document.querySelector('#dark-mode-toggle');
    const accordionHeader3 = document.querySelector('#accordion-header-3');
    const accordionContent3 = document.querySelector('#accordion-content-3');
      const contactSettingsAvatarToggle = document.querySelector('#contact-settings-avatar-toggle');
const contactSettingsCoupleAvatarToggle = document.querySelector('#contact-settings-couple-avatar-toggle');
const coupleAvatarPopup = document.querySelector('#couple-avatar-popup');
const coupleUserAvatarPreview = document.querySelector('#couple-user-avatar-preview');
const coupleUserAvatarInput = document.querySelector('#couple-user-avatar-input');
const coupleBotAvatarPreview = document.querySelector('#couple-bot-avatar-preview');
const coupleBotAvatarInput = document.querySelector('#couple-bot-avatar-input');
const coupleAvatarSaveBtn = document.querySelector('#couple-avatar-save-btn');
const coupleAvatarCancelBtn = document.querySelector('#couple-avatar-cancel-btn');
const coupleAvatarCloseBtn = document.querySelector('#couple-avatar-close-btn');

      //  聊天界面美化的元素抓取
const accordionHeader4 = document.querySelector('#accordion-header-4');
const accordionContent4 = document.querySelector('#accordion-content-4');
const chatNavBgColor = document.querySelector('#chat-nav-bg-color');
const chatNavTextColor = document.querySelector('#chat-nav-text-color');
const chatNavBgUrl = document.querySelector('#chat-nav-bg-url');
const chatNavBgFile = document.querySelector('#chat-nav-bg-file');
const chatNavBgPreview = document.querySelector('#chat-nav-bg-preview');
const chatWallpaperUrl = document.querySelector('#chat-wallpaper-url');
const chatWallpaperFile = document.querySelector('#chat-wallpaper-file');
const chatWallpaperPreview = document.querySelector('#chat-wallpaper-preview');
const chatWallpaperBlur = document.querySelector('#chat-wallpaper-blur');
const chatWallpaperBlurValue = document.querySelector('#chat-wallpaper-blur-value');
const chatWallpaperOpacity = document.querySelector('#chat-wallpaper-opacity');
const chatWallpaperOpacityValue = document.querySelector('#chat-wallpaper-opacity-value');
      //  底部导航栏的元素
const chatBottomBgColor = document.querySelector('#chat-bottom-bg-color');
const chatBottomBgUrl = document.querySelector('#chat-bottom-bg-url');
const chatBottomBgFile = document.querySelector('#chat-bottom-bg-file');
const chatBottomBgPreview = document.querySelector('#chat-bottom-bg-preview');

const chatInputBgColor = document.querySelector('#chat-input-bg-color');
const chatInputTextColor = document.querySelector('#chat-input-text-color');
const chatInputBorderColor = document.querySelector('#chat-input-border-color');
const chatInputRadius = document.querySelector('#chat-input-radius');
const chatInputRadiusValue = document.querySelector('#chat-input-radius-value');
const saveChatStyleBtn = document.querySelector('#save-chat-style-btn');
const clearChatStyleBtn = document.querySelector('#clear-chat-style-btn');

    const iconUrlInputs = {
        dialogue: document.querySelector('#icon-url-dialogue'),
        worldbook: document.querySelector('#icon-url-worldbook'),
        forum: document.querySelector('#icon-url-forum'),
      me: document.querySelector('#icon-url-me'),
        settings: document.querySelector('#icon-url-settings'),
        theme: document.querySelector('#icon-url-theme'),
        memory: document.querySelector('#icon-url-memory')
    };
  
    const saveIconsBtn = document.querySelector('#save-icons-btn');
    const clearIconsBtn = document.querySelector('#clear-icons-btn');
    const iconElements = {
        dialogue: document.querySelector('#icon-dialogue'),
        worldbook: document.querySelector('#icon-worldbook'),
        forum: document.querySelector('#icon-forum'),
      me: document.querySelector('#icon-me'),
        settings: document.querySelector('#icon-settings'),
        theme: document.querySelector('#theme-app-icon'),
        memory: document.querySelector('#icon-memory')
    };
  
    const iconKeys = Object.keys(iconElements); 
    const settingsAppIcon = document.querySelector('#icon-settings'); 
    const settingsScreen = document.querySelector('.settings-screen'); 
    const settingsBackBtn = document.querySelector('#settings-back-btn'); 
    const apiAccordionHeader = document.querySelector('#api-accordion-header');
    const apiAccordionContent = document.querySelector('#api-accordion-content');
    const apiPresetSelector = document.querySelector('#api-preset-selector');
    const apiPresetNameInput = document.querySelector('#api-preset-name-input');
    const apiKeyInput = document.querySelector('#api-key-input');
    const apiBaseUrlInput = document.querySelector('#api-base-url-input');
    const apiModelInput = document.querySelector('#api-model-input');
    const fetchModelsBtn = document.querySelector('#fetch-models-btn');
    const modelSelectorContainer = document.querySelector('#model-selector-container');
    const apiPresetSaveBtn = document.querySelector('#api-preset-save-btn');
    const apiPresetNewBtn = document.querySelector('#api-preset-new-btn');
    const apiPresetDeleteBtn = document.querySelector('#api-preset-delete-btn');
  const apiSummaryPresetSelector = document.querySelector('#api-summary-preset-selector'); // 【新】总结API的选择框
  const dialogueAppIcon = document.querySelector('#icon-dialogue'); 
    const dialogueListScreen = document.querySelector('.dialogue-list-screen');
    const dialogueListBackBtn = document.querySelector('#dialogue-list-back-btn');
    const newChatBtn = document.querySelector('#new-chat-btn');
    const chatWindowScreen = document.querySelector('.chat-window-screen');
    const chatWindowBackBtn = document.querySelector('#chat-window-back-btn');
    const messageContainer = document.querySelector('#message-container');
    const chatInputBox = document.querySelector('#chat-input-box');
    const sendMessageBtn = document.querySelector('#send-message-btn');
    const addContactPopup = document.querySelector('#add-contact-popup');
    const addContactCloseBtn = document.querySelector('#add-contact-close-btn');
    const contactAvatarPreview = document.querySelector('#contact-avatar-preview');
    const contactAvatarFileInput = document.querySelector('#contact-avatar-file-input');
    const contactNameInput = document.querySelector('#contact-name-input');
    const contactPersonaInput = document.querySelector('#contact-persona-input');
    const saveContactBtn = document.querySelector('#save-contact-btn');
    const timeWidget = document.querySelector('.time-widget');
    const themePopup = document.querySelector('#theme-popup');
    const closePopupBtn = document.querySelector('#close-popup-btn');
    const imageUrlInput = document.querySelector('#image-url-input');
    const urlSubmitBtn = document.querySelector('#url-submit-btn');
    const localFileInput = document.querySelector('#local-file-input');
    const widgetEditorPopup = document.querySelector('#widget-editor-popup');
    const widgetEditorCloseBtn = document.querySelector('#widget-editor-close-btn');
    const widgetBgUrlInput = document.querySelector('#widget-bg-url-input');
    const widgetBgFileInput = document.querySelector('#widget-bg-file-input');
    const widgetTextInput = document.querySelector('#widget-text-input');
    const widgetSaveBtn = document.querySelector('#widget-save-btn');
    const widgetClearBtn = document.querySelector('#widget-clear-btn');
    const widgetAvatarUrlInput = document.querySelector('#widget-avatar-url-input');
    const widgetAvatarFileInput = document.querySelector('#widget-avatar-file-input');
    const widgetAvatarImage = document.querySelector('#widget-avatar-image');
    const avatarEditorSection = document.querySelector('#avatar-editor-section');
    const widgetTextColorInput = document.querySelector('#widget-text-color-input');
    
    // 【新功能】抓住两个新的预览框
    const widgetBgPreview = document.querySelector('#widget-bg-preview');
    const widgetAvatarPreview = document.querySelector('#widget-avatar-preview');

    const worldbookListScreen = document.querySelector('#worldbook-list-screen');
    const entryEditorScreen = document.querySelector('#entry-editor-screen');
    const categoryManagerScreen = document.querySelector('#category-manager-screen');
    const worldbookAddMenu = document.querySelector('#worldbook-add-menu');
    const worldbookAppIcon = document.querySelector('#icon-worldbook'); 
    const worldbookBackBtn = document.querySelector('#worldbook-back-btn');
    const worldbookAddBtn = document.querySelector('#worldbook-add-btn');
    const worldbookMenuAddEntry = document.querySelector('#worldbook-menu-add-entry');
    const worldbookMenuManageCategories = document.querySelector('#worldbook-menu-manage-categories');
    const entryEditorBackBtn = document.querySelector('#entry-editor-back-btn');
    const entrySaveBtn = document.querySelector('#entry-save-btn');
    const categoryManagerBackBtn = document.querySelector('#category-manager-back-btn');
    const categoryAddBtn = document.querySelector('#category-add-btn');
    const worldbookCategoryFilter = document.querySelector('#worldbook-category-filter');
    const worldbookListContent = document.querySelector('#worldbook-list-content');
    const entryNameInput = document.querySelector('#entry-name-input');
    const entryCategorySelect = document.querySelector('#entry-category-select');
    const entryContentTextarea = document.querySelector('#entry-content-textarea');
    const categoryNameInput = document.querySelector('#category-name-input');
    const categoryListContainer = document.querySelector('#category-list-container');
    const entryEditorTitle = document.querySelector('#entry-editor-title');
    let currentEditingEntryId = null; 
    let longPressTimer; 
  
  let currentEditingPersonaId = null;
  let isManageMode = false;
  // 【新添加】表情包功能的全局变量
let currentStickerSelectionType = null; // 'user' 或 'role'
let currentViewingLibraryId = null; // 当前正在查看的表情库ID

    const contactSettingsBtn = document.querySelector('#contact-settings-btn'); 
    const contactSettingsBackBtn = document.querySelector('#contact-settings-back-btn');
    const contactSettingsAvatarInput = document.querySelector('#contact-settings-avatar-input');
    const contactSettingsTimeToggle = document.querySelector('#contact-settings-time-toggle');
  const contactSettingsContextSlider = document.querySelector('#contact-settings-context-slider'); // ← 新增
const contactSettingsContextValue = document.querySelector('#contact-settings-context-value'); // ← 新增
    const contactSettingsBgInput = document.querySelector('#contact-settings-bg-input');
    const contactSettingsBgClearBtn = document.querySelector('#contact-settings-bg-clear-btn');
    const contactSettingsLinkWorldbookBtn = document.querySelector('#contact-settings-link-worldbook-btn');
    const contactSettingsSaveBtn = document.querySelector('#contact-settings-save-btn');
    const worldbookLinkerBackBtn = document.querySelector('#worldbook-linker-back-btn');
    const contactSettingsScreen = document.querySelector('#contact-settings-screen');
    const worldbookLinkerScreen = document.querySelector('#worldbook-linker-screen');
    const contactSettingsAvatar = document.querySelector('#contact-settings-avatar');
    const contactSettingsNameInput = document.querySelector('#contact-settings-name-input');
    const contactSettingsRemarkInput = document.querySelector('#contact-settings-remark-input');
    const contactSettingsPersonaInput = document.querySelector('#contact-settings-persona-input');
    const worldbookLinkerList = document.querySelector('#worldbook-linker-list');
    const worldbookLinkerTitle = document.querySelector('#worldbook-linker-title');
    const contactSettingsTitle = document.querySelector('#contact-settings-title');
  const contactMyPersonaPresetSelect = document.querySelector('#contact-mypersona-preset-select');
const contactSettingsMyPersonaPresetSelect = document.querySelector('#contact-settings-mypersona-preset-select');
 const contactSettingsMyPersonaSupplementInput = document.querySelector('#contact-settings-mypersona-supplement-input');
  // 【新添加】抓取"我"页面的元素
const meScreen = document.querySelector('#me-screen');
const meBackBtn = document.querySelector('#me-back-btn');
const personaEditorPopup = document.querySelector('#persona-editor-popup');
const personaEditorTitle = document.querySelector('#persona-editor-title');
const personaAvatarPreview = document.querySelector('#persona-avatar-preview');
const personaAvatarInput = document.querySelector('#persona-avatar-input');
const personaNameInput = document.querySelector('#persona-name-input');
const personaDescInput = document.querySelector('#persona-desc-input');
const savePersonaBtn = document.querySelector('#save-persona-btn');
const personaEditorCloseBtn = document.querySelector('#persona-editor-close-btn');
  // ======================================================
// 【新添加】抓取 "记忆 & 总结" 页面的元素
// ======================================================
const memoryAppIcon = document.querySelector('#icon-memory'); // App 图标
const memoryScreen = document.querySelector('#memory-screen'); // 整个页面
const memoryBackBtn = document.querySelector('#memory-back-btn'); // 返回按钮
// 【修改】抓取新的"角色选择器"按钮
const summaryCharacterSelectorBtn = document.querySelector('#summary-character-selector-btn');
const summarySelectedCharacterName = document.querySelector('#summary-selected-character-name');
const summarySettingsContainer = document.querySelector('#summary-settings-container'); // 设置总容器
const summaryAutoToggle = document.querySelector('#summary-auto-toggle'); // 自动总结开关
const summaryRoundsSlider = document.querySelector('#summary-rounds-slider'); // 总结频率滑块
const summaryRoundsValue = document.querySelector('#summary-rounds-value'); // 总结频率文字
const summaryStatsDisplay = document.querySelector('#summary-stats-display'); // 聊天统计文字
const summaryManualBtn = document.querySelector('#summary-manual-btn'); // 手动总结按钮
const summaryTextarea = document.querySelector('#summary-textarea'); // 总结内容文本框
const summarySaveTextBtn = document.querySelector('#summary-save-text-btn'); // 保存总结按钮
// ======================================================
// 【新添加】抓取 "角色选择" 页面的元素
// ======================================================
const characterSelectorScreen = document.querySelector('#character-selector-screen');
const characterSelectorBackBtn = document.querySelector('#character-selector-back-btn');
const characterSearchInput = document.querySelector('#character-search-input');
const characterSelectorList = document.querySelector('#character-selector-list');

// ======================================================
// ======================================================



    // ======================================================
    // 函数定义 (Functions)
    // ======================================================

  // ======================================================
// 【新增】朋友圈功能 - 核心函数
// ======================================================

// 1. 渲染朋友圈列表
async function renderMomentsList() {
    const momentsContent = document.querySelector('#moments-content');
    
    // 从数据库获取所有动态（按时间倒序）
    const moments = await db.moments.reverse().toArray();
    
    if (moments.length === 0) {
        momentsContent.innerHTML = '<p class="empty-list-message">暂无动态，点击右上角 + 号发布第一条动态</p>';
        return;
    }
    
    momentsContent.innerHTML = '';
    
    for (const moment of moments) {
        // 判断是"我"发的还是"角色"发的
        let avatarUrl = './assets/default-avatar.png';
        let nickname = '我';
        
        if (moment.contactId === 0) {
            // 我发的动态
            const profile = await db.settings.get('myMomentsProfile');
            if (profile && profile.value) {
                nickname = profile.value.nickname || '我';
                if (profile.value.avatarFileKey) {
                    const avatarFile = await db.files.get(profile.value.avatarFileKey);
                    if (avatarFile) {
                        avatarUrl = URL.createObjectURL(avatarFile.file);
                    }
                }
            }
        } else {
            // 角色发的动态
            nickname = moment.contactName || '未知角色';
            if (moment.contactAvatarKey) {
                const avatarFile = await db.files.get(moment.contactAvatarKey);
                if (avatarFile) {
                    avatarUrl = URL.createObjectURL(avatarFile.file);
                }
            }
        }
        
        // 计算时间差
        const timeStr = formatMomentTime(moment.timestamp);
        
        // 创建卡片HTML
        const card = document.createElement('div');
        card.className = 'moment-card';
        card.dataset.momentId = moment.id;
        
        // 处理话题标签
        let contentHtml = moment.content;
        if (moment.hashtags && moment.hashtags.length > 0) {
            moment.hashtags.forEach(tag => {
                contentHtml += ` <a href="#" class="moment-hashtag">#${tag}</a>`;
            });
        }
        
   
// 构建配图区域（文字描述版）
let imagesHtml = '';

// 1. 先渲染真实图片（用户发的）
if (moment.images && moment.images.length > 0) {
    const count = moment.images.length;
    imagesHtml = `<div class="moment-images count-${count}">`;
    moment.images.forEach((img, index) => {
        imagesHtml += `<img src="${img}" alt="图片${index + 1}" class="moment-image">`;
    });
    imagesHtml += '</div>';
}

// 2. 再渲染文字描述（角色发的）
if (moment.imageDescriptions && moment.imageDescriptions.length > 0) {
    imagesHtml += '<div style="margin-top: 10px; padding: 10px; background-color: #f9f9f9; border-radius: 8px; border-left: 3px solid #007aff;">';
    moment.imageDescriptions.forEach((desc, index) => {
        imagesHtml += `<p style="margin: 5px 0; font-size: 13px; color: #555;">📷 ${desc}</p>`;
    });
    imagesHtml += '</div>';
}

// 然后在 card.innerHTML 中使用 ${imagesHtml}
card.innerHTML = `
    <div class="moment-header">
        <img src="${avatarUrl}" alt="头像" class="moment-avatar" style="cursor: pointer;">
        <div class="moment-user-info">
            <p class="moment-username">${nickname}</p>
            <p class="moment-time">${timeStr}</p>
        </div>
    </div>
    
    <div class="moment-content-text">${contentHtml}</div>
    
    ${moment.location ? `
        <div class="moment-location">
            <span class="moment-location-icon">📍</span>
            <span>${moment.location}</span>
        </div>
    ` : ''}
    
    ${imagesHtml}
    
    <div class="moment-actions">
        <button class="moment-action-btn">
            <span class="moment-action-icon">❤️</span>
            <span>${moment.likeCount || 0}</span>
        </button>
        <button class="moment-action-btn">
            <span class="moment-action-icon">💬</span>
            <span>${moment.commentCount || 0}</span>
        </button>
        <button class="moment-action-btn">
            <span class="moment-action-icon">📤</span>
            <span>分享</span>
        </button>
    </div>
    ${moment.likes && moment.likes.length > 0 ? `
     <div class="moment-likes-list">
        <span class="likes-icon">❤️</span>
        ${moment.likes.map(like => `<span class="liker-name">${like.name}</span>`).join(', ')}
    </div>
      <!-- 【新增】评论区（默认隐藏） -->
<div class="moment-comments-section hidden" data-moment-id="${moment.id}">

    <div class="comments-header">
        <span class="generate-comments-link">生成评论</span>
    </div>
   <div class="comments-list">
        ${moment.comments && moment.comments.length > 0 ? moment.comments.map(comment => `
            <div class="comment-item">
                <img src="${comment.avatarKey ? 'URL.createObjectURL(await db.files.get(comment.avatarKey).file)' : './assets/default-avatar.png'}" class="comment-avatar">
                <div class="comment-content">
                    <p class="comment-user">${comment.userName}</p>
                    <p class="comment-text">${comment.text}</p>
                    <p class="comment-time">${formatCommentTime(comment.timestamp)}</p>
                </div>
            </div>
        `).join('') : ''}
    </div>

   
` : ''}
        `;
        
        // 为头像添加点击事件


// 【新增】点击"生成评论"按钮
const generateLink = card.querySelector('.generate-comments-link');
if (generateLink) {
    generateLink.addEventListener('click', async (e) => {
        e.stopPropagation();
        const momentId = parseInt(card.dataset.momentId);
        await generateCommentsForMoment(momentId, generateLink);
    });
}

        const avatar = card.querySelector('.moment-avatar');
        avatar.addEventListener('click', (e) => {
            e.stopPropagation();
            if (moment.contactId === 0) {
                // 点击"我"的头像，打开个人主页
                openUserProfile();
            } else {
                // 点击角色头像，可以打开角色信息（可选功能）
                // TODO: 未来可以添加"查看角色主页"功能
                console.log(`点击了角色：${nickname}`);
            }
        });
        const likeBtn = card.querySelectorAll('.moment-action-btn')[0];
if (likeBtn) {
    likeBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const momentId = parseInt(card.dataset.momentId);
        await toggleMyLike(momentId, likeBtn);
    });
}


// 【新增】点击"评论"按钮，显示/隐藏评论区
const commentBtn = card.querySelectorAll('.moment-action-btn')[1]; // 第二个按钮是"评论"
if (commentBtn) {
    commentBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const commentsSection = card.querySelector('.moment-comments-section');
        if (commentsSection) {
            commentsSection.classList.toggle('hidden');
        }
    });
}
// 长按删除 - 必须在所有子元素事件之后绑定
let longPressTimer = null;

card.addEventListener('mousedown', (e) => {
    console.log('✅ 按下');
    longPressTimer = setTimeout(() => {
        console.log('✅ 长按触发！');
        if (navigator.vibrate) navigator.vibrate(50);
        if (confirm('确定删除？')) {
            db.moments.delete(moment.id);
            card.remove();
        }
    }, 800);
});

card.addEventListener('mousemove', () => {
    clearTimeout(longPressTimer);
});

card.addEventListener('mouseup', () => {
    clearTimeout(longPressTimer);
});

card.addEventListener('mouseleave', () => {
    clearTimeout(longPressTimer);
});


      
momentsContent.appendChild(card);
//console.log('卡片已添加，ID:', moment.id);
//console.log('卡片元素:', card);
     

    }
}
// ======================================================
// 【新增】朋友圈点赞功能
// ======================================================

// 1. 我点赞/取消点赞
async function toggleMyLike(momentId, buttonElement) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        const myUserId = 0; // 我的ID固定为0
        const myLikeIndex = moment.likes.findIndex(like => like.userId === myUserId);
        
        if (myLikeIndex !== -1) {
            // 已点赞，取消点赞
            moment.likes.splice(myLikeIndex, 1);
            moment.likeCount = moment.likes.length;
        } else {
            // 未点赞，添加点赞
            moment.likes.push({
                userId: myUserId,
                name: '我',
                timestamp: new Date()
            });
            moment.likeCount = moment.likes.length;
            
            // 播放爱心飞出动画
            createFlyingHeart(buttonElement);
        }
        
        // 更新数据库
        await db.moments.update(momentId, {
            likes: moment.likes,
            likeCount: moment.likeCount
        });
        
        // 刷新列表
     // 【修复】只更新当前卡片，不刷新整个列表
const card = document.querySelector(`[data-moment-id="${momentId}"]`);
if (card) {
    // 更新点赞数
    const likeCountSpan = card.querySelectorAll('.moment-action-btn')[0].querySelector('span:last-child');
    if (likeCountSpan) {
        likeCountSpan.textContent = moment.likeCount;
    }
    
    // 更新点赞列表
    const existingLikesList = card.querySelector('.moment-likes-list');
    if (moment.likes.length > 0) {
        const likesHtml = `
            <div class="moment-likes-list">
                <span class="likes-icon">❤️</span>
                ${moment.likes.map(like => `<span class="liker-name">${like.name}</span>`).join(', ')}
            </div>
        `;
        if (existingLikesList) {
            existingLikesList.outerHTML = likesHtml;
        } else {
            card.querySelector('.moment-actions').insertAdjacentHTML('afterend', likesHtml);
        }
    } else if (existingLikesList) {
        existingLikesList.remove();
    }
}

        
    } catch (error) {
        console.error('点赞失败:', error);
    }
}

// 2. 创建爱心飞出动画
function createFlyingHeart(buttonElement) {
    const heart = document.createElement('div');
    heart.className = 'flying-heart';
    heart.textContent = '❤️';
    
    // 获取按钮位置
    const rect = buttonElement.getBoundingClientRect();
    heart.style.left = rect.left + rect.width / 2 + 'px';
    heart.style.top = rect.top + 'px';
    
    document.body.appendChild(heart);
    
    // 动画结束后移除元素
    setTimeout(() => {
        heart.remove();
    }, 1000);
}

// 3. 角色自动点赞（延迟1-3秒）
async function autoLikeByContacts(momentId) {
    try {
        // 获取所有联系人
        const contacts = await db.contacts.toArray();
        if (contacts.length === 0) return;
        
        // 为每个角色设置随机延迟
        contacts.forEach((contact, index) => {
            const delay = Math.random() * 2000 + 1000 + (index * 200); // 1-3秒 + 错开时间
            
            setTimeout(async () => {
                const moment = await db.moments.get(momentId);
                if (!moment) return;
                
                // 检查该角色是否已点赞
                const alreadyLiked = moment.likes.some(like => like.userId === contact.id);
                if (alreadyLiked) return;
                
                // 添加点赞
                moment.likes.push({
                    userId: contact.id,
                    name: contact.name,
                    timestamp: new Date()
                });
                moment.likeCount = moment.likes.length;
                
                // 更新数据库
                await db.moments.update(momentId, {
                    likes: moment.likes,
                    likeCount: moment.likeCount
                });
                
                // 刷新列表
                await renderMomentsList();
                
            }, delay);
        });
        
    } catch (error) {
        console.error('自动点赞失败:', error);
    }
}
// ======================================================
// 【新增】生成评论的核心函数
// ======================================================
async function generateCommentsForMoment(momentId, buttonElement) {
  const originalText = buttonElement.textContent;
    try {
    // 1. 更新链接状态

buttonElement.textContent = '正在生成...';
buttonElement.classList.add('loading');
        
        // 2. 获取动态数据
        const moment = await db.moments.get(momentId);
        if (!moment) throw new Error('找不到动态');
        
        // 3. 获取所有联系人
        const contacts = await db.contacts.toArray();
        if (contacts.length === 0) {
            alert('暂无联系人可以评论');
            return;
        }
        
        // 4. 获取API配置
        const preset = await getActiveChatApiPreset();
        if (preset.error) {
            alert(preset.error);
            return;
        }
        
        // 5. 构建提示词
        const systemPrompt = `你需要为多个角色生成对朋友圈的评论。

**朋友圈内容：**
${moment.content}

**角色列表：**
${contacts.map((c, i) => `${i + 1}. ${c.name}：${c.persona || '普通人'}`).join('\n')}

**要求：**
- 为每个角色生成1条评论（15-50字）
- 评论要符合角色人设
- 评论要自然、真实
- 用JSON数组格式返回

**格式示例：**
[
  {"name": "角色A", "text": "评论内容"},
  {"name": "角色B", "text": "评论内容"}
]`;

        // 6. 调用API
        const { apiKey, baseUrl, model } = preset;
        const response = await fetch(`${baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: model,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: "请生成评论" }
                ],
                temperature: 0.8,
                max_tokens: 1000
            })
        });
        
        if (!response.ok) throw new Error('API请求失败');
        
        const data = await response.json();
        const aiResponse = data.choices[0].message.content.trim();
        
        // 7. 解析JSON
        let comments;
        try {
            const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
            comments = JSON.parse(jsonMatch ? jsonMatch[0] : aiResponse);
        } catch (e) {
            throw new Error('AI返回格式错误');
        }
        
        // 8. 保存评论到数据库
        const existingComments = moment.comments || [];
        comments.forEach(comment => {
            const contact = contacts.find(c => c.name === comment.name);
            if (contact) {
                existingComments.push({
                     id: Date.now() + Math.floor(Math.random() * 10000),
                    userId: contact.id,
                    userName: contact.name,
                    avatarKey: contact.avatarFileKey,
                    text: comment.text,
                    timestamp: new Date()
                });
            }
        });
        
        await db.moments.update(momentId, { 
            comments: existingComments,
            commentCount: existingComments.length
        });
        
        // 9. 刷新UI
        await renderMomentsList();
        
    } catch (error) {
        console.error('生成评论失败:', error);
        alert('生成失败：' + error.message);
  } finally {
    buttonElement.textContent = originalText;
    buttonElement.classList.remove('loading');
}
}

// 格式化评论时间
function formatCommentTime(timestamp) {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}`;
}


// 2. 格式化时间显示
function formatMomentTime(timestamp) {
    const now = new Date();
    const postTime = new Date(timestamp);
    const diff = now - postTime;
    
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (seconds < 60) return '刚刚';
    if (minutes < 60) return `${minutes}分钟前`;
    if (hours < 24) return `${hours}小时前`;
    if (days < 7) return `${days}天前`;
    
    // 超过7天显示具体日期
    return `${postTime.getMonth() + 1}月${postTime.getDate()}日`;
}
    
    function captureDefaultIcons() {
        iconKeys.forEach(key => {
            const svgElement = iconElements[key].querySelector('svg');
            if (svgElement) defaultIconSvgData[key] = svgElement.innerHTML;
        });
    }

    function updateClock() {
        const now = new Date(); const month = now.getMonth() + 1; const day = now.getDate();
        const week = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()];
        dateDisplay.textContent = `${month}月${day}日 ${week}`;
        const hours = String(now.getHours()).padStart(2, '0'); const minutes = String(now.getMinutes()).padStart(2, '0');
        timeDisplay.textContent = `${hours}:${minutes}`;
    }

    async function loadSettings() {
        const savedWallpaper = await db.files.get('savedWallpaper');
        if (savedWallpaper) phoneScreen.style.backgroundImage = `url('${URL.createObjectURL(savedWallpaper.file)}')`;
        const savedLeftText = await db.settings.get('topLeftText');
        if (savedLeftText) { 
            topLeftText.textContent = savedLeftText.value; 
            leftTextInput.value = savedLeftText.value; 
        }
        const savedRightText = await db.settings.get('topRightText');
        if (savedRightText) { 
            topRightText.textContent = savedRightText.value; 
            rightTextInput.value = savedRightText.value; 
        }
        const savedFontSize = await db.settings.get('topTextFontSize');
        if (savedFontSize) {
            const scale = savedFontSize.value / 15; 
            topLeftText.style.transform = `scale(${scale})`; 
            topRightText.style.transform = `scale(${scale})`;
            fontSizeSlider.value = savedFontSize.value; 
            fontSizeValue.textContent = savedFontSize.value + 'px';
        }
        const savedMode = await db.settings.get('darkMode');
        if (savedMode && savedMode.value === true) { 
            phoneScreen.classList.add('dark-mode'); 
            darkModeToggle.classList.add('active'); 
        }
iconKeys.forEach(async (key) => {
    const settingKey = `custom_icon_${key}`;
    const fileKey = `custom_icon_file_${key}`;
    const previewImg = document.querySelector(`#icon-preview-${key}`);
    
    // 优先加载本地文件
    const savedFile = await db.files.get(fileKey);
    if (savedFile) {
        const objectUrl = URL.createObjectURL(savedFile.file);
        const svgElement = iconElements[key].querySelector('svg');
        
        if (svgElement) {
            // 【关键】清空 SVG 内容，设置为背景图模式
            svgElement.innerHTML = '';
            svgElement.style.background = `url('${objectUrl}') center/cover no-repeat`;
            svgElement.style.borderRadius = '15px';
        }
        
        // 显示预览
        if (previewImg) {
            previewImg.src = objectUrl;
            previewImg.style.display = 'block';
        }
    } else {
        // 没有本地文件，尝试加载URL
        const savedIconUrl = await db.settings.get(settingKey);
        if (savedIconUrl) {
            const svgElement = iconElements[key].querySelector('svg');
            if (svgElement) {
                svgElement.innerHTML = '';
                svgElement.style.background = `url('${savedIconUrl.value}') center/cover no-repeat`;
                svgElement.style.borderRadius = '15px';
            }
            iconUrlInputs[key].value = savedIconUrl.value;
            
            // 显示预览
            if (previewImg) {
                previewImg.src = savedIconUrl.value;
                previewImg.style.display = 'block';
            }
        }
    }
});


        const widgetBg = largeWidget.querySelector('.widget-bg');
        const widgetBottomText = largeWidget.querySelector('.widget-text');
        const savedWidgetBg = await db.files.get('largeWidget_bg');
        if (savedWidgetBg) widgetBg.style.backgroundImage = `url('${URL.createObjectURL(savedWidgetBg.file)}')`;
        const savedWidgetAvatar = await db.files.get('largeWidget_avatar');
        if (savedWidgetAvatar) widgetAvatarImage.src = URL.createObjectURL(savedWidgetAvatar.file);
        const savedWidgetText = await db.settings.get('largeWidget_text');
        widgetBottomText.textContent = (savedWidgetText) ? savedWidgetText.value : '';
        if (widgetBottomText.textContent === '') {
            widgetBottomText.style.display = 'none';
        } else {
            widgetBottomText.style.display = ''; 
            widgetBg.style.marginBottom = '';
        }
        const savedLargeTextColor = await db.settings.get('largeWidget_textColor');
        if (savedLargeTextColor) widgetBottomText.style.color = savedLargeTextColor.value;
        editableSlimWidgets.forEach(async (widget) => {
            const widgetId = widget.dataset.widgetId;
            const savedBg = await db.files.get(`${widgetId}_bg`);
            const savedText = await db.settings.get(`${widgetId}_text`);
            const savedSlimTextColor = await db.settings.get(`${widgetId}_textColor`);
            if (savedBg) widget.style.backgroundImage = `url('${URL.createObjectURL(savedBg.file)}')`;
            const textElement = widget.querySelector('.widget-text-slim');
            if(textElement && savedText) textElement.textContent = savedText.value;
            if (textElement && savedSlimTextColor) textElement.style.color = savedSlimTextColor.value;
        });
    }

async function addMessageToUI(sender, text, messageId = null) {
    //  获取当前联系人的头像显示设置
    let showAvatar = true;
    if (currentOpenContactId) {
        const contact = await db.contacts.get(currentOpenContactId);
        if (contact && contact.showAvatar === false) {
            showAvatar = false;
        }
    }
    
    // 处理表情包标签
    if (text && text.includes('<sticker>')) {
        const stickerMatch = text.match(/<sticker>(.*?)<\/sticker>/);
        if (stickerMatch) {
            const stickerText = stickerMatch[1];
            const allLibraries = await db.sticker_libraries.toArray();
            let matchedSticker = null;
            
            for (const library of allLibraries) {
                const stickers = await db.stickers.where('libraryId').equals(library.id).toArray();
                matchedSticker = stickers.find(s => s.text === stickerText);
                if (matchedSticker) break;
            }
            
            if (matchedSticker) {
                text = text.replace(/<sticker>.*?<\/sticker>/, `[STICKER]${matchedSticker.url}|||${matchedSticker.text}`);
            } else {
                text = text.replace(/<sticker>.*?<\/sticker>/g, '').trim();
                if (!text) return;
            }
        }
    }
    
    // 检查是否是表情包消息
    if (text && text.trim().startsWith('[STICKER]')) {
        const stickerData = text.trim().substring(9);
        const parts = stickerData.split('|||');
        const url = parts[0];
        const stickerText = parts[1] || '';
        
        const messageEl = document.createElement('div');
        messageEl.classList.add('message-bubble');
        messageEl.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
        messageEl.innerHTML = `<img src="${url}" alt="${stickerText}" class="message-sticker" onerror="this.style.display='none'; this.parentElement.textContent='[图片加载失败]';">`;
        if (messageId) messageEl.dataset.messageId = messageId;
        messageContainer.appendChild(messageEl);
        messageContainer.scrollTop = messageContainer.scrollHeight;
    } else {
        // 普通文字消息
        const messageEl = document.createElement('div');
        messageEl.classList.add('message-bubble');
        messageEl.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
        messageEl.textContent = text;
        
        //  如果需要显示头像
        if (showAvatar) {
            const avatarEl = document.createElement('img');
            avatarEl.className = 'message-avatar';
            avatarEl.style.width = '32px';
            avatarEl.style.height = '32px';
            avatarEl.style.borderRadius = '50%';
            avatarEl.style.objectFit = 'cover';
            avatarEl.style.flexShrink = '0';
            
        
// 获取头像（优先使用情侣头像）
const contact = await db.contacts.get(currentOpenContactId);

if (sender === 'user') {
    // 【优先级1】如果启用了情侣头像，优先使用
    if (contact && contact.coupleAvatarEnabled && contact.coupleUserAvatarFileKey) {
        const coupleFile = await db.files.get(contact.coupleUserAvatarFileKey);
        if (coupleFile) {
            avatarEl.src = URL.createObjectURL(coupleFile.file);
        } else {
            // 找不到情侣头像，使用默认
            avatarEl.src = './assets/default-avatar.png';
        }
    }
    // 【优先级2】否则从"我的人设"读取
    else if (contact && contact.myPersonaPresetId) {
        const myPreset = await db.my_persona_presets.get(contact.myPersonaPresetId);
        
        if (myPreset && myPreset.avatarFileKey) {
            const avatarFile = await db.files.get(myPreset.avatarFileKey);
            if (avatarFile) {
                avatarEl.src = URL.createObjectURL(avatarFile.file);
            } else {
                avatarEl.src = './assets/default-avatar.png';
            }
        } else {
            avatarEl.src = './assets/default-avatar.png';
        }
    }
    // 【优先级3】都没有就用默认
    else {
        avatarEl.src = './assets/default-avatar.png';
    }
} else {
    // AI的头像
    // 【优先级1】如果启用了情侣头像，优先使用
    if (contact && contact.coupleAvatarEnabled && contact.coupleBotAvatarFileKey) {
        const coupleFile = await db.files.get(contact.coupleBotAvatarFileKey);
        if (coupleFile) {
            avatarEl.src = URL.createObjectURL(coupleFile.file);
        } else {
            avatarEl.src = './assets/default-avatar.png';
        }
    }
    // 【优先级2】否则用联系人自己的头像
    else if (contact && contact.avatarFileKey) {
        const avatarFile = await db.files.get(contact.avatarFileKey);
        if (avatarFile) {
            avatarEl.src = URL.createObjectURL(avatarFile.file);
        } else {
            avatarEl.src = './assets/default-avatar.png';
        }
    }
    // 【优先级3】都没有就用默认
    else {
        avatarEl.src = './assets/default-avatar.png';
    }



             
                if (contact && contact.avatarFileKey) {
                    const avatarFile = await db.files.get(contact.avatarFileKey);
                    if (avatarFile) {
                        avatarEl.src = URL.createObjectURL(avatarFile.file);
                    } else {
                        avatarEl.src = './assets/default-avatar.png';
                    }
                } else {
                    avatarEl.src = './assets/default-avatar.png';
                }
            }
            
            // 创建包含头像和消息的容器
            const messageWrapper = document.createElement('div');
            messageWrapper.style.display = 'flex';
            messageWrapper.style.alignItems = 'flex-end';
            messageWrapper.style.gap = '8px';
            messageWrapper.style.marginBottom = '12px';
            
            if (sender === 'user') {
                messageWrapper.style.justifyContent = 'flex-end';
                messageWrapper.appendChild(messageEl);
                messageWrapper.appendChild(avatarEl);
            } else {
                messageWrapper.style.justifyContent = 'flex-start';
                messageWrapper.appendChild(avatarEl);
                messageWrapper.appendChild(messageEl);
            }
            
            // 长按编辑功能
            if (messageId) {
                messageEl.dataset.messageId = messageId;
                
                let localLongPressTimer = null;
                let longPressTriggered = false;
                
                const clearTimer = () => {
                    if (localLongPressTimer) {
                        clearTimeout(localLongPressTimer);
                        localLongPressTimer = null;
                    }
                };
                
                messageEl.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    longPressTriggered = false;
                    
                    localLongPressTimer = setTimeout(() => {
                        longPressTriggered = true;
                        openMessageEditPopup(messageId, text);
                    }, 800);
                });
                
                messageEl.addEventListener('mouseup', (e) => {
                    clearTimer();
                    if (longPressTriggered) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                
                messageEl.addEventListener('mouseleave', () => {
                    clearTimer();
                });
                
                messageEl.addEventListener('touchstart', (e) => {
                    longPressTriggered = false;
                    
                    localLongPressTimer = setTimeout(() => {
                        longPressTriggered = true;
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                        openMessageEditPopup(messageId, text);
                    }, 800);
                }, { passive: true });
                
                messageEl.addEventListener('touchend', (e) => {
                    clearTimer();
                    if (longPressTriggered) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                
                messageEl.addEventListener('touchmove', () => {
                    clearTimer();
                }, { passive: true });
                
                messageEl.addEventListener('touchcancel', () => {
                    clearTimer();
                });
            }
            
            messageContainer.appendChild(messageWrapper);
        } else {
            // 不显示头像
            if (messageId) {
                messageEl.dataset.messageId = messageId;
                
                let localLongPressTimer = null;
                let longPressTriggered = false;
                
                const clearTimer = () => {
                    if (localLongPressTimer) {
                        clearTimeout(localLongPressTimer);
                        localLongPressTimer = null;
                    }
                };
                
                messageEl.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    longPressTriggered = false;
                    
                    localLongPressTimer = setTimeout(() => {
                        longPressTriggered = true;
                        openMessageEditPopup(messageId, text);
                    }, 800);
                });
                
                messageEl.addEventListener('mouseup', (e) => {
                    clearTimer();
                    if (longPressTriggered) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                
                messageEl.addEventListener('mouseleave', () => {
                    clearTimer();
                });
                
                messageEl.addEventListener('touchstart', (e) => {
                    longPressTriggered = false;
                    
                    localLongPressTimer = setTimeout(() => {
                        longPressTriggered = true;
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                        openMessageEditPopup(messageId, text);
                    }, 800);
                }, { passive: true });
                
                messageEl.addEventListener('touchend', (e) => {
                    clearTimer();
                    if (longPressTriggered) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                
                messageEl.addEventListener('touchmove', () => {
                    clearTimer();
                }, { passive: true });
                
                messageEl.addEventListener('touchcancel', () => {
                    clearTimer();
                });
            }
            
            messageContainer.appendChild(messageEl);
        }
        
        messageContainer.scrollTop = messageContainer.scrollHeight;
    }
}


// 打开消息编辑弹窗
// 打开消息编辑弹窗
function openMessageEditPopup(messageId, currentText) {
    if (!messageId) {
        console.error('messageId 为空！');
        return;
    }
    
    console.log('打开编辑弹窗，messageId:', messageId, 'text:', currentText); // 调试用
    
    // 【修复】过滤掉表情包消息
    if (currentText && currentText.trim().startsWith('[STICKER]')) {
        alert('表情包消息暂不支持编辑！');
        return;
    }
    
    currentEditingMessageId = messageId;
    
    const popup = document.querySelector('#message-edit-popup');
    const textarea = document.querySelector('#message-edit-textarea');
    
    if (!popup) {
        console.error('找不到编辑弹窗元素 #message-edit-popup');
        alert('编辑功能初始化失败，请刷新页面！');
        return;
    }
    
    if (!textarea) {
        console.error('找不到文本框元素 #message-edit-textarea');
        alert('编辑功能初始化失败，请刷新页面！');
        return;
    }
    //  确保弹窗在最顶层
    document.body.appendChild(popup);
    popup.style.position = 'fixed';
    popup.style.zIndex = '99999';
  
    textarea.value = currentText;
    popup.classList.remove('hidden');
    
    // 自动聚焦
    setTimeout(() => textarea.focus(), 100);
}


// 关闭消息编辑弹窗
function closeMessageEditPopup() {
    const popup = document.querySelector('#message-edit-popup');
    popup.classList.add('hidden');
    currentEditingMessageId = null;
}



// ======================================================
// 【新添加】"开关" 1: 获取 "聊天" API 预设
// ======================================================
async function getActiveChatApiPreset() {
    // 1. 查找 "聊天" 激活的预设 ID
    const activePresetIdItem = await db.settings.get('activeApiPresetId');
    if (!activePresetIdItem || !activePresetIdItem.value) {
        // 返回一个错误对象
        return { error: "（错误：未选择激活的[聊天API]，请在'设置'中配置。）" };
    }

    // 2. 根据 ID 获取预设
    const preset = await db.apiPresets.get(activePresetIdItem.value);
    if (!preset) {
        return { error: "（错误：找不到[聊天API]预设，请在'设置'中重新选择。）" };
    }

    // 3. 检查预设是否完整
    const { key: apiKey, url: baseUrlRaw, model } = preset;
    if (!apiKey || !baseUrlRaw || !model) {
        return { error: "（错误：当前[聊天API]预设信息不完整。）" };
    }

    // 4. 格式化 URL
    const baseUrl = baseUrlRaw.endsWith('/') ? baseUrlRaw.slice(0, -1) : baseUrlRaw; 

    // 5. 返回完整的预设数据
    return { apiKey, baseUrl, model };
}

// ======================================================
// 【新添加】"开关" 2: 获取 "总结" API 预设 (带回退)
// ======================================================
async function getActiveSummaryApiPreset() {
    // 1. 优先查找 "总结" 激活的预设 ID
    const activePresetIdItem = await db.settings.get('activeSummaryApiPresetId');

    // 2. 【关键】检查 "总结" API 是否被设置
    if (!activePresetIdItem || !activePresetIdItem.value) {
        // 2.1 如果没有设置 (用户选了"默认"), 则 "回退" 去使用 "聊天" API
        console.log("总结API未设置, 自动回退到 聊天API");
        return await getActiveChatApiPreset(); 
    }

    // 3. 如果 "总结" API 已设置, 则按正常流程获取它
    const preset = await db.apiPresets.get(activePresetIdItem.value);
    if (!preset) {
        // 3.1 如果找不到 (比如预设被删了), 也 "回退" 到 "聊天" API
        console.log("找不到总结API预设, 自动回退到 聊天API");
        return await getActiveChatApiPreset();
    }

    // 4. 检查预设是否完整
    const { key: apiKey, url: baseUrlRaw, model } = preset;
    if (!apiKey || !baseUrlRaw || !model) {
        // 4.1 如果信息不完整, 也 "回退" 到 "聊天" API
        console.log("总结API预设信息不完整, 自动回退到 聊天API");
        return await getActiveChatApiPreset();
    }

    // 5. 格式化 URL
    const baseUrl = baseUrlRaw.endsWith('/') ? baseUrlRaw.slice(0, -1) : baseUrlRaw; 

    // 6. 返回 "总结" API 的预设数据
    console.log("总结API: 成功加载专属预设");
    return { apiKey, baseUrl, model };
}
 // ======================================================
// 【新功能】智能拆分消息（如果AI没按格式返回）
// ======================================================
function smartSplitMessage(text) {
    // 如果已经有 ||| 分隔符，直接返回
    if (text.includes('|||')) {
        return text;
    }
    
    // 否则，按照标点和换行智能拆分
    let messages = [];
    
    // 先按换行分段
    const paragraphs = text.split('\n').filter(p => p.trim());
    
    paragraphs.forEach(para => {
        // 每段按句子拆分（按。！？分割）
        const sentences = para.split(/([。！？.!?]+)/).filter(s => s.trim());
        
        let currentMsg = '';
        for (let i = 0; i < sentences.length; i++) {
            currentMsg += sentences[i];
            
            // 如果累积长度超过50字，或遇到句号，就切分
            if (currentMsg.length > 50 || /[。！？.!?]/.test(sentences[i])) {
                if (currentMsg.trim()) {
                    messages.push(currentMsg.trim());
                }
                currentMsg = '';
            }
        }
        
        // 剩余内容
        if (currentMsg.trim()) {
            messages.push(currentMsg.trim());
        }
    });
    
    // 限制数量在 8-15 条之间
    if (messages.length > 15) {
        messages = messages.slice(0, 15);
    } else if (messages.length < 8 && messages.length > 0) {
        // 如果太少，尝试把长句再拆分
        const expanded = [];
        messages.forEach(msg => {
            if (msg.length > 40) {
                // 按逗号拆分长句
                const parts = msg.split(/[，,]/).filter(p => p.trim());
                expanded.push(...parts);
            } else {
                expanded.push(msg);
            }
        });
        messages = expanded.slice(0, 15);
    }
    
    return messages.join('|||');
}
 
    // 【修复】这个函数是干净、正确的版本
 // 【最终版】getAiReply
// ======================================================
// 【优化版】获取AI回复 - 自然聊天风格 + 多条消息
// ======================================================
async function getAiReply(contactId) {
    const preset = await getActiveChatApiPreset();
    if (preset.error) {
        return preset.error; 
    }
    const { apiKey, baseUrl, model } = preset;

    const contact = await db.contacts.get(contactId);
   // 【新增】概率判断
    let shouldPostMoment = false;
    if (contact.autoPostMoments) {
        const randomNum = Math.random() * 100;
        const probability = contact.momentPostProbability || 50;
        shouldPostMoment = randomNum <= probability;
        console.log(`🎲 朋友圈概率判断：${randomNum.toFixed(1)}% ${shouldPostMoment ? '≤' : '>'} ${probability}% → ${shouldPostMoment ? '触发' : '不触发'}`);
    }
    
    let userName = "用户";
    if (contact.myPersonaPresetId) {
        const myPreset = await db.my_persona_presets.get(contact.myPersonaPresetId);
        if (myPreset && myPreset.name) {
            userName = myPreset.name;
        }
    }

    let userPersona = "";
    if (contact.myPersonaPresetId) {
        const myPreset = await db.my_persona_presets.get(contact.myPersonaPresetId);
        if (myPreset && myPreset.description) {
            userPersona = myPreset.description;
        }
    }
    if (contact.myPersonaSupplement) {
        if (userPersona) {
            userPersona += "\n\n--- 补充说明 ---\n" + contact.myPersonaSupplement;
        } else {
            userPersona = contact.myPersonaSupplement;
        }
    }

    const summary = contact.aiSummaryText || "";

    let worldbookText = "";
    const links = await db.contact_worldbook_links.where('contactId').equals(contactId).toArray();
    const linkedEntryIds = links.map(l => l.worldbookEntryId);
    if (linkedEntryIds.length > 0) {
        const entries = await db.worldbook_entries.bulkGet(linkedEntryIds);
        let worldbookContext = "";
        entries.forEach(entry => {
            if(entry) { 
                worldbookContext += `\n--- ${entry.name} ---\n${entry.content}\n`;
            }
        });
        worldbookText = worldbookContext;
    }

    let stickerListText = "";
    const allLibraries = await db.sticker_libraries.toArray();
    if (allLibraries.length > 0) {
        let availableStickers = [];
        for (const library of allLibraries) {
            const stickers = await db.stickers.where('libraryId').equals(library.id).toArray();
            availableStickers.push(...stickers);
        }
        
        if (availableStickers.length > 0) {
            stickerListText = `\n\n# 【重要！表情包使用规则】

**格式要求（严格遵守）：**
✅ 正确：哈哈|||<sticker>笑哭</sticker>|||你太逗了
✅ 正确：<sticker>赞</sticker>
❌ 错误：哈哈<sticker>笑哭</sticker>（文本和表情包在同一条消息）
❌ 错误：<sticker>笑哭</sticker>你太逗了（表情包和文本在同一条消息）

**核心规则：**
1. 每条消息**只能包含一种内容**：要么是纯文字，要么是纯表情包
2. 如果想同时发文字和表情包，必须用 ||| 分成多条
3. 表情包标签内只能有表情包文字，不能有其他内容

**可用的表情包：**\n`;
            availableStickers.forEach(s => {
                stickerListText += `- ${s.text}\n`;
            });
            stickerListText += `\n**示例对话：**
哈哈你太逗了|||<sticker>笑哭</sticker>|||我快笑死了
（解释：第1条是文字，第2条是表情包，第3条是文字）\n\n`;
        }
    }

    let systemPrompt = `你正在扮演以下角色，请完全融入这个身份：

# 【角色人设】
${contact.persona || "一个真实、自然、有个性的普通人"}

# 【用户信息】
你正在和 "${userName}" 聊天。
${userPersona ? `\n关于 ${userName} 的信息：\n${userPersona}` : ""}

# 【聊天记忆】
${summary ? `以下是你们之前聊天的记忆摘要，你应该自然地记得这些内容：\n${summary}\n` : "这是你们的第一次对话。"}

# 【世界观设定】
${worldbookText ? `以下是你所在世界的背景设定，这些是你的常识：\n${worldbookText}\n` : ""}

${stickerListText}

---

# 核心原则
1. **你不是AI助手，你是这个角色本人**
   - 永远不要说"作为AI"、"我是助手"之类的话
   - 你有真实的情绪、记忆、个性、生活

2. **像真人聊天一样发消息**
   - 一次回复包含 **8-15条** 独立的消息
   - 每条消息长度：5-50字（模拟真实打字节奏）
   - 用"|||"分隔每条消息

3. **消息风格要求（重要！）**
   ✅ 每条消息控制在 5-30 字
   ✅ 不要一次说完一整段话
   ✅ 口语化：哈哈、emmm、诶、哇、哦
   ✅ 自然节奏：有时一句话，有时几个字
   ✅ 情绪真实：会停顿、会纠正、会打岔
   ✅ 符合人设：根据角色性格调整语气
   
   ❌ **严禁**：
   - 一条消息超过40字
   - 把多个意思挤在一条消息里
   - 一次性回答完所有问题


---

# 输出格式（严格遵守！）
你的回复必须是多条消息，用 "|||" 分隔，格式如下：

第一条消息内容|||第二条消息内容|||第三条消息内容|||...

**示例：**
哈哈你也在啊|||刚才去吃饭了|||诶对了|||上次你说的那个事儿|||我想了想|||可能这样比较好|||要不明天试试？|||你觉得呢

**错误示例（不要这样）：**
❌ 哈哈你也在啊，我刚才去吃饭了，诶对了，上次你说的那个事儿我想了想，可能这样比较好，要不明天试试？你觉得呢
（太长了！要拆成多条）

${stickerListText ? `\n**发送表情包示例：**\n哈哈|||<sticker>笑哭</sticker>|||你太逗了|||不行了|||<sticker>赞</sticker>\n（注意：每个 <sticker> 标签必须独占一条消息）` : ''}

---

# 当前对话上下文
现在请根据上面的所有信息，以及下面的聊天历史，用你角色的口吻回复 ${userName} 的最新消息。

记住：
- 回复 8-15 条消息
- 用 ||| 分隔
- 保持角色人设
- 自然、真实、有趣${stickerListText ? '\n- 表情包必须独占一条消息' : ''}

# 【新增】朋友圈功能

${contact.autoPostMoments ? `
你现在有 ${contact.momentPostProbability}% 的概率会在回复后发一条朋友圈。

**重要格式要求：**
1. 先正常回复聊天（用 ||| 分隔多条消息）
2. 如果要发朋友圈，在**所有聊天消息之后**，另起一行写：

<MOMENT>
{
    "content": "朋友圈文字（1-3句话）",
    "hashtags": ["话题1"],["话题2"],
    "location": "地点",
    "配图：详细描述图片内容（20-50字，要有画面感和细节）"
}
</MOMENT>

**注意：**
- <MOMENT> 标记和 JSON 之间不要有 |||
- JSON 必须是标准格式，不能有多余符号
- 朋友圈内容要符合你的人设
- 话题2-3个
- 朋友圈文字可以有换行

**示例：**
哈哈你也在啊|||刚才去吃饭了|||诶对了|||上次你说的那个事儿|||我想了想|||可能这样比较好|||要不明天试试？|||你觉得呢
<MOMENT>
{
    "content": "今天天气真好，适合出门走走",
    "hashtags": ["日常", "好心情"],
    "location": "市中心公园",
    "imageDescriptions": ["配图：公园里的阳光,多么多么好……"]
}
</MOMENT>
` : ''} 

---

现在请根据上面的所有信息，用你角色的口吻回复...
`;
  

    if (contact.aiCanReadTime) {
        systemPrompt += `\n\n[System Info: Current local time is ${new Date().toLocaleString('zh-CN')}]`;
    }

    const contextRounds = contact.contextRounds || 10;
    const history = await db.chatMessages.where('contactId').equals(contactId).reverse().limit(contextRounds * 2).toArray();
    history.reverse();

    let messages = [];
    messages.push({ role: "system", content: systemPrompt }); 
    history.forEach(msg => {
        if (msg.sender === 'user' || msg.sender === 'bot') {
            messages.push({ role: msg.sender === 'user' ? 'user' : 'assistant', content: msg.text });
        }
    });

    try {
        const response = await fetch(`${baseUrl}/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model, 
                messages: messages,
                temperature: 0.7,
                top_p: 0.95,
                frequency_penalty: 0.4,
                presence_penalty: 0.4,
                max_tokens: 100000,
                stream: false 
            })
        });
        
        if (!response.ok) {
            return `（API请求失败: ${response.status} ${response.statusText}）`;
        }
        
      const data = await response.json();
if (data.choices && data.choices[0] && data.choices[0].message) {
    let fullReply = data.choices[0].message.content.trim();
    
    // 【修复】检查是否包含朋友圈标记
    if (fullReply.includes('<MOMENT>')) {
        // 分离聊天内容和朋友圈数据
        const parts = fullReply.split('<MOMENT>');
        const chatPart = parts[0].trim();
        
        // 处理聊天部分
        let processedChat = fixStickerFormat(chatPart);
        if (!processedChat.includes('|||')) {
            processedChat = smartSplitMessage(processedChat);
        }
        
        // 返回完整内容（保留 <MOMENT> 标记）
        return processedChat + '|||<MOMENT>' + parts[1];
    }
    
    // 没有朋友圈，正常处理
    fullReply = fixStickerFormat(fullReply);
    
    if (fullReply.includes('|||')) {
        return fullReply;
    } else {
        return smartSplitMessage(fullReply);
    }
}
 else {
            return "（API返回了空数据）";
        }
    } catch (error) {
        return `（网络请求失败: ${error.message}）`;
    }
}
// ======================================================
// 【新增】AI生成朋友圈内容
// ======================================================
async function generateMomentContent(contact, recentMessages) {
    // 1. 获取API配置（复用聊天API）
    const preset = await getActiveChatApiPreset();
    if (preset.error) {
        console.error('API配置错误:', preset.error);
        return null;
    }
    
    const { apiKey, baseUrl, model } = preset;
    
    // 2. 获取用户名
    let userName = "用户";
    if (contact.myPersonaPresetId) {
        const myPreset = await db.my_persona_presets.get(contact.myPersonaPresetId);
        if (myPreset && myPreset.name) userName = myPreset.name;
    }
    
    // 3. 构建对话历史文本
    let conversationText = "";
    if (recentMessages && recentMessages.length > 0) {
        conversationText = "你刚才和 " + userName + " 聊了这些：\n";
        recentMessages.forEach(msg => {
            const speaker = msg.sender === 'user' ? userName : contact.name;
            conversationText += `${speaker}: ${msg.text}\n`;
        });
    }
    
    // 4. 构建提示词
    const systemPrompt = `# 你是谁？
你是 ${contact.name}，一个活生生的人。

${contact.persona || "一个普通人"}

# 你现在要干嘛？
发一条朋友圈。就像你平时刷手机、突然想发点什么一样。

---

## 📱 发朋友圈的灵感（随机选一个方向）

### 方向1：刚才聊天的余韵
${conversationText || "（你最近没和人聊天）"}

把刚才某个话题变成你自己的**自言自语**或感想。
⚠️ 重要：别说"我刚和谁聊天"，要装作是你自己突然想到的！

**例子：**
- ❌ 错误："刚才和朋友聊到咖啡，突然想喝了"
- ✅ 正确："突然好想喝杯咖啡啊...☕"

### 方向2：随便发点日常
说说你现在在干嘛、看到了什么、什么心情。
- 在喝咖啡 / 好困 / 外面下雨了 / 刚运动完好累...
- 随便发，别想太多

### 方向3：随口评论
对你刚看到的东西（新闻、歌、路人、天气）发个简短的看法或吐槽。

---

## 📝 格式要求

返回一个JSON对象（只要JSON，别的都不要）：

\`\`\`json
{
    "content": "朋友圈文字（1-3句话，100字以内，可以有首行缩进或者换行，可用emoji，要符合你的人设性格）",
    "hashtags": ["话题1", "话题2"],
    "location": "地点名称",
  "imageDescriptions": [
    "配图：详细描述图片内容（20-50字，要有画面感和细节）",
    "配图：详细描述图片内容（20-50字，要有画面感和细节）"
]
}
\`\`\`

注意：
- hashtags：0-3个，可以为空数组
- location：可以为null或空字符串
- imageDescriptions：可以为空数组，最多3张图
  - 每个描述必须20-50字
  - 要有具体细节（颜色、光线、氛围、动作等）
  - 像在描述一张真实照片

**配图描述示例：**
❌ 错误："配图：阳光"
✅ 正确："配图：温暖的午后阳光透过树叶洒下斑驳的光影，地面上形成金色的光斑"

❌ 错误："配图：咖啡"
✅ 正确："配图：一杯拿铁咖啡冒着热气，杯壁上凝结着细密的水珠，旁边放着半块提拉米苏"

---

## ⚠️ 注意事项

1. **完全入戏**：你不是AI，你是这个角色本人
2. **自然点**：像真人发朋友圈，别太刻意,灵活生动，有梗。
3. **保持人设**
4. **偶尔跑题**：不是每条都要和聊天有关，随便发点日常，观点，生活小事之内的也行。
5. **别暴露身份**：不要说"我是AI"、"根据对话"之类的

---

现在，发一条朋友圈吧！记住：你是 ${contact.name}，不是程序。`;

    try {
        // 5. 调用API
        const response = await fetch(`${baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: model,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: "发一条朋友圈吧！" }
                ],
                temperature: 0.9,  // 提高随机性，让内容更多样
                max_tokens: 500
            })
        });
        
        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status}`);
        }
        
        const data = await response.json();
        const aiResponse = data.choices[0].message.content.trim();
        
        // 6. 解析JSON
        let momentData;
        try {
            // 尝试直接解析
            momentData = JSON.parse(aiResponse);
        } catch (e) {
            // 如果失败，尝试提取JSON部分
            const jsonMatch = aiResponse.match(/```json\s*([\s\S]*?)\s*```/) || 
                            aiResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                momentData = JSON.parse(jsonMatch[1] || jsonMatch[0]);
            } else {
                throw new Error('AI返回的内容无法解析为JSON');
            }
        }
        
        // 7. 验证数据格式
        if (!momentData.content) {
            throw new Error('AI返回的内容缺少必要字段');
        }
        
        return momentData;
        
    } catch (error) {
        console.error('生成朋友圈失败:', error);
        return null;
    }
}

//  表情包格式修复函数
function fixStickerFormat(text) {
    // 1. 移除所有换行符（避免干扰）
    text = text.replace(/\n+/g, '|||');
    
    // 2. 修复 "文字<sticker>xxx</sticker>" 这种错误格式
    //    将其拆分成: "文字|||<sticker>xxx</sticker>"
    text = text.replace(/([^|])(<sticker>.*?<\/sticker>)/g, '$1|||$2');
    
    // 3. 修复 "<sticker>xxx</sticker>文字" 这种错误格式
    //    将其拆分成: "<sticker>xxx</sticker>|||文字"
    text = text.replace(/(<sticker>.*?<\/sticker>)([^|])/g, '$1|||$2');
    
    // 4. 清理多余的分隔符
    text = text.replace(/\|\|\|+/g, '|||');
    text = text.replace(/^\|\|\||\|\|\|$/g, '');
    
    return text;
}


    
    // 【新功能】关闭时清空预览
    function closeWidgetEditor() {
        widgetEditorPopup.classList.add('hidden');
        currentEditingWidgetId = null; 
        widgetBgPreview.src = '';
        widgetBgPreview.style.display = 'none';
        widgetAvatarPreview.src = '';
        widgetAvatarPreview.style.display = 'none';
    }
    
    async function populateApiForm(presetId) {
        if (!presetId) {
            currentSelectedPresetId = null;
            apiPresetNameInput.value = '';
            apiKeyInput.value = '';
            apiBaseUrlInput.value = '';
            apiModelInput.value = '';
            modelSelectorContainer.innerHTML = '';
        } else {
            currentSelectedPresetId = presetId;
            const preset = await db.apiPresets.get(presetId);
            if (preset) {
                apiPresetNameInput.value = preset.name;
                apiKeyInput.value = preset.key || '';
                apiBaseUrlInput.value = preset.url || '';
                apiModelInput.value = preset.model || '';
                modelSelectorContainer.innerHTML = ''; 
            }
        }
    }

async function loadApiPresets() {
    // 【修改】同时清空两个下拉框
    apiPresetSelector.innerHTML = ''; 
    apiSummaryPresetSelector.innerHTML = ''; // <-- 【新】

    // --- 1. 填充“聊天 API”下拉框 (和以前一样) ---
    const newOptionChat = document.createElement('option');
    newOptionChat.value = "new"; 
    newOptionChat.textContent = "--- [ 新建预设 ] ---";
    apiPresetSelector.appendChild(newOptionChat);

    // --- 2. 填充“总结 API”下拉框 (和以前一样) ---
    const newOptionSummary = document.createElement('option');
    newOptionSummary.value = ""; 
    newOptionSummary.textContent = "--- 使用默认 (与聊天API相同) ---"; 
    apiSummaryPresetSelector.appendChild(newOptionSummary); 

    // --- 3. 从数据库获取数据 (和以前一样) ---
    const allPresets = await db.apiPresets.toArray();
    const activeChatPresetIdItem = await db.settings.get('activeApiPresetId');
    const activeChatId = activeChatPresetIdItem ? activeChatPresetIdItem.value : null;
    const activeSummaryPresetIdItem = await db.settings.get('activeSummaryApiPresetId'); 
    const activeSummaryId = activeSummaryPresetIdItem ? activeSummaryPresetIdItem.value : null; 

    // --- 4. 检查预设是否为空 (和以前一样) ---
    if (allPresets.length === 0) {
         apiPresetSelector.value = "new";
         populateApiForm(null);
         return;
    }

    // --- 5. 循环填充两个列表 (和以前一样) ---
    allPresets.forEach(preset => {
        const optionChat = document.createElement('option');
        optionChat.value = preset.id;
        optionChat.textContent = preset.name;
        if (preset.id === activeChatId) {
            optionChat.textContent += " (聊天激活)"; 
        }
        apiPresetSelector.appendChild(optionChat);

        const optionSummary = optionChat.cloneNode(true); 
        if (preset.id === activeSummaryId) {
            optionSummary.textContent = preset.name + " (总结激活)";
        } else {
            optionSummary.textContent = preset.name; 
        }
        apiSummaryPresetSelector.appendChild(optionSummary); 
    });

    // --- 6. 设置两个下拉框的 "当前选中值" (和以前一样) ---
    if (activeChatId) {
        apiPresetSelector.value = activeChatId;
        await populateApiForm(activeChatId); 
    } else {
        apiPresetSelector.value = allPresets[0].id;
        await populateApiForm(allPresets[0].id); 
    }

    // 【修复】只设置 value，不再调用那个不存在的函数
    if (activeSummaryId) {
        apiSummaryPresetSelector.value = activeSummaryId; 
    } else {
        apiSummaryPresetSelector.value = ""; 
    }
}
  // ======================================================
// 【新功能】我的人设 (My Persona Presets) 
// ======================================================






async function openPersonaEditor(personaId) {
  
    
    if (personaId === null) {
        // 新建模式
        currentEditingPersonaId = null;
        document.querySelector('#persona-editor-title').textContent = '添加新人设';
        document.querySelector('#persona-name-input').value = '';
        document.querySelector('#persona-desc-input').value = '';
        document.querySelector('#persona-avatar-preview').src = './assets/default-avatar.png';
        document.querySelector('#persona-avatar-input').value = '';
    } else {
        // 编辑模式
        const persona = await db.my_persona_presets.get(personaId);
     
        
        if (!persona) {
            alert('找不到这个人设！');
            return;
        }
        
        currentEditingPersonaId = personaId;
        document.querySelector('#persona-editor-title').textContent = '编辑人设';
        document.querySelector('#persona-name-input').value = persona.name;
        document.querySelector('#persona-desc-input').value = persona.description || '';
        document.querySelector('#persona-avatar-preview').src = './assets/default-avatar.png';
        
        if (persona.avatarFileKey) {
            const avatarFile = await db.files.get(persona.avatarFileKey);
            if (avatarFile) {
                document.querySelector('#persona-avatar-preview').src = URL.createObjectURL(avatarFile.file);
            }
        }
        
        document.querySelector('#persona-avatar-input').value = '';
    }
    
 
    personaEditorPopup.classList.remove('hidden');
}



function closePersonaEditor() {
    personaEditorPopup.classList.add('hidden');
    currentEditingPersonaId = null;
}

  async function populateMyPersonaSelects(selectedId = null) {
    // 【关键】先检查表是否存在
    if (!db.my_persona_presets) {
        console.error('数据库表 my_persona_presets 不存在！');
        return;
    }
    
    const presets = await db.my_persona_presets.toArray();
    
    // 更新"添加联系人"弹窗中的选择器
    const selectEl = document.querySelector('#contact-mypersona-preset-select');
    if (selectEl) {
        selectEl.innerHTML = '<option value="">--- 请选择一个人设预设 ---</option>';
        presets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);  // ✅ 正确
        });
    }
    
    // 更新"联系人设置"页面中的选择器
    const settingsSelectEl = document.querySelector('#contact-settings-mypersona-preset-select');
    if (settingsSelectEl) {
        settingsSelectEl.innerHTML = '<option value="">--- 请选择一个人设预设 ---</option>';
        presets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            settingsSelectEl.appendChild(option);  // ✅ 正确
        });
        if (selectedId) {
            settingsSelectEl.value = selectedId;
        }
    }
}


       (async () => {
        captureDefaultIcons(); 
        updateClock();
        setInterval(updateClock, 1000);
        await loadSettings(); 
        await loadApiPresets(); 
        renderContactList(); 
        await renderCategories();
        await renderWorldbookEntries();
       // 【新增】创建测试朋友圈数据（仅首次运行）
    const existingMoments = await db.moments.count();
    if (existingMoments === 0) {
        // 创建示例动态
        await db.moments.add({
            contactId: 1, // 假设有ID为1的联系人
            content: '今天发现了一家超棒的咖啡馆，隐藏在巷子深处，环境特别有格调。他们的手冲咖啡真的是一绝，强烈推荐给喜欢咖啡的朋友们！',
            hashtags: ['美食探店', '咖啡时光'],
            location: '隐巷咖啡馆 · 市中心',
            images: [
                'https://images.unsplash.com/photo-1501339847302-ac426a4a7cbb?w=400',
                'https://images.unsplash.com/photo-1511920170033-f8396924c348?w=400'
            ],
            timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000), // 2小时前
            likes: [],
            likeCount: 0,
            commentCount: 0
        });
    }
    
    // 加载朋友圈列表
    await renderMomentsList();

    })();
    
    largeWidget.addEventListener('click', () => {
        currentEditingWidgetId = 'largeWidget'; 
        const currentText = largeWidget.querySelector('.widget-text').textContent;
        widgetBgUrlInput.value = '';
        widgetAvatarUrlInput.value = '';
        widgetTextInput.value = (currentText === '大胆，朕是皇帝！' && !localStorage.getItem('largeWidget_text')) ? '' : currentText;
        widgetTextColorInput.value = largeWidget.querySelector('.widget-text').style.color || '#333333';
        avatarEditorSection.classList.remove('hidden'); 
        widgetEditorPopup.classList.remove('hidden');
    });

    editableSlimWidgets.forEach(widget => {
        widget.addEventListener('click', () => {
            currentEditingWidgetId = widget.dataset.widgetId; 
            const currentText = widget.querySelector('.widget-text-slim').textContent;
            widgetBgUrlInput.value = '';
            widgetTextInput.value = currentText || '';
            widgetTextColorInput.value = widget.querySelector('.widget-text-slim').style.color || '#FFFFFF';
            avatarEditorSection.classList.add('hidden'); 
            widgetEditorPopup.classList.remove('hidden');
        });
    });
    
    widgetEditorCloseBtn.addEventListener('click', closeWidgetEditor);
    widgetEditorPopup.addEventListener('click', (event) => {
        if (event.target === widgetEditorPopup) closeWidgetEditor();
    });

    widgetSaveBtn.addEventListener('click', async () => {
      
        if (!currentEditingWidgetId) return; 
        const bgFile = widgetBgFileInput.files[0];
        const newText = widgetTextInput.value;
        const avatarFile = widgetAvatarFileInput.files[0]; 
        const newColor = widgetTextColorInput.value; 

        if (currentEditingWidgetId === 'largeWidget') {
            const widgetBg = largeWidget.querySelector('.widget-bg');
            const widgetText = largeWidget.querySelector('.widget-text');
            widgetText.textContent = newText;
            await db.settings.put({ key: 'largeWidget_text', value: newText });
            widgetText.style.display = (newText === '') ? 'none' : ''; 
            widgetBg.style.marginBottom = (newText === '') ? '0px' : ''; 
            widgetText.style.color = newColor;
            await db.settings.put({ key: 'largeWidget_textColor', value: newColor });
        } else { 
            const widgetToUpdate = document.querySelector(`[data-widget-id="${currentEditingWidgetId}"]`);
            const textElementToUpdate = widgetToUpdate.querySelector('.widget-text-slim');
            if(textElementToUpdate) textElementToUpdate.textContent = newText;
            await db.settings.put({ key: `${currentEditingWidgetId}_text`, value: newText });
            if(textElementToUpdate) textElementToUpdate.style.color = newColor;
            await db.settings.put({ key: `${currentEditingWidgetId}_textColor`, value: newColor });
        }
        try {
            if (bgFile) {
                await db.files.put({ key: `${currentEditingWidgetId}_bg`, file: bgFile });
                if (currentEditingWidgetId === 'largeWidget') {
                     largeWidget.querySelector('.widget-bg').style.backgroundImage = `url('${URL.createObjectURL(bgFile)}')`;
                } else {
                    document.querySelector(`[data-widget-id="${currentEditingWidgetId}"]`).style.backgroundImage = `url('${URL.createObjectURL(bgFile)}')`;
                }
            }
            if (avatarFile && currentEditingWidgetId === 'largeWidget') {
                await db.files.put({ key: 'largeWidget_avatar', file: avatarFile });
                widgetAvatarImage.src = URL.createObjectURL(avatarFile);
            }
        } catch (error) { console.error("保存文件失败:", error); }
        closeWidgetEditor();
        widgetBgFileInput.value = '';
        widgetAvatarFileInput.value = ''; 
    });

    widgetClearBtn.addEventListener('click', async () => { 
        if (!currentEditingWidgetId) return;
        if (currentEditingWidgetId === 'largeWidget') {
            largeWidget.querySelector('.widget-bg').style.backgroundImage = '';
            largeWidget.querySelector('.widget-bg').style.marginBottom = '0px'; 
            largeWidget.querySelector('.widget-text').textContent = ''; 
            largeWidget.querySelector('.widget-text').style.display = 'none'; 
            largeWidget.querySelector('.widget-text').style.color = ''; 
            widgetAvatarImage.src = './assets/default-avatar.png'; 
            await db.files.delete('largeWidget_bg');
            await db.files.delete('largeWidget_avatar');
            await db.settings.delete('largeWidget_text');
            await db.settings.delete('largeWidget_textColor');
        } else {
            const widgetToUpdate = document.querySelector(`[data-widget-id="${currentEditingWidgetId}"]`);
            widgetToUpdate.style.backgroundImage = '';
            if (widgetToUpdate.querySelector('.widget-text-slim')) {
                widgetToUpdate.querySelector('.widget-text-slim').textContent = '';
                widgetToUpdate.querySelector('.widget-text-slim').style.color = '';
            }
            await db.files.delete(`${currentEditingWidgetId}_bg`);
            await db.settings.delete(`${currentEditingWidgetId}_text`);
            await db.settings.delete(`${currentEditingWidgetId}_textColor`);
        }
        closeWidgetEditor();
    });

    themeAppIcon.addEventListener('click', () => { appGrid.classList.add('home-screen-hidden'); dock.classList.add('home-screen-hidden'); themeScreen.classList.remove('hidden'); });
    backToHomeBtn.addEventListener('click', () => { appGrid.classList.remove('home-screen-hidden'); dock.classList.remove('home-screen-hidden'); themeScreen.classList.add('hidden'); });
    settingsAppIcon.addEventListener('click', () => { appGrid.classList.add('home-screen-hidden'); dock.classList.add('home-screen-hidden'); settingsScreen.classList.remove('hidden'); });
    settingsBackBtn.addEventListener('click', () => { appGrid.classList.remove('home-screen-hidden'); dock.classList.remove('home-screen-hidden'); settingsScreen.classList.add('hidden'); });
    apiAccordionHeader.addEventListener('click', () => { apiAccordionHeader.classList.toggle('expanded'); apiAccordionContent.classList.toggle('expanded'); });
    dialogueAppIcon.addEventListener('click', () => { appGrid.classList.add('home-screen-hidden'); dock.classList.add('home-screen-hidden'); dialogueListScreen.classList.remove('hidden'); });
    dialogueListBackBtn.addEventListener('click', () => { appGrid.classList.remove('home-screen-hidden'); dock.classList.remove('home-screen-hidden'); dialogueListScreen.classList.add('hidden'); });
    newChatBtn.addEventListener('click', () => {
        addContactPopup.classList.remove('hidden'); 
        contactNameInput.value = '';
        contactPersonaInput.value = '';
        contactAvatarPreview.src = './assets/default-avatar.png'; 
        contactAvatarFileInput.value = ''; 
    });

    addContactCloseBtn.addEventListener('click', () => addContactPopup.classList.add('hidden'));
    addContactPopup.addEventListener('click', (event) => {
        if (event.target === addContactPopup) addContactPopup.classList.add('hidden');
    });

    contactAvatarFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => { contactAvatarPreview.src = e.target.result; };
            reader.readAsDataURL(file);
        }
    });

// 【替换】保存联系人按钮逻辑
saveContactBtn.addEventListener('click', async () => {
    const name = contactNameInput.value.trim();
    const persona = contactPersonaInput.value.trim();
    const avatarFile = contactAvatarFileInput.files[0]; 
    const selectedMyPersonaPresetId = parseInt(contactMyPersonaPresetSelect.value) || null; 

    // 验证必填项
    if (!name) return alert('至少需要输入一个姓名！');
    if (!avatarFile) return alert('请上传一个头像！'); 

    // 【新增】检查是否已存在同名联系人
    const existingContact = await db.contacts.where('name').equals(name).first();
    if (existingContact) {
        alert(`联系人"${name}"已存在！请使用其他名字。`);
        return;
    }

    // 1. 存头像文件
    const fileKey = `avatar_${Date.now()}`;
    await db.files.put({ key: fileKey, file: avatarFile });

    // 2. 存联系人信息
    const newContact = {
        name: name,
        persona: persona,
        avatarFileKey: fileKey, 
        myPersonaPresetId: selectedMyPersonaPresetId,
        myPersonaSupplement: '',
        contextRounds: 10,
        remark: '',
        aiCanReadTime: false,
        showAvatar: true,
        chatBackgroundFileKey: null,
        history: [], 
        isBlockedByUser: false, 
        isBlockedByAi: false,
        userBlockTimestamp: null,
        aiBlockTimestamp: null,
        blockEndTime: null,
        pendingMessages: [],
        autoPostMoments: false,         
        momentPostProbability: 50,
        coupleAvatarEnabled: false // 【新增】默认关闭情侣头像
    };
    await db.contacts.add(newContact);
    
    // 3. 刷新列表 & 关闭
    renderContactList();
    addContactPopup.classList.add('hidden');
    
    alert('联系人添加成功！'); // 【新增】成功提示
});


    accordionHeader1.addEventListener('click', () => { accordionHeader1.classList.toggle('expanded'); accordionContent1.classList.toggle('expanded'); });
    accordionHeader2.addEventListener('click', () => { accordionHeader2.classList.toggle('expanded'); accordionContent2.classList.toggle('expanded'); });
    accordionHeader3.addEventListener('click', () => { accordionHeader3.classList.toggle('expanded'); accordionContent3.classList.toggle('expanded'); });
// 聊天界面美化手风琴的展开/折叠
accordionHeader4.addEventListener('click', () => { 
    accordionHeader4.classList.toggle('expanded'); 
    accordionContent4.classList.toggle('expanded'); 
});

// 【 】滑块实时更新
chatWallpaperBlur.addEventListener('input', () => {
    chatWallpaperBlurValue.textContent = chatWallpaperBlur.value + 'px';
});

chatWallpaperOpacity.addEventListener('input', () => {
    chatWallpaperOpacityValue.textContent = chatWallpaperOpacity.value + '%';
});

chatInputRadius.addEventListener('input', () => {
    chatInputRadiusValue.textContent = chatInputRadius.value + 'px';
});

// 【 】导航栏背景图片预览
chatNavBgFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            chatNavBgPreview.src = ev.target.result;
            chatNavBgPreview.style.display = 'block';
            chatNavBgUrl.value = '';
        };
        reader.readAsDataURL(file);
    }
});

// 【 】聊天壁纸预览
chatWallpaperFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            chatWallpaperPreview.src = ev.target.result;
            chatWallpaperPreview.style.display = 'block';
            chatWallpaperUrl.value = '';
        };
        reader.readAsDataURL(file);
    }
});
//  底部导航栏背景图片预览
chatBottomBgFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            chatBottomBgPreview.src = ev.target.result;
            chatBottomBgPreview.style.display = 'block';
            chatBottomBgUrl.value = '';
        };
        reader.readAsDataURL(file);
    }
});

//  保存聊天样式
saveChatStyleBtn.addEventListener('click', async () => {
    try {
        // 保存导航栏样式
        await db.settings.put({ key: 'chatNavBgColor', value: chatNavBgColor.value });
        await db.settings.put({ key: 'chatNavTextColor', value: chatNavTextColor.value });
        
        // 保存导航栏背景图
        const navBgFile = chatNavBgFile.files[0];
        if (navBgFile) {
            await db.files.put({ key: 'chatNavBgImage', file: navBgFile });
        } else if (chatNavBgUrl.value) {
            await db.settings.put({ key: 'chatNavBgUrl', value: chatNavBgUrl.value });
        }
        
        // 保存聊天壁纸
        const wallpaperFile = chatWallpaperFile.files[0];
        if (wallpaperFile) {
            await db.files.put({ key: 'chatWallpaperImage', file: wallpaperFile });
        } else if (chatWallpaperUrl.value) {
            await db.settings.put({ key: 'chatWallpaperUrl', value: chatWallpaperUrl.value });
        }
        
        await db.settings.put({ key: 'chatWallpaperBlur', value: chatWallpaperBlur.value });
        await db.settings.put({ key: 'chatWallpaperOpacity', value: chatWallpaperOpacity.value });
                // 保存底部导航栏样式
        await db.settings.put({ key: 'chatBottomBgColor', value: chatBottomBgColor.value });
        
        const bottomBgFile = chatBottomBgFile.files[0];
        if (bottomBgFile) {
            await db.files.put({ key: 'chatBottomBgImage', file: bottomBgFile });
        } else if (chatBottomBgUrl.value) {
            await db.settings.put({ key: 'chatBottomBgUrl', value: chatBottomBgUrl.value });
        }
        

        // 保存输入框样式
        await db.settings.put({ key: 'chatInputBgColor', value: chatInputBgColor.value });
        await db.settings.put({ key: 'chatInputTextColor', value: chatInputTextColor.value });
        await db.settings.put({ key: 'chatInputBorderColor', value: chatInputBorderColor.value });
        await db.settings.put({ key: 'chatInputRadius', value: chatInputRadius.value });
        
        // 应用样式
        applyChatStyles();
        
        alert('聊天样式已保存！');
        accordionHeader4.classList.remove('expanded');
        accordionContent4.classList.remove('expanded');
        
    } catch (error) {
        console.error('保存失败:', error);
        alert('保存失败，请重试！');
    }
});

//  清除聊天样式
clearChatStyleBtn.addEventListener('click', async () => {
    if (!confirm('确定要清除所有聊天样式吗？')) return;
    
    // 清除数据库
    await db.settings.delete('chatNavBgColor');
    await db.settings.delete('chatNavTextColor');
    await db.settings.delete('chatNavBgUrl');
    await db.files.delete('chatNavBgImage');
    await db.settings.delete('chatWallpaperUrl');
    await db.files.delete('chatWallpaperImage');
    await db.settings.delete('chatWallpaperBlur');
    await db.settings.delete('chatWallpaperOpacity');
    await db.settings.delete('chatBottomBgColor');
    await db.settings.delete('chatBottomBgUrl');
    await db.files.delete('chatBottomBgImage');
    await db.settings.delete('chatInputBgColor');
    await db.settings.delete('chatInputTextColor');
    await db.settings.delete('chatInputBorderColor');
    await db.settings.delete('chatInputRadius');
    
    // 重置表单
    chatNavBgColor.value = '#ffffff';
    chatNavTextColor.value = '#333333';
    chatNavBgUrl.value = '';
    chatNavBgFile.value = '';
    chatNavBgPreview.style.display = 'none';
    chatWallpaperUrl.value = '';
    chatWallpaperFile.value = '';
    chatWallpaperPreview.style.display = 'none';
    chatWallpaperBlur.value = 0;
    chatWallpaperBlurValue.textContent = '0px';
    chatWallpaperOpacity.value = 100;
    chatWallpaperOpacityValue.textContent = '100%';
    chatBottomBgColor.value = '#ffffff';
    chatBottomBgUrl.value = '';
    chatBottomBgFile.value = '';
    chatBottomBgPreview.style.display = 'none';
    chatInputBgColor.value = '#ffffff';
    chatInputTextColor.value = '#333333';
    chatInputBorderColor.value = '#cccccc';
    chatInputRadius.value = 18;
    chatInputRadiusValue.textContent = '18px';
    
    // 【关键修复】立即清除页面上的样式
    const chatNav = document.querySelector('.chat-window-screen .theme-nav');
    const messageContainer = document.querySelector('.message-container');
    const chatInput = document.querySelector('#chat-input-box');
    const chatInputArea = document.querySelector('.dialogue-input-area');
    
    if (chatNav) {
        chatNav.style.backgroundColor = '';
        chatNav.style.color = '';
        chatNav.style.backgroundImage = '';
        const navTitle = chatNav.querySelector('h2');
        const backBtn = chatNav.querySelector('.back-btn');
        const settingsBtn = chatNav.querySelector('.nav-action-btn');
        if (navTitle) navTitle.style.color = '';
        if (backBtn) backBtn.style.color = '';
        if (settingsBtn) settingsBtn.style.color = '';
    }
    
    if (messageContainer) {
        // 移除全局壁纸背景层
        const oldBgLayer = messageContainer.querySelector('.chat-bg-layer');
        if (oldBgLayer) oldBgLayer.remove();
        
        // 【关键】如果当前有打开的联系人，重新加载角色专属背景
        if (currentOpenContactId) {
            const contact = await db.contacts.get(currentOpenContactId);
            if (contact && contact.chatBackgroundFileKey) {
                const bgFile = await db.files.get(contact.chatBackgroundFileKey);
                if (bgFile) {
                   const bgLayer = document.createElement('div');
bgLayer.className = 'chat-bg-layer';
bgLayer.style.position = 'fixed'; // 【修改】改为 fixed，固定在视口
bgLayer.style.top = messageContainer.getBoundingClientRect().top + 'px'; // 【修改】动态计算位置
bgLayer.style.left = messageContainer.getBoundingClientRect().left + 'px';
bgLayer.style.width = messageContainer.offsetWidth + 'px'; // 【修改】使用实际宽度
bgLayer.style.height = messageContainer.offsetHeight + 'px'; // 【修改】使用实际高度
bgLayer.style.zIndex = '0';
bgLayer.style.backgroundSize = 'cover';
bgLayer.style.backgroundPosition = 'center';
bgLayer.style.backgroundAttachment = 'fixed'; //  背景固定
bgLayer.style.pointerEvents = 'none';
                    
                    messageContainer.style.position = 'relative';
                    messageContainer.insertBefore(bgLayer, messageContainer.firstChild);
                    console.log('✅ 清除后重新应用角色专属背景');
                }
            }
        }
    }
    
    if (chatInputArea) {
        chatInputArea.style.backgroundColor = '';
        chatInputArea.style.backgroundImage = '';
    }
    //  同时清除输入框本身
if (chatInput) {
    chatInput.style.backgroundColor = '#ffffff'; // 恢复白色背景
}

    if (chatInput) {
        chatInput.style.backgroundColor = '';
        chatInput.style.color = '';
        chatInput.style.borderColor = '';
        chatInput.style.borderRadius = '';
    }
    
    // 清除整个窗口的背景
    if (chatWindowScreen) {
        chatWindowScreen.style.backgroundImage = '';
        chatWindowScreen.style.backgroundColor = '#ffffff';
    }
    
    alert('已清除所有聊天样式！');
    
    //  延迟应用默认样式（确保角色专属背景不被覆盖）
    setTimeout(() => {
        applyChatStyles();
    }, 100);
});


// 【修复】应用聊天样式的函数
async function applyChatStyles() {
    // 获取聊天窗口的元素
    const chatNav = document.querySelector('.chat-window-screen .theme-nav');
    const messageContainer = document.querySelector('.message-container');
    const chatInput = document.querySelector('#chat-input-box');
    
    if (!chatNav || !messageContainer || !chatInput) {
        console.log('聊天界面元素未找到，跳过样式应用');
        return;
    }
    
    //  清除可能残留在整个窗口上的背景
    if (chatWindowScreen) {
        chatWindowScreen.style.backgroundImage = '';
        chatWindowScreen.style.backgroundColor = '#ffffff';
    }
    
    // 1. 应用导航栏样式
    const navBgColor = await db.settings.get('chatNavBgColor');
    if (navBgColor) {
        chatNav.style.backgroundColor = navBgColor.value;
    } else {
        chatNav.style.backgroundColor = ''; //  清除时恢复默认
    }
    
    const navTextColor = await db.settings.get('chatNavTextColor');
    if (navTextColor) {
        chatNav.style.color = navTextColor.value;
        const navTitle = chatNav.querySelector('h2');
        const backBtn = chatNav.querySelector('.back-btn');
        const settingsBtn = chatNav.querySelector('.nav-action-btn');
        if (navTitle) navTitle.style.color = navTextColor.value;
        if (backBtn) backBtn.style.color = navTextColor.value;
        if (settingsBtn) settingsBtn.style.color = navTextColor.value;
    } else {
        //  清除时恢复默认
        chatNav.style.color = '';
        const navTitle = chatNav.querySelector('h2');
        const backBtn = chatNav.querySelector('.back-btn');
        const settingsBtn = chatNav.querySelector('.nav-action-btn');
        if (navTitle) navTitle.style.color = '';
        if (backBtn) backBtn.style.color = '';
        if (settingsBtn) settingsBtn.style.color = '';
    }
    
    // 导航栏背景图
    const navBgFile = await db.files.get('chatNavBgImage');
    const navBgUrl = await db.settings.get('chatNavBgUrl');
    if (navBgFile) {
        chatNav.style.backgroundImage = `url('${URL.createObjectURL(navBgFile.file)}')`;
        chatNav.style.backgroundSize = 'cover';
        chatNav.style.backgroundPosition = 'center';
    } else if (navBgUrl) {
        chatNav.style.backgroundImage = `url('${navBgUrl.value}')`;
        chatNav.style.backgroundSize = 'cover';
        chatNav.style.backgroundPosition = 'center';
    } else {
        //  清除时移除背景图
        chatNav.style.backgroundImage = '';
    }
    
    // 2. 【关键修复】应用聊天壁纸（只在没有角色专属背景时应用）
    // 先检查当前角色是否有专属背景
    let hasContactBackground = false;
    if (currentOpenContactId) {
        const contact = await db.contacts.get(currentOpenContactId);
        if (contact && contact.chatBackgroundFileKey) {
            const bgFile = await db.files.get(contact.chatBackgroundFileKey);
            if (bgFile) {
                hasContactBackground = true;
                console.log('✅ 检测到角色专属背景，跳过全局壁纸');
            }
        }
    }
    
    // 只有在没有角色专属背景时，才应用全局壁纸
   if (!hasContactBackground) {
    const wallpaperFile = await db.files.get('chatWallpaperImage');
    const wallpaperUrl = await db.settings.get('chatWallpaperUrl');
    const blur = await db.settings.get('chatWallpaperBlur');
    const opacity = await db.settings.get('chatWallpaperOpacity');
    
    if (wallpaperFile || wallpaperUrl) {
        let bgImageUrl = '';
        if (wallpaperFile) {
            bgImageUrl = URL.createObjectURL(wallpaperFile.file);
        } else if (wallpaperUrl) {
            bgImageUrl = wallpaperUrl.value;
        }
        
        // 【简化】直接设置容器背景
        messageContainer.style.backgroundImage = `url('${bgImageUrl}')`;
        messageContainer.style.backgroundSize = 'cover';
        messageContainer.style.backgroundPosition = 'center';
        messageContainer.style.backgroundAttachment = 'fixed'; // 关键：固定背景
        
        if (blur && blur.value > 0) {
            // 注意：blur 不能直接应用到容器，需要用伪元素
            console.warn('模糊效果需要使用方案A');
        }
        
        if (opacity && opacity.value < 100) {
            // 注意：opacity 会影响所有子元素
            console.warn('透明度效果需要使用方案A');
        }
        
        console.log('✅ 已应用全局聊天壁纸');
    } else {
        // 清除背景
        messageContainer.style.backgroundImage = '';
        messageContainer.style.backgroundColor = '#f9f9f9';
    }
}
    // 3. 【新增】应用底部导航栏背景
const chatInputArea = document.querySelector('.dialogue-input-area');
if (chatInputArea) {
    const bottomBgColor = await db.settings.get('chatBottomBgColor');
    if (bottomBgColor) {
        chatInputArea.style.backgroundColor = bottomBgColor.value;
    }
    
    const bottomBgFile = await db.files.get('chatBottomBgImage');
    const bottomBgUrl = await db.settings.get('chatBottomBgUrl');
    if (bottomBgFile) {
        chatInputArea.style.backgroundImage = `url('${URL.createObjectURL(bottomBgFile.file)}')`;
        chatInputArea.style.backgroundSize = 'cover';
        chatInputArea.style.backgroundPosition = 'center';
    } else if (bottomBgUrl) {
        chatInputArea.style.backgroundImage = `url('${bottomBgUrl.value}')`;
        chatInputArea.style.backgroundSize = 'cover';
        chatInputArea.style.backgroundPosition = 'center';
    }
}

    // 4. 应用输入框样式
    const inputBgColor = await db.settings.get('chatInputBgColor');
    if (inputBgColor) {
        chatInput.style.backgroundColor = inputBgColor.value;
    } else {
        chatInput.style.backgroundColor = ''; //  清除时恢复默认
    }
    
    const inputTextColor = await db.settings.get('chatInputTextColor');
    if (inputTextColor) {
        chatInput.style.color = inputTextColor.value;
    } else {
        chatInput.style.color = ''; //  清除时恢复默认
    }
    
    const inputBorderColor = await db.settings.get('chatInputBorderColor');
    if (inputBorderColor) {
        chatInput.style.borderColor = inputBorderColor.value;
    } else {
        chatInput.style.borderColor = ''; //  清除时恢复默认
    }
    
    const inputRadius = await db.settings.get('chatInputRadius');
    if (inputRadius) {
        chatInput.style.borderRadius = inputRadius.value + 'px';
    } else {
        chatInput.style.borderRadius = ''; //  清除时恢复默认
    }
    
    console.log('✅ 聊天样式已应用');
}



//  页面加载时应用保存的样式
//  页面加载时应用保存的样式
async function loadChatStyles() {
    const navBgColor = await db.settings.get('chatNavBgColor');
    if (navBgColor) chatNavBgColor.value = navBgColor.value;
    
    const navTextColor = await db.settings.get('chatNavTextColor');
    if (navTextColor) chatNavTextColor.value = navTextColor.value;
    
    const navBgUrl = await db.settings.get('chatNavBgUrl');
    if (navBgUrl) {
        chatNavBgUrl.value = navBgUrl.value;
        chatNavBgPreview.src = navBgUrl.value;
        chatNavBgPreview.style.display = 'block';
    }
    
    const wallpaperUrl = await db.settings.get('chatWallpaperUrl');
    if (wallpaperUrl) {
        chatWallpaperUrl.value = wallpaperUrl.value;
        chatWallpaperPreview.src = wallpaperUrl.value;
        chatWallpaperPreview.style.display = 'block';
    }
    
    const blur = await db.settings.get('chatWallpaperBlur');
    if (blur) {
        chatWallpaperBlur.value = blur.value;
        chatWallpaperBlurValue.textContent = blur.value + 'px';
    }
    
    const opacity = await db.settings.get('chatWallpaperOpacity');
    if (opacity) {
        chatWallpaperOpacity.value = opacity.value;
        chatWallpaperOpacityValue.textContent = opacity.value + '%';
    }
    
    const bottomBgColor = await db.settings.get('chatBottomBgColor');
    if (bottomBgColor) chatBottomBgColor.value = bottomBgColor.value;
    
    const bottomBgUrl = await db.settings.get('chatBottomBgUrl');
    if (bottomBgUrl) {
        chatBottomBgUrl.value = bottomBgUrl.value;
        chatBottomBgPreview.src = bottomBgUrl.value;
        chatBottomBgPreview.style.display = 'block';
    }
    
    const inputBgColor = await db.settings.get('chatInputBgColor');
    if (inputBgColor) chatInputBgColor.value = inputBgColor.value;
    
    const inputTextColor = await db.settings.get('chatInputTextColor');
    if (inputTextColor) chatInputTextColor.value = inputTextColor.value;
    
    const inputBorderColor = await db.settings.get('chatInputBorderColor');
    if (inputBorderColor) chatInputBorderColor.value = inputBorderColor.value;
    
    const inputRadius = await db.settings.get('chatInputRadius');
    if (inputRadius) {
        chatInputRadius.value = inputRadius.value;
        chatInputRadiusValue.textContent = inputRadius.value + 'px';
    }
    
    // 【删除】不在这里应用样式，等打开聊天窗口时再应用
    // await applyChatStyles();
}




    darkModeToggle.addEventListener('click', async () => { 
        darkModeToggle.classList.toggle('active'); 
        phoneScreen.classList.toggle('dark-mode'); 
        await db.settings.put({ key: 'darkMode', value: phoneScreen.classList.contains('dark-mode') }); 
    });
// ======================================================
// 【新功能】自定义图标 - 本地上传 + 预览
// ======================================================

// 为每个图标添加文件上传的监听器
iconKeys.forEach(key => {
    const fileInput = document.querySelector(`#icon-file-${key}`);
    const previewImg = document.querySelector(`#icon-preview-${key}`);
    
    if (fileInput && previewImg) {
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    // 显示预览图
                    previewImg.src = ev.target.result;
                    previewImg.style.display = 'block';
                    
                    // 清空URL输入框（因为用户选择了本地文件）
                    iconUrlInputs[key].value = '';
                };
                reader.readAsDataURL(file);
            }
        });
    }
});

saveIconsBtn.addEventListener('click', async () => { 
    for (const key of iconKeys) {
        const newUrl = iconUrlInputs[key].value;
        const fileInput = document.querySelector(`#icon-file-${key}`);
        const uploadedFile = fileInput ? fileInput.files[0] : null;
        const settingKey = `custom_icon_${key}`;
        const fileKey = `custom_icon_file_${key}`;
        
        const svgElement = iconElements[key].querySelector('svg');
        
        // 优先处理本地上传的文件
        if (uploadedFile) {
            // 1. 保存文件到数据库
            await db.files.put({ key: fileKey, file: uploadedFile });
            
            // 2. 更新图标（使用 CSS 背景）
            const objectUrl = URL.createObjectURL(uploadedFile);
            if (svgElement) {
                svgElement.innerHTML = '';
                svgElement.style.background = `url('${objectUrl}') center/cover no-repeat`;
                svgElement.style.borderRadius = '15px';
            }
            
            // 3. 清除URL设置（因为用了本地文件）
            await db.settings.delete(settingKey);
            
        } else if (newUrl) {
            // 如果输入了URL
            await db.settings.put({ key: settingKey, value: newUrl });
            
            if (svgElement) {
                svgElement.innerHTML = '';
                svgElement.style.background = `url('${newUrl}') center/cover no-repeat`;
                svgElement.style.borderRadius = '15px';
            }
            
            // 清除本地文件（因为用了URL）
            await db.files.delete(fileKey);
            
        } else {
            // 两个都没有，恢复默认图标
            await db.settings.delete(settingKey);
            await db.files.delete(fileKey);
            
            if (svgElement) {
                // 恢复原始 SVG 内容
                svgElement.style.background = '';
                svgElement.style.borderRadius = '';
                svgElement.innerHTML = defaultIconSvgData[key];
            }
        }
    }
    
    accordionHeader3.classList.remove('expanded');
    accordionContent3.classList.remove('expanded');
    alert('图标已保存！');
});



clearIconsBtn.addEventListener('click', async () => {
    if (!confirm('确定要清除所有自定义图标吗？这将恢复默认图标。')) {
        return;
    }
    
    for (const key of iconKeys) {
        const settingKey = `custom_icon_${key}`;
        const fileKey = `custom_icon_file_${key}`;
        
        // 1. 删除数据库中的URL设置
        await db.settings.delete(settingKey);
        
        // 2. 删除数据库中的本地文件
        await db.files.delete(fileKey);
        
        // 3. 清空URL输入框
        iconUrlInputs[key].value = '';
        
        // 4. 清空文件上传控件
        const fileInput = document.querySelector(`#icon-file-${key}`);
        if (fileInput) {
            fileInput.value = '';
        }
        
        // 5. 隐藏预览图
        const previewImg = document.querySelector(`#icon-preview-${key}`);
        if (previewImg) {
            previewImg.src = '';
            previewImg.style.display = 'none';
        }
        
        // 6. 恢复Dock上的默认图标
        const svgElement = iconElements[key].querySelector('svg');
        if (svgElement) {
            svgElement.style.background = '';
            svgElement.style.borderRadius = '';
            svgElement.innerHTML = defaultIconSvgData[key];
        }
    }
    
    alert('已清除所有自定义图标！');
});



    saveTextBtn.addEventListener('click', async () => { 
        const newLeftText = leftTextInput.value; 
        const newRightText = rightTextInput.value; 
        topLeftText.textContent = newLeftText; 
        topRightText.textContent = newRightText; 
        await db.settings.put({ key: 'topLeftText', value: newLeftText });
        await db.settings.put({ key: 'topRightText', value: newRightText });
        await db.settings.put({ key: 'topTextFontSize', value: fontSizeSlider.value });
        accordionHeader1.classList.remove('expanded'); 
        accordionContent1.classList.remove('expanded'); 
        alert('保存成功！'); 
    });

    fontSizeSlider.addEventListener('input', () => {
        const newSize = fontSizeSlider.value;
        fontSizeValue.textContent = newSize + 'px';
        const scale = newSize / 15;
        topLeftText.style.transform = `scale(${scale})`;
        topRightText.style.transform = `scale(${scale})`;
    });

    clearTextBtn.addEventListener('click', async () => { 
        leftTextInput.value = ''; rightTextInput.value = ''; 
        topLeftText.textContent = ''; topRightText.textContent = ''; 
        topLeftText.style.transform = 'scale(1)'; 
        topRightText.style.transform = 'scale(1)'; 
        await db.settings.delete('topLeftText');
        await db.settings.delete('topRightText');
        await db.settings.delete('topTextFontSize');
        fontSizeSlider.value = 15; 
        fontSizeValue.textContent = '15px'; 
    });

    timeWidget.addEventListener('click', () => themePopup.classList.remove('hidden'));
    closePopupBtn.addEventListener('click', () => themePopup.classList.add('hidden'));
    themePopup.addEventListener('click', (event) => {
        if (event.target === themePopup) themePopup.classList.add('hidden');
    });
    
    urlSubmitBtn.addEventListener('click', () => alert("请使用“从本地选择图片”功能，URL方式已被禁用。"));
    
    localFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            db.files.put({ key: 'savedWallpaper', file: file }).then(() => {
                phoneScreen.style.backgroundImage = `url('${URL.createObjectURL(file)}')`;
                themePopup.classList.add('hidden');
            }).catch(err => alert("保存壁纸失败！"));
        }
    });
    
sendMessageBtn.addEventListener('click', async () => {
    if (!currentOpenContactId) return;
    
    // 显示"正在思考"
    addMessageToUI('bot', '...');
    
    //  设置一个标记，表示正在处理回复
    const processingId = Date.now(); // 用时间戳作为唯一标识
    
    // 调用AI回复（使用独立的异步函数，不阻塞）
    processAiReply(currentOpenContactId, processingId);
});

//  独立的AI回复处理函数
async function processAiReply(contactId, processingId) {
    try {
        const aiResponseText = await getAiReply(contactId);
        
        // 检查是否包含朋友圈标记
        let messages = [];
        let momentData = null;
        
        if (aiResponseText.includes('<MOMENT>')) {
            const parts = aiResponseText.split('|||<MOMENT>');
            messages = parts[0].split('|||').map(m => m.trim()).filter(m => m);
            
            try {
                const momentJson = parts[1].split('</MOMENT>')[0].trim();
                momentData = JSON.parse(momentJson);
            } catch (e) {
                console.error('解析朋友圈数据失败:', e);
            }
        } else {
            messages = aiResponseText.split('|||').map(m => m.trim()).filter(m => m);
        }
        
        // 移除"正在思考"
        const typingBubble = messageContainer.querySelector('.message-bubble:last-child');
        if (typingBubble && typingBubble.textContent === '...') {
            typingBubble.remove();
        }
        
        // 显示AI消息
        for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            const botMessage = { 
                contactId: contactId, 
                sender: 'bot', 
                text: msg, 
                timestamp: new Date() 
            };
            await db.chatMessages.add(botMessage);
            await addMessageToUI('bot', msg);
            
            if (i < messages.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
            }
        }
        // 【新增】检查是否需要发朋友圈
if (shouldPostMoment) {
    console.log('🎲 触发自动发朋友圈');
    await checkAndPostMoment(contactId);
}
        // 如果有朋友圈数据，保存
        if (momentData) {
            const contact = await db.contacts.get(contactId);
            await db.moments.add({
                contactId: contact.id,
                contactName: contact.name,
                contactAvatarKey: contact.avatarFileKey,
                content: momentData.content || '',
                hashtags: momentData.hashtags || [],
                location: momentData.location || null,
                images: [],
                imageDescriptions: momentData.imageDescriptions || [],
                timestamp: new Date(),
                likes: [],
                likeCount: 0,
                commentCount: 0
            });
            
            console.log(`✅ ${contact.name} 发布了一条朋友圈`);
    
    // 【修复】无论朋友圈是否打开，都刷新列表
    await renderMomentsList();
        }
        
        renderContactList();
        await checkAndRunAutoSummary(contactId);
        
    } catch (error) {
        console.error('AI回复失败:', error);
        const typingBubble = messageContainer.querySelector('.message-bubble:last-child');
        if (typingBubble && typingBubble.textContent === '...') {
            typingBubble.remove();
        }
        addMessageToUI('bot', '（回复失败，请重试）');
    }
}

// ======================================================
// 【新增】检查并发布朋友圈的核心函数
// ======================================================
async function checkAndPostMoment(contactId) {
    try {
        const contact = await db.contacts.get(contactId);
        if (!contact || !contact.autoPostMoments) return;
        
        const now = Date.now();
        const lastPostTime = contact.lastMomentPostTime || 0;
        const cooldown = (contact.momentCooldown || 10) * 60 * 1000; // 转换为毫秒
        
        // 检查冷却时间
        if (now - lastPostTime < cooldown) {
            console.log(`⏳ 冷却中，还需等待 ${Math.ceil((cooldown - (now - lastPostTime)) / 60000)} 分钟`);
            return;
        }
        
        console.log(`🤖 冷却时间已过，开始生成朋友圈...`);
        
        // 获取最近的聊天记录
        const recentMessages = await db.chatMessages
            .where('contactId').equals(contactId)
            .reverse()
            .limit(10)
            .toArray();
        
        recentMessages.reverse();
        
        // 调用AI生成朋友圈内容
        const momentData = await generateMomentContent(contact, recentMessages);
        
        if (!momentData) {
            console.log('❌ 朋友圈生成失败');
            return;
        }
        
        // 保存到数据库
        await db.moments.add({
            contactId: contact.id,
            contactName: contact.name,
            contactAvatarKey: contact.avatarFileKey,
            content: momentData.content || '',
            hashtags: momentData.hashtags || [],
            location: momentData.location || null,
            images: [],
            imageDescriptions: momentData.imageDescriptions || [],
            timestamp: new Date(),
            likes: [],
            likeCount: 0,
            commentCount: 0
        });
        
        // 更新最后发布时间
        await db.contacts.update(contactId, { lastMomentPostTime: now });
        
        console.log(`✅ ${contact.name} 发布了一条朋友圈`);
        
        // 刷新朋友圈列表
        const momentsScreen = document.querySelector('.moments-screen');
        if (momentsScreen && !momentsScreen.classList.contains('hidden')) {
            await renderMomentsList();
        }
        
    } catch (error) {
        console.error('❌ 自动发朋友圈失败:', error);
    }
}


  // ======================================================
// 【修复】监听 "聊天 API" 下拉框 (已移除死循环)
// ======================================================
apiPresetSelector.addEventListener('change', async () => {
 
    const selectedValue = apiPresetSelector.value;
    if (selectedValue === "new") {
        await populateApiForm(null); 
        apiPresetNameInput.focus();
        await db.settings.delete('activeApiPresetId');
    } else {
        const selectedId = parseInt(selectedValue);
        await populateApiForm(selectedId); 
        await db.settings.put({ key: 'activeApiPresetId', value: selectedId });
        // 【已删除】那行导致死循环的 await loadApiPresets();
    }
});
 
// ======================================================
// 【修复】监听 "总结 API" 下拉框 (只负责保存)
// ======================================================
apiSummaryPresetSelector.addEventListener('change', async () => {
    const selectedValue = apiSummaryPresetSelector.value;

    if (selectedValue === "") {
        // 1. 如果用户选了 "使用默认 (与聊天API相同)"
        await db.settings.delete('activeSummaryApiPresetId');

    } else {
        // 2. 否则, 用户选了一个具体的预设
        const selectedId = parseInt(selectedValue);
        await db.settings.put({ key: 'activeSummaryApiPresetId', value: selectedId });
    }

    // 3. 重新加载所有预设, 以便在 UI 上正确显示 "(总结激活)" 字样
    await loadApiPresets(); 
});

// 【已删除】所有 summaryFetchModelsBtn 和 apiSummaryPresetSaveBtn 的监听器
// 因为它们相关的 HTML 已经被我们删掉了。



    apiPresetNewBtn.addEventListener('click', () => {
        apiPresetSelector.value = "new";
        apiPresetSelector.dispatchEvent(new Event('change'));
    });

    apiPresetDeleteBtn.addEventListener('click', async () => {
        if (!currentSelectedPresetId) {
            alert("你正处于“新建”模式，没有什么可删除的。");
            return;
        }
        const preset = await db.apiPresets.get(currentSelectedPresetId);
        if (confirm(`确定要删除预设 "${preset.name}" 吗？`)) {
            await db.apiPresets.delete(currentSelectedPresetId);
            const activePresetIdItem = await db.settings.get('activeApiPresetId');
            if (activePresetIdItem && activePresetIdItem.value === currentSelectedPresetId) {
                await db.settings.delete('activeApiPresetId');
            }
            alert("删除成功！");
            await loadApiPresets(); 
        }
    });

    apiPresetSaveBtn.addEventListener('click', async () => {
        const presetData = {
            name: apiPresetNameInput.value,
            key: apiKeyInput.value,
            url: apiBaseUrlInput.value,
            model: apiModelInput.value
        };
        if (!presetData.name) {
            alert("请填写预设名称！");
            apiPresetNameInput.focus();
            return;
        }
        let savedId;
        if (currentSelectedPresetId) {
            await db.apiPresets.update(currentSelectedPresetId, presetData);
            savedId = currentSelectedPresetId;
            alert("预设已更新！");
          await loadApiPresets(); // 重新加载两个下拉框, 因为 "名称" 可能已改变
        } else {
            savedId = await db.apiPresets.add(presetData);
            alert("新预设已保存！");
        }
        await db.settings.put({ key: 'activeApiPresetId', value: savedId });
        await loadApiPresets(); 
    });

    fetchModelsBtn.addEventListener('click', async () => {
        const key = apiKeyInput.value;
        const url = apiBaseUrlInput.value;
        if (!key || !url) {
            alert("请先填写 API Key 和 基础 URL");
            return;
        }
        const fetchUrl = url.endsWith('/') ? `${url}models` : `${url}/models`; 
        fetchModelsBtn.textContent = '...';
        fetchModelsBtn.disabled = true;
        modelSelectorContainer.innerHTML = ''; 
        try {
            const response = await fetch(fetchUrl, {
                method: 'GET',
                headers: { 'Authorization': `Bearer ${key}` }
            });
            if (!response.ok) throw new Error(`API 请求失败: ${response.status}`);
            const data = await response.json();
            if (data && data.data && Array.isArray(data.data)) {
                const models = data.data.map(m => m.id);
                const relevantModels = models.filter(m => 
                    m.includes('gpt') || m.includes('claude') || m.includes('gemini') ||
                    m.includes('qwen') || m.includes('moonshot') || m.includes('deepseek')
                ).sort(); 
                if (relevantModels.length === 0) {
                     modelSelectorContainer.innerHTML = '<p style="font-size: 12px; color: #555;">未找到相关模型。</p>';
                } else {
                    const selectEl = document.createElement('select');
                    selectEl.style = "width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ccc;";
                    selectEl.appendChild(new Option(`--- 找到 ${relevantModels.length} 个模型 ---`, ''));
                    relevantModels.forEach(modelId => selectEl.appendChild(new Option(modelId, modelId)));
                    selectEl.addEventListener('change', () => {
                        if (selectEl.value) apiModelInput.value = selectEl.value;
                    });
                    modelSelectorContainer.appendChild(selectEl);
                    if (apiModelInput.value) selectEl.value = apiModelInput.value;
                }
            } else { throw new Error("返回的数据格式不正确。"); }
        } catch (error) {
            modelSelectorContainer.innerHTML = `<p style="font-size: 12px; color: red;">拉取失败: ${error.message}</p>`;
        } finally {
            fetchModelsBtn.textContent = '拉取';
            fetchModelsBtn.disabled = false;
        }
    });

    // ======================================================
    // 世界书 (Worldbook) 核心逻辑
    // ======================================================

    // 【修复】这个函数是干净、正确的版本
    async function renderCategories() {
        const categories = await db.worldbook_categories.toArray();
        worldbookCategoryFilter.innerHTML = '<option value="all">--- 全部 ---</option>';
        entryCategorySelect.innerHTML = '';
        categoryListContainer.innerHTML = '';

        if (categories.length === 0) {
            entryCategorySelect.innerHTML = '<option value="">--- 请先去“管理分类”中添加 ---</option>';
            categoryListContainer.innerHTML = '<p style="font-size: 12px; color: #777; text-align: center;">暂无分类</p>';
            return; 
        }

        categories.forEach(cat => {
            worldbookCategoryFilter.appendChild(new Option(cat.name, cat.id));
            entryCategorySelect.appendChild(new Option(cat.name, cat.id));
            const item = document.createElement('div');
            item.className = 'category-list-item';
            
            // 【修复】这里的 class. 已经改回 class=
            item.innerHTML = `
                <span>${cat.name}</span>
                <button class="category-delete-btn" data-id="${cat.id}">×</button>
            `;
            categoryListContainer.appendChild(item);
        });
    }

    // 【修复】这个函数是干净、正确的版本
    async function renderWorldbookEntries() {
        const categories = await db.worldbook_categories.toArray();
        const categoryMap = categories.reduce((acc, cat) => {
            acc[cat.id] = cat.name;
            return acc;
        }, {});
        const selectedCategoryId = worldbookCategoryFilter.value;
        let entries;
        if (selectedCategoryId === 'all') {
            entries = await db.worldbook_entries.toArray();
        } else {
            entries = await db.worldbook_entries.where('categoryId').equals(parseInt(selectedCategoryId)).toArray();
        }
        
        worldbookListContent.innerHTML = '';
        if (entries.length === 0) {
            worldbookListContent.innerHTML = '<p class="empty-list-message">暂无条目</p>';
            return;
        }

        // 【修复】这里是正确的 forEach 循环
        entries.forEach(entry => {
            const categoryName = categoryMap[entry.categoryId] || '未分类';
            const firstLetter = categoryName.charAt(0).toUpperCase() || '?';
            const item = document.createElement('div');
            item.className = 'worldbook-entry-item';
            item.dataset.id = entry.id; 
            
            // 【修复】这里是正确的“首字母”图标，不再有 isChecked 错误
            item.innerHTML = `
                <div class="entry-item-icon">${firstLetter}</div>
                <div class="entry-item-info">
                    <p class="entry-item-name">${entry.name}</p>
                    <p class="entry-item-category">${categoryName}</p>
                </div>
            `;
            
            item.addEventListener('mousedown', (e) => {
                 if (e.button !== 0) return;
                longPressTimer = setTimeout(() => {
                    handleEntryLongPress(entry.id, entry.name);
                }, 800);
            });
            item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
            item.addEventListener('click', () => {
                 if (longPressTimer) handleEntryClick(entry.id);
            });
            worldbookListContent.appendChild(item);
        });
    }

    async function handleEntryClick(entryId) {
        currentEditingEntryId = entryId;
        const entry = await db.worldbook_entries.get(entryId);
        if (!entry) return;
        entryEditorTitle.textContent = "编辑条目";
        entryNameInput.value = entry.name;
        entryContentTextarea.value = entry.content;
        entryCategorySelect.value = entry.categoryId;
        worldbookListScreen.classList.add('hidden');
        entryEditorScreen.classList.remove('hidden');
    }

    async function handleEntryLongPress(entryId, entryName) {
        clearTimeout(longPressTimer);
        longPressTimer = null; 
        if (confirm(`确定要删除条目 "${entryName}" 吗？`)) {
            await db.worldbook_entries.delete(entryId);
            await renderWorldbookEntries();
            await loadChatStyles();
              await loadChatStyles(); //  加载聊天样式

        }
    }

    worldbookAppIcon.addEventListener('click', () => {
        appGrid.classList.add('home-screen-hidden');
        dock.classList.add('home-screen-hidden');
        worldbookListScreen.classList.remove('hidden');
        renderCategories();
        renderWorldbookEntries();
    });
    worldbookBackBtn.addEventListener('click', () => {
        appGrid.classList.remove('home-screen-hidden');
        dock.classList.remove('home-screen-hidden');
        worldbookListScreen.classList.add('hidden');
    });
    worldbookAddBtn.addEventListener('click', () => {
        worldbookAddMenu.classList.remove('hidden');
    });
    worldbookAddMenu.addEventListener('click', (e) => {
        if (e.target === worldbookAddMenu) worldbookAddMenu.classList.add('hidden');
    });
    worldbookMenuAddEntry.addEventListener('click', () => {
        worldbookAddMenu.classList.add('hidden'); 
        currentEditingEntryId = null; 
        entryEditorTitle.textContent = "添加新条目";
        entryNameInput.value = '';
        entryContentTextarea.value = '';
        worldbookListScreen.classList.add('hidden');
        entryEditorScreen.classList.remove('hidden');
    });
    worldbookMenuManageCategories.addEventListener('click', () => {
        worldbookAddMenu.classList.add('hidden'); 
        worldbookListScreen.classList.add('hidden');
        categoryManagerScreen.classList.remove('hidden');
    });
    categoryManagerBackBtn.addEventListener('click', () => {
        categoryManagerScreen.classList.add('hidden');
        worldbookListScreen.classList.remove('hidden');
        renderCategories();
        renderWorldbookEntries();
    });
    entryEditorBackBtn.addEventListener('click', () => {
        entryEditorScreen.classList.add('hidden');
        worldbookListScreen.classList.remove('hidden');
        renderWorldbookEntries();
    });
    worldbookCategoryFilter.addEventListener('change', () => {
        renderWorldbookEntries(); 
    });
    categoryAddBtn.addEventListener('click', async () => {
        const name = categoryNameInput.value.trim();
        if (!name) return alert("分类名称不能为空！");
        try {
            await db.worldbook_categories.add({ name: name });
            categoryNameInput.value = '';
            await renderCategories();
        } catch (error) {
            alert("添加失败，可能这个分类已经存在了。");
        }
    });
    categoryListContainer.addEventListener('click', async (e) => {
        if (e.target.classList.contains('category-delete-btn')) {
            const categoryId = parseInt(e.target.dataset.id);
            const categoryName = e.target.previousElementSibling.textContent;
            if (confirm(`确定要删除分类 "${categoryName}" 吗？\n（警告：这不会删除该分类下的条目，它们会变成“未分类”。）`)) {
                await db.worldbook_categories.delete(categoryId);
                await renderCategories();
            }
        }
    });
    entrySaveBtn.addEventListener('click', async () => {
        const entryData = {
            name: entryNameInput.value.trim(),
            content: entryContentTextarea.value.trim(),
            categoryId: parseInt(entryCategorySelect.value) 
        };
        if (!entryData.name) return alert("条目名称不能为空！");
        if (!entryData.categoryId) return alert("请选择一个分类！");
        if (currentEditingEntryId) {
            await db.worldbook_entries.update(currentEditingEntryId, entryData);
        } else {
            await db.worldbook_entries.add(entryData);
        }
        alert("保存成功！");
                  //  保存后重新应用样式
            setTimeout(() => {
                applyChatStyles();
            }, 100);

        entryEditorScreen.classList.add('hidden');
        worldbookListScreen.classList.remove('hidden');
        await renderWorldbookEntries();
    });

    // ======================================================
    // 联系人设置 (Character Settings) 核心逻辑
    // ======================================================

    async function openContactSettings(contactId) {
        if (!contactId) return;
        const contact = await db.contacts.get(contactId);
        if (!contact) {
            alert("错误：找不到联系人！");
            return;
        }
        contactSettingsTitle.textContent = `设置: ${contact.name}`;
        contactSettingsNameInput.value = contact.name;
        contactSettingsRemarkInput.value = contact.remark || ''; 
        contactSettingsPersonaInput.value = contact.persona;
        contactSettingsAvatar.src = './assets/default-avatar.png'; 
        if (contact.avatarFileKey) {
            const avatarFile = await db.files.get(contact.avatarFileKey);
            if (avatarFile) contactSettingsAvatar.src = URL.createObjectURL(avatarFile.file);
        }
        if (contact.aiCanReadTime) { 
            contactSettingsTimeToggle.classList.add('active');
        } else {
            contactSettingsTimeToggle.classList.remove('active');
        }
       //  加载"是否显示头像"设置
    if (contact.showAvatar !== false) { // 默认显示
        contactSettingsAvatarToggle.classList.add('active');
    } else {
        contactSettingsAvatarToggle.classList.remove('active');
    }
      // 加载"是否启用情侣头像"
if (contact.coupleAvatarEnabled) {
    contactSettingsCoupleAvatarToggle.classList.add('active');
} else {
    contactSettingsCoupleAvatarToggle.classList.remove('active');
}

        contactSettingsAvatarInput.value = '';
        contactSettingsBgInput.value = '';
        chatWindowScreen.classList.add('hidden');
      await populateMyPersonaSelects(contact.myPersonaPresetId);
       contactSettingsMyPersonaSupplementInput.value = contact.myPersonaSupplement || '';
       //  加载"上下文参考"
    const contextRounds = contact.contextRounds || 10; // 默认10轮
    contactSettingsContextSlider.value = contextRounds;
    contactSettingsContextValue.value = contextRounds;

// 【修改】加载自动发朋友圈设置
const autoMomentToggle = document.querySelector('#contact-settings-auto-moment-toggle');
const intervalContainer = document.querySelector('#moment-interval-container');
const cooldownContainer = document.querySelector('#moment-cooldown-container');
const intervalSlider = document.querySelector('#contact-settings-moment-interval');
const intervalValue = document.querySelector('#contact-settings-moment-interval-value');
const cooldownSlider = document.querySelector('#contact-settings-moment-cooldown');
const cooldownValue = document.querySelector('#contact-settings-moment-cooldown-value');

if (contact.autoPostMoments) {
    autoMomentToggle.classList.add('active');
    intervalContainer.classList.remove('hidden');
    cooldownContainer.classList.remove('hidden');
} else {
    autoMomentToggle.classList.remove('active');
    intervalContainer.classList.add('hidden');
    cooldownContainer.classList.add('hidden');
}

const interval = contact.momentInterval || 5;
const cooldown = contact.momentCooldown || 10;
intervalSlider.value = interval;
intervalValue.value = interval;
cooldownSlider.value = cooldown;
cooldownValue.value = cooldown;

      
        contactSettingsScreen.classList.remove('hidden');
      
    }

    // 【修复】这个函数是干净、正确的版本
    async function loadWorldbookLinker(contactId) {
        const categories = await db.worldbook_categories.toArray();
        const categoryMap = categories.reduce((acc, cat) => {
            acc[cat.id] = cat.name;
            return acc;
        }, {});
        const allEntries = await db.worldbook_entries.toArray();
        const links = await db.contact_worldbook_links.where('contactId').equals(contactId).toArray();
        const linkedEntryIds = new Set(links.map(l => l.worldbookEntryId)); 

        worldbookLinkerList.innerHTML = '';
        if (allEntries.length === 0) {
            worldbookLinkerList.innerHTML = '<p class="empty-list-message">你还没有创建任何世界书条目</p>';
            return;
        }

        // 【修复】这里是正确的 forEach 循环
        allEntries.forEach(entry => {
            const categoryName = categoryMap[entry.categoryId] || '未分类';
            const isChecked = linkedEntryIds.has(entry.id); 
            const item = document.createElement('div');
            item.className = 'linker-item';
            item.dataset.entryId = entry.id; // 【修复】确保是 .entryId

            // 【修复】这里的 class 拼写已全部正确
            item.innerHTML = `
                <div class="linker-item-checkbox ${isChecked ? 'checked' : ''}"></div>
                <div class="linker-item-info">
                    <p class="linker-item-name">${entry.name}</p>
                    <p class="linker-item-category">${categoryName}</p>
                </div>
            `;
            worldbookLinkerList.appendChild(item);
        });
    }

    contactSettingsBtn.addEventListener('click', () => {
        openContactSettings(currentOpenContactId); 
    });
    contactSettingsBackBtn.addEventListener('click', () => {
        contactSettingsScreen.classList.add('hidden');
        chatWindowScreen.classList.remove('hidden');
    });
    contactSettingsLinkWorldbookBtn.addEventListener('click', () => {
        loadWorldbookLinker(currentOpenContactId);
        contactSettingsScreen.classList.add('hidden');
        worldbookLinkerScreen.classList.remove('hidden');
    });
    worldbookLinkerBackBtn.addEventListener('click', () => {
        worldbookLinkerScreen.classList.add('hidden');
        contactSettingsScreen.classList.remove('hidden');
    });

    // 【修复】这个函数是干净、正确的版本
    worldbookLinkerList.addEventListener('click', async (e) => {
        const item = e.target.closest('.linker-item');
        if (!item) return; 
        const entryId = parseInt(item.dataset.entryId); // 【修复】确保读取 .entryId
        const contactId = currentOpenContactId;
        const checkbox = item.querySelector('.linker-item-checkbox');
        
        if (checkbox.classList.contains('checked')) {
            checkbox.classList.remove('checked');
            await db.contact_worldbook_links.delete([contactId, entryId]);
        } else {
            checkbox.classList.add('checked');
            await db.contact_worldbook_links.add({
                contactId: contactId,
                worldbookEntryId: entryId
            });
        }
    });

    contactSettingsTimeToggle.addEventListener('click', () => {
        contactSettingsTimeToggle.classList.toggle('active');
    });

    contactSettingsBgClearBtn.addEventListener('click', async () => {
        if (!confirm("确定要清除自定义背景吗？")) return;
        const contactId = currentOpenContactId;
        const contact = await db.contacts.get(contactId);
        if (contact) {
            contact.chatBackgroundFileKey = null; 
            await db.contacts.put(contact);
            alert("背景已清除！");
            chatWindowScreen.style.backgroundImage = '';
            chatWindowScreen.style.backgroundColor = '#ffffff';
        }
    });

    contactSettingsSaveBtn.addEventListener('click', async () => {
        const contactId = currentOpenContactId;
        if (!contactId) return;
        try {
            const dataToUpdate = {
                name: contactSettingsNameInput.value,
                remark: contactSettingsRemarkInput.value,
                persona: contactSettingsPersonaInput.value,
                aiCanReadTime: contactSettingsTimeToggle.classList.contains('active'),
         myPersonaPresetId: parseInt(contactSettingsMyPersonaPresetSelect.value) || null,
 myPersonaSupplement: contactSettingsMyPersonaSupplementInput.value,
              contextRounds: parseInt(contactSettingsContextValue.value) || 10,
               showAvatar: contactSettingsAvatarToggle.classList.contains('active'),
              coupleAvatarEnabled: contactSettingsCoupleAvatarToggle.classList.contains('active'),
 // 【新增】保存自动发朋友圈设置
       autoPostMoments: autoMomentToggle.classList.contains('active'),
momentInterval: parseInt(intervalValue.value) || 5,
momentCooldown: parseInt(cooldownValue.value) || 10

            
            };
            const avatarFile = contactSettingsAvatarInput.files[0];
            if (avatarFile) {
                const fileKey = `avatar_${Date.now()}`;
                await db.files.put({ key: fileKey, file: avatarFile });
                dataToUpdate.avatarFileKey = fileKey; 
                contactSettingsAvatar.src = URL.createObjectURL(avatarFile);
            }
            const bgFile = contactSettingsBgInput.files[0];
            if (bgFile) {
                const fileKey = `chatbg_${Date.now()}`;
                await db.files.put({ key: fileKey, file: bgFile });
                dataToUpdate.chatBackgroundFileKey = fileKey; 
            }
                      //  如果上传了新背景，立即应用
            if (bgFile) {
                setTimeout(() => {
                    applyChatStyles();
                }, 100);
            }

            await db.contacts.update(contactId, dataToUpdate);
            renderContactList();
            document.querySelector('#chat-window-title').textContent = dataToUpdate.name;
            if (bgFile) {
                 chatWindowScreen.style.backgroundImage = `url('${URL.createObjectURL(bgFile)}')`;
            }
            alert("保存成功！");
            contactSettingsScreen.classList.add('hidden');
            chatWindowScreen.classList.remove('hidden');
        } catch (error) {
            console.error("保存失败:", error);
            alert("保存失败，请检查控制台。");
        }
    });

    // 【修复】这个函数是干净、正确的版本
    async function renderContactList() {
        const listContentContainer = document.querySelector('.dialogue-list-content');
        const contacts = await db.contacts.toArray();
        if (contacts.length === 0) {
            listContentContainer.innerHTML = '<p class="empty-list-message">暂无对话，点击右上角 + 号开始新聊天</p>';
            return; 
        }
        listContentContainer.innerHTML = '';
        for (const contact of contacts) {
            let avatarUrl = './assets/default-avatar.png'; 
            if (contact.avatarFileKey) { 
                const avatarFile = await db.files.get(contact.avatarFileKey);
                if (avatarFile) avatarUrl = URL.createObjectURL(avatarFile.file);
            }
            let previewText = contact.persona; 
            const lastMessage = await db.chatMessages.where('contactId').equals(contact.id).last(); 
            if (lastMessage) previewText = lastMessage.text; 
            const displayName = contact.remark || contact.name;
            const contactItemEl = document.createElement('div');
            contactItemEl.className = 'contact-list-item'; 
            contactItemEl.dataset.contactId = contact.id; 

            // 【修复】这里的 class. 已经改回 class=
            contactItemEl.innerHTML = `
                <img src="${avatarUrl}" alt="头像" class="contact-item-avatar"> 
                <div class="contact-item-info">
                    <p class="contact-item-name">${displayName}</p> 
                    <p class="contact-item-preview">${previewText || '...'}</p> 
                </div>
            `;
            listContentContainer.appendChild(contactItemEl);
        }
    }

document.querySelector('.dialogue-list-content').addEventListener('click', async (event) => {
    const clickedItem = event.target.closest('.contact-list-item');
    if (!clickedItem) return; 
    currentOpenContactId = parseInt(clickedItem.dataset.contactId); 
    const contact = await db.contacts.get(currentOpenContactId);
    if (!contact) return; 
    document.querySelector('#chat-window-title').textContent = contact.name;
    
    // 【修复】先清除整个窗口的背景
    chatWindowScreen.style.backgroundImage = '';
    chatWindowScreen.style.backgroundColor = '#ffffff';
    
    // 【修复】移除消息容器中旧的背景层
    const oldBgLayer = messageContainer.querySelector('.chat-bg-layer');
    if (oldBgLayer) oldBgLayer.remove();
    
    // 【修复】如果有角色专属背景，创建新的背景层
  if (contact.chatBackgroundFileKey) {
    const bgFile = await db.files.get(contact.chatBackgroundFileKey);
    if (bgFile) {
        const bgImageUrl = URL.createObjectURL(bgFile.file);
        
        // 【简化】直接设置容器背景
        messageContainer.style.backgroundImage = `url('${bgImageUrl}')`;
        messageContainer.style.backgroundSize = 'cover';
        messageContainer.style.backgroundPosition = 'center';
        messageContainer.style.backgroundAttachment = 'fixed'; // 关键：固定背景
        
        console.log('✅ 已应用角色专属背景');
    }
} else {
    // 清除背景
    messageContainer.style.backgroundImage = '';
    messageContainer.style.backgroundColor = '#f9f9f9';
}
 
    // 【修复】加载历史消息（按顺序等待）
    messageContainer.innerHTML = ''; 
    const history = await db.chatMessages.where('contactId').equals(currentOpenContactId).toArray();

    // 【改】用 for...of 循环 + await 确保按顺序添加
    for (const msg of history) {
       await addMessageToUI(msg.sender, msg.text, msg.id);
       //  滚动到最新消息
       messageContainer.scrollTop = messageContainer.scrollHeight;
    }
    
    // 【修复】最后才应用全局样式（但会跳过角色专属背景）
    setTimeout(() => {
        applyChatStyles();
    }, 100);

    dialogueListScreen.classList.add('hidden');
    chatWindowScreen.classList.remove('hidden');
});


    // 【修复】这个函数是干净、正确的版本
    chatWindowBackBtn.addEventListener('click', () => {
        chatWindowScreen.classList.add('hidden'); 
        dialogueListScreen.classList.remove('hidden'); 
        currentOpenContactId = null; 
        chatWindowScreen.style.backgroundImage = '';
    });

    // ======================================================
    // 【新功能】组件编辑器 - 本地图片预览
    // ======================================================

    // 1. 监听“背景图”文件选择
    widgetBgFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader(); 
            reader.onload = (e) => {
                widgetBgPreview.src = e.target.result;
                widgetBgPreview.style.display = 'block'; 
            };
            reader.readAsDataURL(file); 
        } else {
            widgetBgPreview.style.display = 'none'; 
        }
    });

    // 2. 监听“头像”文件选择
    widgetAvatarFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                widgetAvatarPreview.src = e.target.result;
                widgetAvatarPreview.style.display = 'block';
            };
            reader.readAsDataURL(file);
        } else {
            widgetAvatarPreview.style.display = 'none';
        }
    });
  // ======================================================
// 【新功能】表情包库管理功能
// ======================================================

// 1. 解析批量导入的文本
function parseStickerBatchInput(text) {
    const lines = text.split('\n').filter(line => line.trim());
    const results = [];
    
    lines.forEach(line => {
        // 匹配三种格式: 文本+URL, 文本：URL, 文本,URL
        const match1 = line.match(/^(.+?)\+(.+)$/);
        const match2 = line.match(/^(.+?)：(.+)$/);
        const match3 = line.match(/^(.+?),(.+)$/);
        
        const match = match1 || match2 || match3;
        
        if (match) {
            const text = match[1].trim();
            const url = match[2].trim();
            
            // 简单验证URL
            if (url.startsWith('http://') || url.startsWith('https://')) {
                results.push({ text, url });
            }
        }
    });
    
    return results;
}
//  实时预览表情包
function updateStickerPreview() {
    const batchText = document.querySelector('#sticker-batch-input').value.trim();
    const previewGrid = document.querySelector('#sticker-preview-grid');
    const previewCount = document.querySelector('#preview-count');
    
    if (!batchText) {
        previewGrid.innerHTML = '<p style="font-size: 12px; color: #999; text-align: center; grid-column: 1 / -1;">输入链接后自动预览</p>';
        previewCount.textContent = '0';
        return;
    }
    
    // 解析文本
    const stickers = parseStickerBatchInput(batchText);
    
    if (stickers.length === 0) {
        previewGrid.innerHTML = '<p style="font-size: 12px; color: #ff3b30; text-align: center; grid-column: 1 / -1;">❌ 格式错误，请检查</p>';
        previewCount.textContent = '0';
        return;
    }
    
    // 更新数量
    previewCount.textContent = stickers.length;
    
    // 渲染预览
    previewGrid.innerHTML = '';
    stickers.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'preview-sticker-item';
        item.innerHTML = `
            <img src="${sticker.url}" alt="${sticker.text}" class="preview-sticker-img" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'60\' height=\'60\'%3E%3Crect fill=\'%23f0f0f0\' width=\'60\' height=\'60\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' font-size=\'10\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%23999\'%3E加载失败%3C/text%3E%3C/svg%3E'">
            <span class="preview-sticker-text">${sticker.text}</span>
        `;
        previewGrid.appendChild(item);
    });
}

// 2. 渲染已导入的表情包库列表
async function renderStickerLibraries() {
    const container = document.querySelector('#sticker-libraries-container');
    const libraries = await db.sticker_libraries.toArray();
    
    if (libraries.length === 0) {
        container.innerHTML = '<p style="font-size: 12px; color: #777; text-align: center;">暂无表情包库</p>';
        return;
    }
    
    container.innerHTML = '';
    
    for (const library of libraries) {
        // 统计这个库有多少个表情
        const count = await db.stickers.where('libraryId').equals(library.id).count();
        
        const item = document.createElement('div');
        item.className = 'sticker-library-item';
        item.innerHTML = `
            <div class="sticker-library-info">
                <p class="sticker-library-name">📁 ${library.name}</p>
                <p class="sticker-library-count">${count} 个表情包</p>
            </div>
            <div class="sticker-library-actions">
                <button class="sticker-view-btn" data-library-id="${library.id}">查看</button>
                <button class="sticker-delete-btn" data-library-id="${library.id}">删除</button>
            </div>
        `;
        
        container.appendChild(item);
    }
}


//  查看表情包库
async function viewStickerLibrary(libraryId) {
    const library = await db.sticker_libraries.get(libraryId);
    if (!library) {
        alert('找不到该表情包库！');
        return;
    }
    
    // 获取这个库的所有表情包
    const stickers = await db.stickers.where('libraryId').equals(libraryId).toArray();
    
    // 打开弹窗
    const popup = document.querySelector('#view-sticker-popup');
    document.body.appendChild(popup);
    
    // 设置弹窗样式（与导入弹窗一致）
    popup.style.position = 'fixed';
    popup.style.top = '0';
    popup.style.left = '0';
    popup.style.width = '100vw';
    popup.style.height = '100vh';
    popup.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    popup.style.display = 'flex';
    popup.style.justifyContent = 'center';
    popup.style.alignItems = 'center';
    popup.style.zIndex = '999999';
    
    popup.classList.remove('hidden');
    
    const content = popup.querySelector('.popup-content');
    if (content) {
        content.style.backgroundColor = '#ffffff';
        content.style.padding = '20px 25px';
        content.style.borderRadius = '25px';
    }
    
    // 更新标题和统计
    document.querySelector('#view-library-name').textContent = library.name;
    document.querySelector('#view-sticker-count').textContent = stickers.length;
    
    // 渲染表情包网格
    const grid = document.querySelector('#view-sticker-grid');
    
    if (stickers.length === 0) {
        grid.innerHTML = '<p style="font-size: 12px; color: #999; text-align: center; grid-column: 1 / -1;">这个库是空的</p>';
        return;
    }
    
    grid.innerHTML = '';
    stickers.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-grid-item';
        item.dataset.stickerId = sticker.id;  //  保存表情包ID
        item.innerHTML = `
            <button class="sticker-item-delete" data-sticker-id="${sticker.id}">×</button>
            <img src="${sticker.url}" alt="${sticker.text}" class="sticker-grid-img" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'70\' height=\'70\'%3E%3Crect fill=\'%23f0f0f0\' width=\'70\' height=\'70\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' font-size=\'10\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%23999\'%3E加载失败%3C/text%3E%3C/svg%3E'">
            <span class="sticker-grid-text">${sticker.text}</span>
        `;
        grid.appendChild(item);
    });
    
    //  为删除按钮添加事件监听
    grid.querySelectorAll('.sticker-item-delete').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();  // 阻止事件冒泡
            const stickerId = parseInt(btn.dataset.stickerId);
            const stickerText = btn.parentElement.querySelector('.sticker-grid-text').textContent;
            
            if (confirm(`确定要删除表情包"${stickerText}"吗？`)) {
                try {
                    // 从数据库删除
                    await db.stickers.delete(stickerId);
                    
                    // 从UI中移除
                    btn.parentElement.remove();
                    
                    // 更新统计数字
                    const currentCount = parseInt(document.querySelector('#view-sticker-count').textContent);
                    document.querySelector('#view-sticker-count').textContent = currentCount - 1;
                    
                    // 如果删完了，显示提示
                    if (grid.children.length === 0) {
                        grid.innerHTML = '<p style="font-size: 12px; color: #999; text-align: center; grid-column: 1 / -1;">这个库是空的</p>';
                    }
                    
                    // 刷新"我"页面的表情库列表
                    await renderStickerLibraries();
                    
                } catch (error) {
                    console.error('删除失败:', error);
                    alert('删除失败，请重试');
                }
            }
        });
    });
}


// 5. 删除表情包库
async function deleteStickerLibrary(libraryId) {
    const library = await db.sticker_libraries.get(libraryId);
    if (!library) return;
    
    if (!confirm(`确定要删除表情包库"${library.name}"吗？\n库中的所有表情包也会被删除。`)) {
        return;
    }
    
    // 删除库中的所有表情
    await db.stickers.where('libraryId').equals(libraryId).delete();
    
    // 删除库本身
    await db.sticker_libraries.delete(libraryId);
    
    // 从用户和角色的选择中移除
    const userSelection = await db.user_sticker_selection.get('user');
    if (userSelection) {
        const newIds = userSelection.libraryIds.filter(id => id !== libraryId);
        await db.user_sticker_selection.put({ key: 'user', libraryIds: newIds });
    }
    
    const roleSelection = await db.role_sticker_selection.get('role');
    if (roleSelection) {
        const newIds = roleSelection.libraryIds.filter(id => id !== libraryId);
        await db.role_sticker_selection.put({ key: 'role', libraryIds: newIds });
    }
    
    alert('删除成功！');
    await renderStickerLibraries();
}

// ======================================================
// 【新功能】"我"页面事件监听
// ======================================================

// 【新】"我"页面 - 打开/关闭
const meAppIcon = document.querySelector('#icon-me');


meAppIcon.addEventListener('click', async () => {
    appGrid.classList.add('home-screen-hidden');
    dock.classList.add('home-screen-hidden');
    meScreen.classList.remove('hidden');
  await loadMyPersonaPresets();
});

meBackBtn.addEventListener('click', () => {
    appGrid.classList.remove('home-screen-hidden');
    dock.classList.remove('home-screen-hidden');
    meScreen.classList.add('hidden');
});

// 【新】"我"页面 - 人设手风琴的展开/折叠
const personaAccordionHeader = document.querySelector('#persona-accordion-header');
const personaAccordionContent = document.querySelector('#persona-accordion-content');

personaAccordionHeader.addEventListener('click', async () => { // 【改】加上 async
    personaAccordionHeader.classList.toggle('expanded');
    personaAccordionContent.classList.toggle('expanded');
    
    //  展开时自动加载列表
    if (personaAccordionContent.classList.contains('expanded')) {
        await loadMyPersonaPresets();
    }
});


// 头像预览功能
personaAvatarInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            personaAvatarPreview.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    }
});

// 关闭编辑弹窗
personaEditorCloseBtn.addEventListener('click', closePersonaEditor);
personaEditorPopup.addEventListener('click', (e) => {
    if (e.target === personaEditorPopup) closePersonaEditor();
});

// 保存人设按钮
savePersonaBtn.addEventListener('click', async () => {
    const name = document.querySelector('#persona-name-input').value.trim();
    const description = document.querySelector('#persona-desc-input').value.trim();
    
    if (!name) {
        alert('请输入人设名称！');
        return;
    }

    let avatarFileKey = null;
    const avatarFile = document.querySelector('#persona-avatar-input').files[0];
    
    if (avatarFile) {
        // 用户上传了新头像
        avatarFileKey = 'persona_avatar_' + Date.now();
        await db.files.put({ key: avatarFileKey, file: avatarFile });
    } else if (currentEditingPersonaId) {
        // 编辑模式，保留原头像
        const existingPersona = await db.my_persona_presets.get(currentEditingPersonaId);
        if (existingPersona) avatarFileKey = existingPersona.avatarFileKey;
    }

    const personaData = {
        name: name,
        description: description,
        avatarFileKey: avatarFileKey
    };

    if (currentEditingPersonaId) {
        // 更新现有人设
        await db.my_persona_presets.update(currentEditingPersonaId, personaData);
        alert('保存成功！');
    } else {
        // 创建新人设
        await db.my_persona_presets.add(personaData);
        alert('创建成功！');
    }

    closePersonaEditor();
    await loadMyPersonaPresets(); // 刷新列表
    await populateMyPersonaSelects(); // 刷新其他地方的人设选择器
});
  // 【新】"新增"按钮 - 打开空白编辑弹窗
const personaAddBtn = document.querySelector('#persona-add-btn');
personaAddBtn.addEventListener('click', () => {
    openPersonaEditor(null); // null 表示新建模式
});
async function loadMyPersonaPresets() {
    const listContainer = document.querySelector('#my-persona-list-container');
    if (!listContainer) return;
    
    const presets = await db.my_persona_presets.toArray();
    
    if (presets.length === 0) {
        listContainer.innerHTML = '<p style="font-size: 12px; color: #777; text-align: center;">暂无人设</p>';
        return;
    }
    
    listContainer.innerHTML = '';
    for (const preset of presets) {
        let avatarUrl = './assets/default-avatar.png';
        if (preset.avatarFileKey) {
            const avatarFile = await db.files.get(preset.avatarFileKey);
            if (avatarFile) avatarUrl = URL.createObjectURL(avatarFile.file);
        }
        
        const item = document.createElement('div');
        item.className = 'persona-list-item';
        item.dataset.personaId = preset.id;
        item.innerHTML = `
            <img src="${avatarUrl}" alt="头像" class="persona-item-avatar">
            <div class="persona-item-info">
                <p class="persona-item-name">${preset.name}</p>
                <p class="persona-item-desc">${preset.description || '暂无描述'}</p>
            </div>
            <button class="persona-item-delete hidden">×</button>
        `;
        
        // 点击列表项打开编辑
        item.addEventListener('click', async (e) => {
            if (e.target.classList.contains('persona-item-delete')) return;
            await openPersonaEditor(preset.id);
        });
        
        // 点击删除按钮
        const deleteBtn = item.querySelector('.persona-item-delete');
        deleteBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (confirm(`确定要删除人设"${preset.name}"吗？`)) {
                await db.my_persona_presets.delete(preset.id);
                if (preset.avatarFileKey) {
                    await db.files.delete(preset.avatarFileKey);
                }
                await loadMyPersonaPresets();
                await populateMyPersonaSelects();
                alert('删除成功！');
            }
        });
        
        listContainer.appendChild(item);
    }
    
    // 【关键】列表渲染完成后，恢复管理模式状态
    updateManageMode();
}

//  "管理"按钮事件
const personaManageBtn = document.querySelector('#persona-manage-btn');

if (personaManageBtn) {
    personaManageBtn.addEventListener('click', () => {
        isManageMode = !isManageMode;
        const deleteButtons = document.querySelectorAll('.persona-item-delete');
        
        deleteButtons.forEach(btn => {
            if (isManageMode) {
                btn.classList.remove('hidden');
            } else {
                btn.classList.add('hidden');
            }
        });
        
        if (isManageMode) {
            personaManageBtn.textContent = '完成';
            personaManageBtn.style.backgroundColor = '#007aff';
            personaManageBtn.style.color = 'white';
        } else {
            personaManageBtn.textContent = '管理';
            personaManageBtn.style.backgroundColor = '';
            personaManageBtn.style.color = '';
        }
    });
}

function updateManageMode() {
  
    const personaManageBtn = document.querySelector('#persona-manage-btn');
    const deleteButtons = document.querySelectorAll('.persona-item-delete');
  
    
    if (isManageMode) {
        // 进入管理模式
        deleteButtons.forEach(btn => btn.classList.remove('hidden'));
        if (personaManageBtn) {
            personaManageBtn.textContent = '完成';
            personaManageBtn.style.backgroundColor = '#007aff';
            personaManageBtn.style.color = 'white';
        }
    } else {
        // 退出管理模式
        deleteButtons.forEach(btn => btn.classList.add('hidden'));
        if (personaManageBtn) {
            personaManageBtn.textContent = '管理';
            personaManageBtn.style.backgroundColor = '';
            personaManageBtn.style.color = '';
        }
    }
}//  滑块变化时更新输入框
contactSettingsContextSlider.addEventListener('input', () => {
    contactSettingsContextValue.value = contactSettingsContextSlider.value;
});

//  输入框变化时更新滑块
contactSettingsContextValue.addEventListener('input', () => {
    let newValue = parseInt(contactSettingsContextValue.value);
    
    // 限制范围
    if (newValue < 5) newValue = 5;
    if (newValue > 200) newValue = 200;
    if (isNaN(newValue)) newValue = 10;
    
    contactSettingsContextValue.value = newValue;
    contactSettingsContextSlider.value = newValue;
});

// ======================================================
// 【新功能】"记忆 & 总结" 页面事件监听
// ======================================================

// 1. 点击 Dock 上的 "记忆" App 图标
memoryAppIcon.addEventListener('click', () => {
    // 隐藏主屏幕
    appGrid.classList.add('home-screen-hidden');
    dock.classList.add('home-screen-hidden');
    // 显示记忆页面
    memoryScreen.classList.remove('hidden');


// 【修改】重置为 "请选择..."
summarySelectedCharacterName.textContent = '请选择要管理的角色...';
    summarySettingsContainer.classList.add('hidden');
    currentSummaryContactId = null;
});

// 2. 点击 "记忆" 页面的 "返回" 按钮
memoryBackBtn.addEventListener('click', () => {
    // 隐藏记忆页面
    memoryScreen.classList.add('hidden');
    // 恢复主屏幕
    appGrid.classList.remove('home-screen-hidden');
    dock.classList.remove('home-screen-hidden');
});

// --- (这是一个新函数, 用于计算聊天统计) ---
// ======================================================
// 【替换 8.10】使用 "黄金标准" (你来我往 = 1轮)
// ======================================================
async function updateSummaryStats(contactId) {
    if (!contactId) return;
    try {
        const contact = await db.contacts.get(contactId);
        if (!contact) {
            summaryStatsDisplay.textContent = "无法加载角色";
            return;
        }

        // 1. 【黄金标准】计算总轮数
        let totalTurns = 0;
        let lastSender = 'bot'; // 假定 AI 先说话, 这样第一条 user 消息就会被算作第1轮

        // 我们用 .each() 来一条一条地看, 这样最快
        await db.chatMessages
            .where('contactId').equals(contactId)
            .each(message => {
                // 如果这条是 'user', 且上一条是 'bot', 这才是一个新轮次的开始
                if (message.sender === 'user' && lastSender !== 'user') {
                    totalTurns++;
                }
                lastSender = message.sender; // 记录这一条的发送者
            });

        // 2. 获取上次总结到的轮数 (这个轮数现在也是 "黄金标准" 的轮数)
        const settings = contact.summarySettings || {};
        const lastSummaryTurn = settings.lastSummaryTurn || 0;

        const unsummarizedTurns = totalTurns - lastSummaryTurn;

        // 3. 显示统计 (现在是 100% 准确的 "你来我往" 轮数)
        summaryStatsDisplay.textContent = `已总结 ${lastSummaryTurn} 轮 / ${totalTurns} 轮 (${unsummarizedTurns > 0 ? unsummarizedTurns : 0} 轮未总结)`;

    } catch (error) {
        console.error("计算统计时出错:", error);
        summaryStatsDisplay.textContent = "统计加载失败";
    }
}

// --- (这是一个新函数, 用于加载所选角色的所有设置) ---
async function loadSummarySettings(contactId) {
    try {
        const contact = await db.contacts.get(contactId);
        if (!contact) {
            alert("错误：找不到该联系人！");
            return;
        }

        // 【新】把选中的名字显示在按钮上
        summarySelectedCharacterName.textContent = contact.name;

        // 1. 加载 "自动总结" 设置
        const settings = contact.summarySettings || { auto: false, rounds: 20, lastSummaryTurn: 0 };

        if (settings.auto) {
            summaryAutoToggle.classList.add('active');
        } else {
            summaryAutoToggle.classList.remove('active');
        }

        summaryRoundsSlider.value = settings.rounds || 20;
     summaryRoundsValue.value = settings.rounds || 20;


        // 2. 加载 "手动总结" 统计
        await updateSummaryStats(contactId);

        // 3. 加载 "AI 总结内容"
        summaryTextarea.value = contact.aiSummaryText || '';

        // 4. 【关键】显示整个设置面板
        summarySettingsContainer.classList.remove('hidden');

    } catch (error) {
        console.error("加载总结设置失败:", error);
        alert("加载设置失败，请查看控制台。");
    }
}
  
  // 4. 【新】监听 "请选择角色" 按钮的点击
summaryCharacterSelectorBtn.addEventListener('click', async () => { // <-- 【改】1. 加上 async

    // 【新】2. 清空 "选人" 页的搜索框
    characterSearchInput.value = ''; 

    // 【新】3. 加载完整列表 (实现 "选" 的功能)
    await renderCharacterSelectorList(); 

    // 打开"选人"页面
    characterSelectorScreen.classList.remove('hidden');
});

// 5. 【新】监听 "选人" 页面的 "返回" 按钮
characterSelectorBackBtn.addEventListener('click', () => {
    // 关闭"选人"页面
    characterSelectorScreen.classList.add('hidden');
});
  // ======================================================
// 【新添加】"选人"页面的核心功能
// ======================================================

// --- (这是一个新函数, 用于 "选人" 页面, 负责显示列表) ---
async function renderCharacterSelectorList(query = '') {
    // 1. 清空旧列表, 显示加载中
    characterSelectorList.innerHTML = '<p class="empty-list-message" style="margin-top: 20px;">正在加载...</p>';

    let contacts;
    try {
        // 2. 根据是否有 "搜索词" 来从数据库获取数据
        if (query) {
            // "搜" 模式
            contacts = await db.contacts.where('name').startsWith(query).toArray();
        } else {
            // "选" 模式 (加载全部)
            contacts = await db.contacts.toArray();
        }

        // 3. 再次清空 (清除 "加载中")
        characterSelectorList.innerHTML = '';

        if (contacts.length === 0) {
            characterSelectorList.innerHTML = '<p class="empty-list-message" style="margin-top: 20px;">' + (query ? '无匹配角色' : '暂无联系人') + '</p>';
            return;
        }

        // 4. 循环创建列表项 (我们复用 "联系人" App 的样式)
        for (const contact of contacts) {
            let avatarUrl = './assets/default-avatar.png'; 
            if (contact.avatarFileKey) { 
                const avatarFile = await db.files.get(contact.avatarFileKey);
                if (avatarFile) avatarUrl = URL.createObjectURL(avatarFile.file);
            }

            const displayName = contact.name; 

            const contactItemEl = document.createElement('div');
            contactItemEl.className = 'contact-list-item'; // 复用样式
            contactItemEl.dataset.contactId = contact.id;

            contactItemEl.innerHTML = `
                <img src="${avatarUrl}" alt="头像" class="contact-item-avatar"> 
                <div class="contact-item-info">
                    <p class="contact-item-name">${displayName}</p> 
                </div>
            `;

            // 5. 【关键】为每个列表项添加点击事件
            contactItemEl.addEventListener('click', () => {
                const contactId = contact.id;

                // 5.1 记录我们选中的 ID
                currentSummaryContactId = contactId; 

                // 5.2 加载这个角色的总结设置 (到"记忆"主页上)
                loadSummarySettings(contactId);

                // 5.3 关闭 "选人" 页面
                characterSelectorScreen.classList.add('hidden');
            });

            characterSelectorList.appendChild(contactItemEl);
        }

    } catch (error) {
        console.error("加载角色列表失败:", error);
        characterSelectorList.innerHTML = '<p class="empty-list-message" style="color: red;">加载列表失败</p>';
    }
}
// 5. 【新】让 "总结频率" 滑块能实时更新文字
// 1. 滑块变化时，更新输入框
summaryRoundsSlider.addEventListener('input', () => {
    summaryRoundsValue.value = summaryRoundsSlider.value;
});

// 2. 输入框变化时，更新滑块
summaryRoundsValue.addEventListener('input', () => {
    let newValue = parseInt(summaryRoundsValue.value);
    
    // 限制范围
    if (newValue < 0) newValue = 0;
    if (newValue > 200) newValue = 200;
    if (isNaN(newValue)) newValue = 20; // 如果输入非法，恢复默认值
    
    summaryRoundsValue.value = newValue;
    summaryRoundsSlider.value = newValue;
});

  // --- (这是一个新函数, 用于保存 "自动总结" 的设置, 避免代码重复) ---
async function saveSummarySetting(settingKey, settingValue) {
    if (!currentSummaryContactId) return; // 安全检查, 确保有选中的角色

    try {
        const contact = await db.contacts.get(currentSummaryContactId);
        if (!contact) return;

        // 1. 获取旧设置, 或创建一个新对象
        const oldSettings = contact.summarySettings || {};

        // 2. 更新你指定的那个设置 (例如 'auto' 或 'rounds')
        const newSettings = { ...oldSettings, [settingKey]: settingValue };

        // 3. 将更新后的完整设置对象, 保存回数据库
        await db.contacts.update(currentSummaryContactId, { summarySettings: newSettings });

    } catch (error) {
        console.error(`保存 ${settingKey} 失败:`, error);
    }
}

// 6. 【新】监听 "自动总结" 开关的点击
summaryAutoToggle.addEventListener('click', () => {
    // 切换 'active' 状态并获取新状态 (true / false)
    const isActive = summaryAutoToggle.classList.toggle('active');

    // 异步保存这个新状态, "即时生效, 无需等待"
    saveSummarySetting('auto', isActive); 
});

// 7. 【新】监听 "总结频率" 滑块的 "松手" (我们用 'change' 事件)
// 滑块松手时保存
summaryRoundsSlider.addEventListener('change', () => {
    const newRounds = parseInt(summaryRoundsSlider.value);
    saveSummarySetting('rounds', newRounds);
});

// 输入框失去焦点时保存
summaryRoundsValue.addEventListener('blur', () => {
    const newRounds = parseInt(summaryRoundsValue.value);
    if (!isNaN(newRounds) && newRounds >= 0 && newRounds <= 200) {
        saveSummarySetting('rounds', newRounds);
    }
});

// 输入框按下回车时保存
summaryRoundsValue.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        summaryRoundsValue.blur(); // 触发blur事件
    }
});


// 8. 【新】监听 "保存修改" (AI总结内容) 按钮的点击
summarySaveTextBtn.addEventListener('click', async () => {
    if (!currentSummaryContactId) return; // 安全检查

    const newText = summaryTextarea.value; // 获取文本框里的所有内容

    try {
        // 直接更新数据库中的 aiSummaryText 字段
        await db.contacts.update(currentSummaryContactId, { aiSummaryText: newText });
        alert("总结已保存！"); // 给用户一个明确的反馈

    } catch (error) {
        console.error("保存总结文本失败:", error);
        alert("保存失败，请查看控制台。");
    }
});
  // ======================================================
// 【新添加】"选人"页面的搜索框事件
// ======================================================
characterSearchInput.addEventListener('input', () => {
    // 清除上一个计时器 (防抖)
    clearTimeout(summarySearchTimeout); 

    // 延迟 300ms 执行搜索
    summarySearchTimeout = setTimeout(async () => {
        const query = characterSearchInput.value.trim();
        // 调用同一个函数, 但这次传入 "搜索词" (实现 "搜" 的功能)
        await renderCharacterSelectorList(query); 
    }, 300);
});
  // ======================================================
// ======================================================
// 【新功能1】计算聊天的轮数（黄金标准：你来我往=1轮）
// ======================================================
async function calculateGoldenStandardTurns(contactId) {
    // 1. 创建两个"盒子"来装结果
    let totalTurns = 0;        // 总共聊了多少轮
    let turnBlocks = [];       // 每一轮的详细内容
    
    // 2. 创建临时变量
    let lastSender = 'bot';    // 假设AI先说话
    let currentBlock = [];     // 当前这一轮的消息
    
    // 3. 从数据库取出所有聊天记录
    const messages = await db.chatMessages
        .where('contactId').equals(contactId)
        .sortBy('timestamp'); // 按时间排序
    
    // 4. 一条一条地看每条消息
    for (const msg of messages) {
        // 4.1 如果这条是"用户"发的，且上一条是"AI"发的
        if (msg.sender === 'user' && lastSender !== 'user') {
            // 说明新的一轮开始了！
            
            // 把之前累积的消息存起来
            if (currentBlock.length > 0) {
                turnBlocks.push([...currentBlock]);
            }
            
            // 开始新一轮
            totalTurns++;
            currentBlock = [];
        }
        
        // 4.2 把这条消息加入当前轮次
        currentBlock.push({
            sender: msg.sender,
            text: msg.text
        });
        
        // 4.3 记录这条消息的发送者
        lastSender = msg.sender;
    }
    
    // 5. 别忘了最后一轮！
    if (currentBlock.length > 0) {
        turnBlocks.push(currentBlock);
    }
    
    // 6. 返回结果
    return { 
        totalTurns: totalTurns,     // 数字：总轮数
        turnBlocks: turnBlocks      // 数组：每轮的详细内容
    };
}
// ======================================================
// 【新功能2】调用AI生成总结（核心逻辑）
// ======================================================
async function runSummaryGeneration(
    contactId, 
  unsummarizedBlocks,  // 📦 未总结的对话块
    preset,              // 🔑 API配置
    roleName,            // 👤 AI角色名
    userName,            // 👤 用户名
    existingSummary,     // 📝 已有的旧总结
    updateUiCallback     // 🎨 UI更新函数（可选）
) {
    // ===== 第1阶段：构建提示词 =====
    
    // 1.1 把对话块转换成易读的文本
    let conversationText = "";
    unsummarizedBlocks.forEach((block, index) => {
        conversationText += `\n--- 第 ${index + 1} 轮对话 ---\n`;
        block.forEach(msg => {
            const speaker = msg.sender === 'user' ? userName : roleName;
            conversationText += `${speaker}: ${msg.text}\n`;
        });
    });
    
    // 1.2 构建系统提示词
  const systemPrompt = `你是一个专业的对话记录分析师。你的任务是生成结构化的对话总结。

📋 **总结格式要求：**

1. 开头必须包含时间戳和轮次范围：
   📅 [当前日期] - 第X-Y轮对话

2. 使用列表形式记录事件（用 • 符号）：
   • 第一个关键事件
   • 第二个关键事件
   ...

3. 结尾用分隔线：
   ---

🎯 **内容要求：**
- 用第三人称描述（例如："${userName}询问了..."、"${roleName}回答说..."）
- 保留所有重要细节：具体的问题、关键的回答、情感变化、决策点
- 按时间顺序组织，确保逻辑连贯
- 每个要点应该是一个完整的句子（不要只写关键词）
- 如果对话中有明确的结论或下一步计划，务必记录

📌 **特殊规则：**
- 如果已有旧总结，请在新总结**之后**追加（保持时间顺序）
- 每条要点控制在0-100字
- 整体总结控制在0-1000字
- 绝对不要突然截断，确保每个总结都有完整的结尾`;


    // 1.3 构建用户请求
// 1. 计算轮次范围
const startTurn = (await db.contacts.get(contactId)).summarySettings?.lastSummaryTurn || 0;
const endTurn = startTurn + unsummarizedBlocks.length;

// 2. 获取当前日期
const currentDate = new Date().toLocaleDateString('zh-CN', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
});

// 3. 构建提示词
const userPrompt = `**当前日期：** ${currentDate}
**本次总结的轮次范围：** 第 ${startTurn + 1} 轮 到 第 ${endTurn} 轮

**已有的旧总结：**
${existingSummary}

**新对话记录（共 ${unsummarizedBlocks.length} 轮）：**
${conversationText}

请按照格式要求生成新总结：`;


    // ===== 第2阶段：调用API =====
    
    try {
        // 2.1 更新UI（如果有回调函数）
        if (updateUiCallback) {
            updateUiCallback("正在请求AI...", "正在生成总结 (2/3)...");
        }
        
        // 2.2 发送请求
        const { apiKey, baseUrl, model } = preset;
        const response = await fetch(`${baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify({
                model: model,
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ],
                temperature: 0.7,  // 让总结更客观
                max_tokens: 8000    // 控制总结长度
            })
        });
        
        // 2.3 检查响应
        if (!response.ok) {
            throw new Error(`API错误: ${response.status}`);
        }
        
        const data = await response.json();
        
        // 2.4 提取总结内容
        const summaryText = data.choices[0].message.content.trim();
        
        // 2.5 更新UI（如果有回调）
        if (updateUiCallback) {
            updateUiCallback("总结完成", "正在保存 (3/3)...");
        }
        
        return summaryText;
        
    } catch (error) {
        console.error('调用AI失败:', error);
        throw error;
    }
}
// ======================================================
// 【新功能3】执行总结的核心逻辑（手动和自动共用）
// ======================================================
async function executeSummary(contactId, updateUiCallback = null) {
    // 1. 获取API配置
    const preset = await getActiveSummaryApiPreset();
    if (preset.error) {
        throw new Error(preset.error);
    }
    
    // 2. 获取联系人数据
    const contact = await db.contacts.get(contactId);
    if (!contact) {
        throw new Error("找不到联系人");
    }
    
    const settings = contact.summarySettings || { lastSummaryTurn: 0 };
    const lastSummaryTurn = settings.lastSummaryTurn || 0;
    const existingSummary = contact.aiSummaryText || "无";
    
    // 3. 获取角色名和用户名
    const roleName = contact.name;
    let userName = "用户";
    if (contact.myPersonaPresetId) {
        const myPreset = await db.my_persona_presets.get(contact.myPersonaPresetId);
        if (myPreset && myPreset.name) userName = myPreset.name;
    }
    
    // 4. 计算轮数
    if (updateUiCallback) {
        updateUiCallback("正在计算...", "正在构建轮次 (1/3)...");
    }
    
    const { totalTurns, turnBlocks } = await calculateGoldenStandardTurns(contactId);
    const unsummarizedBlocks = turnBlocks.slice(lastSummaryTurn);
    
    // 5. 检查是否有新内容
    if (unsummarizedBlocks.length === 0) {
        throw new Error("No new messages");
    }
    
    // 6. 调用AI生成总结
    const newContentString = await runSummaryGeneration(
       contactId, 
      unsummarizedBlocks,
        preset,
        roleName,
        userName,
        existingSummary,
        updateUiCallback
    );
    
    // 7. 保存总结
    const finalSummary = (existingSummary === "无" ? "" : existingSummary + "\n\n") + newContentString;
    
    await db.contacts.update(contactId, {
        aiSummaryText: finalSummary
    });
    
    await saveSummarySetting('lastSummaryTurn', totalTurns);
    
    // 8. 更新UI（如果在总结页面）
    if (updateUiCallback) {
        summaryTextarea.value = finalSummary;
        await updateSummaryStats(contactId);
    }
}
// ======================================================
// 【新功能4】自动总结检查与执行
// ======================================================
async function checkAndRunAutoSummary(contactId) {
    try {
        // 1. 获取联系人设置
        const contact = await db.contacts.get(contactId);
        if (!contact) return;
        
        const settings = contact.summarySettings || { auto: false };
        
        // 2. 检查是否开启了自动总结
        if (!settings.auto) {
            console.log('⏸️ 自动总结未开启');
            return;
        }
        
        // 3. 计算当前轮数
        const { totalTurns } = await calculateGoldenStandardTurns(contactId);
        const lastSummaryTurn = settings.lastSummaryTurn || 0;
        const triggerRounds = settings.rounds || 20;
        
        // 4. 判断是否达到触发条件
        const unsummarizedTurns = totalTurns - lastSummaryTurn;
        
        if (unsummarizedTurns < triggerRounds) {
            console.log(`⏳ 自动总结: 未达到触发条件 (${unsummarizedTurns}/${triggerRounds})`);
            return;
        }
        
        // 5. 触发条件满足！开始执行
        console.log(`🤖 自动总结触发: 已累积 ${unsummarizedTurns} 轮未总结`);
        
        // 6. 静默执行总结（不传UI回调）
        await executeSummary(contactId, null);
        
        console.log('✅ 自动总结完成');
        
    } catch (error) {
        // 静默失败，不打扰用户
        console.error('❌ 自动总结失败:', error);
    }
}

summaryManualBtn.addEventListener('click', async () => {
    if (!currentSummaryContactId) return;
    
    // 1. UI反馈
    summaryManualBtn.disabled = true;
    summaryManualBtn.textContent = "正在分析...";
    
    // 2. UI更新回调函数
    const updateUi = (btnText, statsText) => {
        summaryManualBtn.textContent = btnText;
        summaryStatsDisplay.textContent = statsText;
    };
    
    try {
        // 3. 调用总结逻辑（复用核心函数）
        await executeSummary(currentSummaryContactId, updateUi);
        
        alert("总结完成！");
        
    } catch (error) {
        if (error.message !== "No new messages") {
            alert(`总结失败: ${error.message}`);
        }
    } finally {
        // 4. 重置按钮
        summaryManualBtn.disabled = false;
        summaryManualBtn.textContent = "立即手动总结 (未总结部分)";
    }
});

// 1. 表情包库手风琴的展开/折叠
const stickerAccordionHeader = document.querySelector('#sticker-accordion-header');
const stickerAccordionContent = document.querySelector('#sticker-accordion-content');

if (stickerAccordionHeader) {
    stickerAccordionHeader.addEventListener('click', async () => {
        stickerAccordionHeader.classList.toggle('expanded');
        stickerAccordionContent.classList.toggle('expanded');
        
        // 展开时加载表情库列表
        if (stickerAccordionContent.classList.contains('expanded')) {
            await renderStickerLibraries();
        }
    });
}




const importStickerBtn = document.querySelector('#import-sticker-btn');
if (importStickerBtn) {
    importStickerBtn.addEventListener('click', () => {
        const popup = document.querySelector('#import-sticker-popup');
        
        // 关键修复：把弹窗移到 body 下面（脱离 phone-screen）
        document.body.appendChild(popup);
        
        // 然后再设置样式
        popup.style.position = 'fixed';
        popup.style.top = '0';
        popup.style.left = '0';
        popup.style.width = '100vw';
        popup.style.height = '100vh';
        popup.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
        popup.style.display = 'flex';
        popup.style.justifyContent = 'center';
        popup.style.alignItems = 'center';
        popup.style.zIndex = '999999';
        
        popup.classList.remove('hidden');
        
        const content = popup.querySelector('.popup-content');
        if (content) {
            content.style.backgroundColor = '#ffffff';
            content.style.padding = '20px 25px';
            content.style.borderRadius = '25px';
            content.style.maxWidth = '320px';
            content.style.maxHeight = '500px';
            content.style.overflowY = 'auto';
        }
        
        document.querySelector('#sticker-library-name-input').value = '';
        document.querySelector('#sticker-batch-input').value = '';
         //  监听输入框的变化
        const batchInput = document.querySelector('#sticker-batch-input');
        if (batchInput) {
            // 移除旧的监听器（如果有）
            batchInput.removeEventListener('input', updateStickerPreview);
            // 添加新的监听器
            batchInput.addEventListener('input', updateStickerPreview);
        }
        
        // 清空预览
        document.querySelector('#sticker-preview-grid').innerHTML = '<p style="font-size: 12px; color: #999; text-align: center; grid-column: 1 / -1;">输入链接后自动预览</p>';
        document.querySelector('#preview-count').textContent = '0';
      
    });
}



// 5. 导入弹窗 - 取消/关闭
const importStickerCancelBtn = document.querySelector('#import-sticker-cancel-btn');
if (importStickerCancelBtn) {
    importStickerCancelBtn.addEventListener('click', () => {
        document.querySelector('#import-sticker-popup').classList.add('hidden');
    });
}

const importStickerCloseBtn = document.querySelector('#import-sticker-close-btn');
if (importStickerCloseBtn) {
    importStickerCloseBtn.addEventListener('click', () => {
        document.querySelector('#import-sticker-popup').classList.add('hidden');
    });
}

// 6. 导入弹窗 - 确认导入
const importStickerConfirmBtn = document.querySelector('#import-sticker-confirm-btn');
if (importStickerConfirmBtn) {
    importStickerConfirmBtn.addEventListener('click', async () => {
        const name = document.querySelector('#sticker-library-name-input').value.trim();
        const batchText = document.querySelector('#sticker-batch-input').value.trim();
        
        if (!name) {
            alert('请输入表情包库名称！');
            return;
        }
        
        if (!batchText) {
            alert('请粘贴表情包链接！');
            return;
        }
        
        // 解析文本
        const stickers = parseStickerBatchInput(batchText);
        
        if (stickers.length === 0) {
            alert('没有解析到有效的表情包！\n请检查格式是否正确。');
            return;
        }
        
        try {
            // 创建新库
            const libraryId = await db.sticker_libraries.add({ name });
            
            // 批量添加表情包
            for (const sticker of stickers) {
                await db.stickers.add({
                    libraryId: libraryId,
                    text: sticker.text,
                    url: sticker.url
                });
            }
            
            alert(`成功导入 ${stickers.length} 个表情包！`);
            
            // 关闭弹窗并刷新列表
            document.querySelector('#import-sticker-popup').classList.add('hidden');
            await renderStickerLibraries();
            
        } catch (error) {
            console.error('导入失败:', error);
            alert('导入失败，请查看控制台错误信息。');
        }
    });
}



// 8. 选择弹窗 - 确认
const selectStickerConfirmBtn = document.querySelector('#select-sticker-confirm-btn');
if (selectStickerConfirmBtn) {
    selectStickerConfirmBtn.addEventListener('click', () => {
        saveStickerSelection();
    });
}

// 9. 表情库列表 - 查看/删除按钮
const stickerLibrariesContainer = document.querySelector('#sticker-libraries-container');
if (stickerLibrariesContainer) {
    stickerLibrariesContainer.addEventListener('click', async (e) => {
        const libraryId = parseInt(e.target.dataset.libraryId);
        
        if (e.target.classList.contains('sticker-view-btn')) {
            // 【修改】调用查看功能
            await viewStickerLibrary(libraryId);
        }
        
        if (e.target.classList.contains('sticker-delete-btn')) {
            await deleteStickerLibrary(libraryId);
        }
    });
}

      //  查看弹窗 - 关闭
const viewStickerCloseBtn = document.querySelector('#view-sticker-close-btn');
if (viewStickerCloseBtn) {
    viewStickerCloseBtn.addEventListener('click', () => {
        document.querySelector('#view-sticker-popup').classList.add('hidden');
    });
}

const viewStickerCloseBtn2 = document.querySelector('#view-sticker-close-btn2');
if (viewStickerCloseBtn2) {
    viewStickerCloseBtn2.addEventListener('click', () => {
        document.querySelector('#view-sticker-popup').classList.add('hidden');
    });
}
// ======================================================
// 【新功能】聊天时发送表情包
// ======================================================

let currentActiveStickerTab = null; // 当前选中的表情库ID
let stickerSearchTimeout = null;

// 1. 加载表情面板的标签页
async function loadStickerPanelTabs() {
    const tabsContainer = document.querySelector('#sticker-panel-tabs');
    const libraries = await db.sticker_libraries.toArray();
    
    if (libraries.length === 0) {
        tabsContainer.innerHTML = '<p style="font-size: 12px; color: #999;">暂无表情包库</p>';
        return;
    }
    
    tabsContainer.innerHTML = '';
    
    // 为每个表情库创建标签
    libraries.forEach((library, index) => {
        const tab = document.createElement('button');
        tab.className = 'sticker-tab';
        tab.textContent = library.name;
        tab.dataset.libraryId = library.id;
        
        // 默认选中第一个
        if (index === 0) {
            tab.classList.add('active');
            currentActiveStickerTab = library.id;
        }
        
        // 点击切换标签
        tab.addEventListener('click', async () => {
            // 移除其他标签的active
            tabsContainer.querySelectorAll('.sticker-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            
            currentActiveStickerTab = library.id;
            await loadStickerPanelContent(library.id);
        });
        
        tabsContainer.appendChild(tab);
    });
    
    // 加载第一个库的内容
    if (libraries.length > 0) {
        await loadStickerPanelContent(libraries[0].id);
    }
}

// 2. 加载表情面板的内容
async function loadStickerPanelContent(libraryId, searchQuery = '') {
    const contentContainer = document.querySelector('#sticker-panel-content');
    
    let stickers;
    if (searchQuery) {
        // 搜索模式：在当前库中搜索
        stickers = await db.stickers
            .where('libraryId').equals(libraryId)
            .filter(s => s.text.includes(searchQuery))
            .toArray();
    } else {
        // 正常模式：显示所有表情
        stickers = await db.stickers.where('libraryId').equals(libraryId).toArray();
    }
    
    if (stickers.length === 0) {
        contentContainer.innerHTML = '<p style="font-size: 12px; color: #999; text-align: center; grid-column: 1 / -1;">无匹配的表情包</p>';
        return;
    }
    
    contentContainer.innerHTML = '';
    
    stickers.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-panel-item';
        item.innerHTML = `
            <img src="${sticker.url}" alt="${sticker.text}" class="sticker-panel-img" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'60\' height=\'60\'%3E%3Crect fill=\'%23f0f0f0\' width=\'60\' height=\'60\'/%3E%3Ctext x=\'50%25\' y=\'50%25\' font-size=\'10\' text-anchor=\'middle\' dy=\'.3em\' fill=\'%23999\'%3E加载失败%3C/text%3E%3C/svg%3E'">
            <span class="sticker-panel-text">${sticker.text}</span>
        `;
        
        // 点击发送表情包
        item.addEventListener('click', async () => {
            await sendStickerMessage(sticker);
            // 发送后关闭面板
            document.querySelector('#sticker-panel').classList.add('hidden');
        });
        
        contentContainer.appendChild(item);
    });
}

// 3. 发送表情包消息
async function sendStickerMessage(sticker) {
    if (!currentOpenContactId) return;
    
    // 【立即】关闭表情面板
    const panel = document.querySelector('#sticker-panel');
    if (panel) {
        panel.classList.add('hidden');
    }
    
    // 保存到数据库（使用特殊格式标记为表情包）
    const message = {
        contactId: currentOpenContactId,
        sender: 'user',
        text: `[STICKER]${sticker.url}|||${sticker.text}`,
        timestamp: new Date()
    };
    
    await db.chatMessages.add(message);
    
    // 添加到UI（使用修改后的 addMessageToUI）
    addMessageToUI('user', `[STICKER]${sticker.url}|||${sticker.text}`);
    
    // 刷新联系人列表
    renderContactList();
    
    // 【删除】不再自动调用 AI 回复
    // 用户需要点击"接收"按钮才会触发回复
}



// 4. 在UI中显示表情包
function addStickerToUI(sender, url, text) {
    const messageEl = document.createElement('div');
    messageEl.classList.add('message-bubble');
    messageEl.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
    messageEl.innerHTML = `<img src="${url}" alt="${text}" class="message-sticker">`;
    messageContainer.appendChild(messageEl);
    messageContainer.scrollTop = messageContainer.scrollHeight;
}



// ======================================================
//  表情面板相关事件
// ======================================================

// 1. 表情按钮 - 切换面板显示/隐藏
const stickerToggleBtn = document.querySelector('#sticker-toggle-btn');
if (stickerToggleBtn) {
    stickerToggleBtn.addEventListener('click', async () => {
        const panel = document.querySelector('#sticker-panel');
        
        if (panel.classList.contains('hidden')) {
            // 打开面板
            await loadStickerPanelTabs();
            panel.classList.remove('hidden');
        } else {
            // 关闭面板
            panel.classList.add('hidden');
        }
    });
}

// 2. 搜索框 - 实时搜索
const stickerSearchInput = document.querySelector('#sticker-search-input');
if (stickerSearchInput) {
    stickerSearchInput.addEventListener('input', () => {
        clearTimeout(stickerSearchTimeout);
        
        stickerSearchTimeout = setTimeout(async () => {
            const query = stickerSearchInput.value.trim();
            if (currentActiveStickerTab) {
                await loadStickerPanelContent(currentActiveStickerTab, query);
            }
        }, 300);
    });
}

// 监听回车键发送用户消息
chatInputBox.addEventListener('keypress', async (e) => {
    if (e.key === 'Enter') {
        const text = chatInputBox.value.trim();
        if (!text || !currentOpenContactId) return;
        
        // 保存用户消息
        const userMessage = { 
            contactId: currentOpenContactId, 
            sender: 'user', 
            text: text, 
            timestamp: new Date() 
        };
        await db.chatMessages.add(userMessage);
        
        // 显示在界面上
        addMessageToUI('user', text);
        chatInputBox.value = '';
        renderContactList();
    }
});

// 消息编辑弹窗 - 取消按钮
const messageEditCancelBtn = document.querySelector('#message-edit-cancel-btn');
if (messageEditCancelBtn) {
    messageEditCancelBtn.addEventListener('click', closeMessageEditPopup);
} else {
    console.error('找不到 #message-edit-cancel-btn');
}

// 消息编辑弹窗 - 关闭按钮
const messageEditCloseBtn = document.querySelector('#message-edit-close-btn');
if (messageEditCloseBtn) {
    messageEditCloseBtn.addEventListener('click', closeMessageEditPopup);
} else {
    console.error('找不到 #message-edit-close-btn');
}

// 消息编辑弹窗 - 点击背景关闭
const messageEditPopup = document.querySelector('#message-edit-popup');
if (messageEditPopup) {
    messageEditPopup.addEventListener('click', (e) => {
        if (e.target === messageEditPopup) closeMessageEditPopup();
    });
} else {
    console.error('找不到 #message-edit-popup');
}

// 消息编辑弹窗 - 保存按钮
const messageEditSaveBtn = document.querySelector('#message-edit-save-btn');
if (messageEditSaveBtn) {
    messageEditSaveBtn.addEventListener('click', async () => {
        if (!currentEditingMessageId) {
            alert('错误：没有正在编辑的消息！');
            return;
        }
        
        const newText = document.querySelector('#message-edit-textarea').value.trim();
        
        if (!newText) {
            alert('消息内容不能为空！');
            return;
        }
        
        try {
            // 更新数据库
            await db.chatMessages.update(currentEditingMessageId, { text: newText });
            
            // 更新UI
            const messageEl = messageContainer.querySelector(`[data-message-id="${currentEditingMessageId}"]`);
            if (messageEl) {
                messageEl.textContent = newText;
            }
            
            alert('修改成功！');
            closeMessageEditPopup();
            
        } catch (error) {
            console.error('保存失败:', error);
            alert('保存失败，请重试。');
        }
    });
} else {
    console.error('找不到 #message-edit-save-btn');
}
// ======================================================
// 【新功能】字体设置 - 只保留默认和自定义
// ======================================================

// 1. 手风琴展开/折叠
const fontAccordionHeader = document.querySelector('#font-accordion-header');
const fontAccordionContent = document.querySelector('#font-accordion-content');

fontAccordionHeader.addEventListener('click', async () => {
    fontAccordionHeader.classList.toggle('expanded');
    fontAccordionContent.classList.toggle('expanded');
    
    // 展开时加载预设列表
    if (fontAccordionContent.classList.contains('expanded')) {
        await loadFontPresets();
    }
});

// 2. 滑块实时更新
document.querySelector('#global-font-size').addEventListener('input', (e) => {
    const value = e.target.value;
    document.querySelector('#global-font-size-value').textContent = value + 'px';
    document.querySelector('#global-font-preview').style.fontSize = value + 'px';
});

document.querySelector('#chat-font-size').addEventListener('input', (e) => {
    const value = e.target.value;
    document.querySelector('#chat-font-size-value').textContent = value + 'px';
    document.querySelector('#chat-font-preview').style.fontSize = value + 'px';
});

// 3. 加载字体预设列表
async function loadFontPresets() {
    const select = document.querySelector('#font-preset-select');
    select.innerHTML = `
        <option value="default">默认</option>
        <option value="custom">--- 新建自定义预设 ---</option>
    `;
    
    // 从数据库加载用户保存的预设
    const savedPresets = await db.settings.get('fontPresets');
    if (savedPresets && savedPresets.value && savedPresets.value.length > 0) {
        savedPresets.value.forEach(preset => {
            const option = document.createElement('option');
            option.value = 'saved_' + preset.id;
            option.textContent = preset.name + ' ⭐';
            select.appendChild(option);
        });
    }
    
    // 恢复上次选择的预设
    const lastPreset = await db.settings.get('activeFontPreset');
    if (lastPreset) {
        select.value = lastPreset.value;
        // 触发一次change事件来应用字体
        await applyFontPreset(lastPreset.value);
    }
}

// 4. 应用字体预设
async function applyFontPreset(presetValue) {
    const globalUrl = document.querySelector('#global-font-url');
    const globalName = document.querySelector('#global-font-name');
    const globalSize = document.querySelector('#global-font-size');
    const chatUrl = document.querySelector('#chat-font-url');
    const chatName = document.querySelector('#chat-font-name');
    const chatSize = document.querySelector('#chat-font-size');
    
    if (presetValue === 'default') {
        // 默认字体
        globalUrl.value = '';
        globalName.value = 'sans-serif';
        globalSize.value = 16;
        chatUrl.value = '';
        chatName.value = '';
        chatSize.value = 16;
        
    } else if (presetValue.startsWith('saved_')) {
        // 用户保存的自定义预设
        const presetId = presetValue.replace('saved_', '');
        const savedPresets = await db.settings.get('fontPresets');
        const preset = savedPresets.value.find(p => p.id === presetId);
        
        if (preset) {
            globalUrl.value = preset.globalUrl || '';
            globalName.value = preset.globalName || 'sans-serif';
            globalSize.value = preset.globalSize || 16;
            chatUrl.value = preset.chatUrl || '';
            chatName.value = preset.chatName || '';
            chatSize.value = preset.chatSize || 16;
        }
    } else if (presetValue === 'custom') {
        // 新建自定义（清空表单）
        globalUrl.value = '';
        globalName.value = '';
        globalSize.value = 16;
        chatUrl.value = '';
        chatName.value = '';
        chatSize.value = 16;
    }
    
    // 更新滑块显示和预览
    document.querySelector('#global-font-size-value').textContent = globalSize.value + 'px';
    document.querySelector('#chat-font-size-value').textContent = chatSize.value + 'px';
    document.querySelector('#global-font-preview').style.fontSize = globalSize.value + 'px';
    document.querySelector('#chat-font-preview').style.fontSize = chatSize.value + 'px';
    
    // 应用字体
    applyFontsToPage();
}

// 5. 字体预设切换
document.querySelector('#font-preset-select').addEventListener('change', async (e) => {
    await applyFontPreset(e.target.value);
});

// 6. 保存字体设置按钮
document.querySelector('#font-save-btn').addEventListener('click', async () => {
    const presetSelect = document.querySelector('#font-preset-select');
    const currentPreset = presetSelect.value;
    
    const fontData = {
        globalUrl: document.querySelector('#global-font-url').value,
        globalName: document.querySelector('#global-font-name').value,
        globalSize: document.querySelector('#global-font-size').value,
        chatUrl: document.querySelector('#chat-font-url').value,
        chatName: document.querySelector('#chat-font-name').value,
        chatSize: document.querySelector('#chat-font-size').value
    };
    
    // 如果是"新建自定义"，需要保存为新预设
    if (currentPreset === 'custom') {
        const presetName = prompt('请为这个字体方案起个名字：', '我的字体方案');
        if (!presetName) return;
        
        // 生成唯一ID
        const presetId = 'preset_' + Date.now();
        
        // 获取现有预设
        const savedPresets = await db.settings.get('fontPresets');
        const presets = savedPresets ? savedPresets.value : [];
        
        // 添加新预设
        presets.push({
            id: presetId,
            name: presetName,
            ...fontData
        });
        
        // 保存到数据库
        await db.settings.put({ key: 'fontPresets', value: presets });
        await db.settings.put({ key: 'activeFontPreset', value: 'saved_' + presetId });
        
        alert('字体方案已保存！');
        await loadFontPresets();
        
    } else if (currentPreset.startsWith('saved_')) {
        // 更新已有的自定义预设
        const presetId = currentPreset.replace('saved_', '');
        const savedPresets = await db.settings.get('fontPresets');
        const presets = savedPresets.value;
        
        const index = presets.findIndex(p => p.id === presetId);
        if (index !== -1) {
            presets[index] = {
                ...presets[index],
                ...fontData
            };
            
            await db.settings.put({ key: 'fontPresets', value: presets });
            await db.settings.put({ key: 'activeFontPreset', value: currentPreset });
            alert('字体方案已更新！');
        }
        
    } else {
        // 默认预设，直接保存为激活状态
        await db.settings.put({ key: 'activeFontPreset', value: currentPreset });
        alert('字体设置已保存！');
    }
    
    // 应用字体
    applyFontsToPage();
});

// 7. 恢复默认按钮
document.querySelector('#font-reset-btn').addEventListener('click', async () => {
    const presetSelect = document.querySelector('#font-preset-select');
    const currentPreset = presetSelect.value;
    
    // 如果是自定义预设，提供删除选项
    if (currentPreset.startsWith('saved_')) {
        const choice = confirm('要删除这个自定义方案吗？\n点"确定"删除，点"取消"只重置当前设置');
        
        if (choice) {
            // 删除这个预设
            const presetId = currentPreset.replace('saved_', '');
            const savedPresets = await db.settings.get('fontPresets');
            const presets = savedPresets.value.filter(p => p.id !== presetId);
            
            await db.settings.put({ key: 'fontPresets', value: presets });
            await db.settings.put({ key: 'activeFontPreset', value: 'default' });
            
            alert('已删除该方案！');
            await loadFontPresets();
            await applyFontPreset('default');
            return;
        }
    }
    
    // 恢复默认
    await db.settings.put({ key: 'activeFontPreset', value: 'default' });
    await applyFontPreset('default');
    applyFontsToPage();
    
    alert('已恢复默认字体！');
});

// 8. 应用字体到页面
function applyFontsToPage() {
    const globalName = document.querySelector('#global-font-name').value || 'sans-serif';
    const globalSize = document.querySelector('#global-font-size').value || '16';
    const chatName = document.querySelector('#chat-font-name').value || globalName;
    const chatSize = document.querySelector('#chat-font-size').value || globalSize;
    
    // 应用全局字体
    document.body.style.fontFamily = globalName;
    document.body.style.fontSize = globalSize + 'px';
    
    // 应用聊天字体
    const messageContainer = document.querySelector('.message-container');
    if (messageContainer) {
        messageContainer.style.fontFamily = chatName;
        messageContainer.style.fontSize = chatSize + 'px';
    }
    
    // 更新预览
    const globalPreview = document.querySelector('#global-font-preview');
    const chatPreview = document.querySelector('#chat-font-preview');
    
    if (globalPreview) {
        globalPreview.style.fontFamily = globalName;
        globalPreview.style.fontSize = globalSize + 'px';
    }
    
    if (chatPreview) {
        chatPreview.style.fontFamily = chatName || globalName;
        chatPreview.style.fontSize = chatSize + 'px';
    }
}

// 9. 页面加载时应用保存的字体
(async () => {
    const lastPreset = await db.settings.get('activeFontPreset');
    if (lastPreset) {
        await applyFontPreset(lastPreset.value);
    }
})();

// "是否显示头像"开关
contactSettingsAvatarToggle.addEventListener('click', () => {
    contactSettingsAvatarToggle.classList.toggle('active');
});

// ======================================================
// 【新功能】撤回AI最新回复并重新生成
// ======================================================
const retractBtn = document.querySelector('#retract-btn');
if (retractBtn) {
    retractBtn.addEventListener('click', async () => {
        if (!currentOpenContactId) {
            alert('请先打开一个对话！');
            return;
        }
        
        // 1. 获取最新的消息
        const messages = await db.chatMessages
            .where('contactId').equals(currentOpenContactId)
            .reverse()
            .toArray();
        
        if (messages.length === 0) {
            alert('当前没有消息可以撤回！');
            return;
        }
        
        // 2. 找到最新的AI回复
        let lastBotMessageIndex = -1;
        for (let i = 0; i < messages.length; i++) {
            if (messages[i].sender === 'bot') {
                lastBotMessageIndex = i;
                break; // 找到第一个（也就是最新的）就停止
            }
        }
        
        if (lastBotMessageIndex === -1) {
            alert('没有找到AI的回复可以撤回！');
            return;
        }
        
        // 3. 确认撤回
        if (!confirm('确定要撤回AI的最新回复吗？\n撤回后会立即重新生成回复。')) {
            return;
        }
        
        // 4. 删除最新的AI回复（可能是多条消息）
        const lastBotMessage = messages[lastBotMessageIndex];
        const lastBotTimestamp = lastBotMessage.timestamp;
        
        // 找出所有和这条消息同一时间生成的AI消息（因为AI可能一次回复多条）
        const messagesToDelete = messages.filter(msg => 
            msg.sender === 'bot' && 
            Math.abs(new Date(msg.timestamp) - new Date(lastBotTimestamp)) < 5000 // 5秒内的算同一批
        );
        
        // 5. 从数据库删除
        for (const msg of messagesToDelete) {
            await db.chatMessages.delete(msg.id);
        }
        
    // 6. 【修复】从UI中移除消息（兼容有头像和无头像两种情况）
const allBubbles = Array.from(messageContainer.querySelectorAll('.message-bubble'));
let deletedCount = 0;

// 从后往前遍历（避免删除时索引变化）
for (let i = allBubbles.length - 1; i >= 0 && deletedCount < messagesToDelete.length; i--) {
    const bubble = allBubbles[i];
    
    // 只删除AI的消息
    if (bubble.classList.contains('bot-message')) {
        // 检查是否有头像容器（messageWrapper）
        const wrapper = bubble.closest('div[style*="display: flex"]');
        
        if (wrapper && wrapper !== messageContainer) {
            // 有头像：删除整个wrapper
            wrapper.remove();
        } else {
            // 没有头像：直接删除气泡
            bubble.remove();
        }
        
        deletedCount++;
    }
}

        
        // 7. 显示"正在重新生成..."
        addMessageToUI('bot', '...');
        
        // 8. 重新调用AI生成回复
        const processingId = Date.now();
        try {
            await processAiReply(currentOpenContactId, processingId);
        } catch (error) {
            console.error('重新生成失败:', error);
            // 移除"正在思考"
            const typingBubble = messageContainer.querySelector('.message-bubble:last-child');
            if (typingBubble && typingBubble.textContent === '...') {
                typingBubble.remove();
            }
            addMessageToUI('bot', '（重新生成失败，请点击"接收"按钮手动重试）');
        }
        
        // 9. 刷新联系人列表
        renderContactList();
    });
}
// ======================================================
// 【新功能】情侣头像功能
// ======================================================


// 1. 点击"启用情侣头像"开关
contactSettingsCoupleAvatarToggle.addEventListener('click', async () => {
    // 【关键修复】先检查是否有当前联系人
    if (!currentOpenContactId) {
        alert('请先打开一个联系人的设置页面！');
        return;
    }
    
    // 切换开关状态
    const willBeActive = !contactSettingsCoupleAvatarToggle.classList.contains('active');
    
    if (willBeActive) {
        // 【新增】如果要开启情侣头像，先检查"显示头像"开关
        if (!contactSettingsAvatarToggle.classList.contains('active')) {
            // 如果"显示头像"是关闭的，给出提示并自动打开
            if (confirm('使用情侣头像需要先开启"是否显示头像"功能。\n是否自动开启？')) {
                contactSettingsAvatarToggle.classList.add('active');
            } else {
                // 用户拒绝，就不打开弹窗
                return;
            }
        }
        
        // 开启时，立即打开弹窗
        contactSettingsCoupleAvatarToggle.classList.add('active');
        await openCoupleAvatarPopup();
    } else {
        // 关闭时，直接关闭（不需要弹窗）
        contactSettingsCoupleAvatarToggle.classList.remove('active');
      
        // 同时保存关闭状态
        await db.contacts.update(currentOpenContactId, {
            coupleAvatarEnabled: false
        });
    }
});

// 2. 打开情侣头像弹窗
async function openCoupleAvatarPopup() {
    if (!currentOpenContactId) {
        alert('错误：没有当前联系人！');
        return;
    }
    
    const contact = await db.contacts.get(currentOpenContactId);
    if (!contact) {
        alert('错误：找不到联系人数据！');
        return;
    }
    
    // 加载已保存的头像（如果有）
    coupleUserAvatarPreview.src = './assets/default-avatar.png';
    coupleBotAvatarPreview.src = './assets/default-avatar.png';
    
    if (contact.coupleUserAvatarFileKey) {
        const userFile = await db.files.get(contact.coupleUserAvatarFileKey);
        if (userFile) {
            coupleUserAvatarPreview.src = URL.createObjectURL(userFile.file);
        }
    }
    
    if (contact.coupleBotAvatarFileKey) {
        const botFile = await db.files.get(contact.coupleBotAvatarFileKey);
        if (botFile) {
            coupleBotAvatarPreview.src = URL.createObjectURL(botFile.file);
        }
    }
    
    // 清空文件选择器
    coupleUserAvatarInput.value = '';
    coupleBotAvatarInput.value = '';
    
    // 【关键修复】把弹窗移到body下，并强制设置样式
    document.body.appendChild(coupleAvatarPopup);
    coupleAvatarPopup.style.position = 'fixed';
    coupleAvatarPopup.style.top = '0';
    coupleAvatarPopup.style.left = '0';
    coupleAvatarPopup.style.width = '100vw';
    coupleAvatarPopup.style.height = '100vh';
    coupleAvatarPopup.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    coupleAvatarPopup.style.display = 'flex';
    coupleAvatarPopup.style.justifyContent = 'center';
    coupleAvatarPopup.style.alignItems = 'center';
    coupleAvatarPopup.style.zIndex = '999999';
    
    // 确保内容框也正确显示
    const content = coupleAvatarPopup.querySelector('.popup-content');
    if (content) {
        content.style.backgroundColor = '#ffffff';
        content.style.padding = '20px 25px';
        content.style.borderRadius = '25px';
    }
    
    // 移除hidden类
    coupleAvatarPopup.classList.remove('hidden');
}


// 3. 用户头像预览
coupleUserAvatarInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            coupleUserAvatarPreview.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    }
});

// 4. AI头像预览
coupleBotAvatarInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (ev) => {
            coupleBotAvatarPreview.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    }
});

// 5. 保存情侣头像
coupleAvatarSaveBtn.addEventListener('click', async () => {
    if (!currentOpenContactId) return;
    
    const contact = await db.contacts.get(currentOpenContactId);
    if (!contact) {
        alert('错误：找不到联系人数据！');
        return;
    }
    
    const userFile = coupleUserAvatarInput.files[0];
    const botFile = coupleBotAvatarInput.files[0];
    
    // 【关键修复】如果用户没有重新上传文件，就使用之前保存的
    let userFileKey = contact.coupleUserAvatarFileKey;
    let botFileKey = contact.coupleBotAvatarFileKey;
    
    // 如果用户上传了新的用户头像
    if (userFile) {
        userFileKey = `couple_user_${Date.now()}`;
        await db.files.put({ key: userFileKey, file: userFile });
    }
    
    // 如果用户上传了新的AI头像
    if (botFile) {
        botFileKey = `couple_bot_${Date.now()}`;
        await db.files.put({ key: botFileKey, file: botFile });
    }
    
    // 【关键】检查是否至少有一个头像（新的或旧的）
    if (!userFileKey || !botFileKey) {
        alert('请至少上传双方的头像一次！');
        return;
    }
    
    try {
        // 更新数据库
        await db.contacts.update(currentOpenContactId, {
            coupleUserAvatarFileKey: userFileKey,
            coupleBotAvatarFileKey: botFileKey,
            coupleAvatarEnabled: true
        });
        
        alert('情侣头像已保存！');
        coupleAvatarPopup.classList.add('hidden');
        
    } catch (error) {
        console.error('保存失败:', error);
        alert('保存失败，请重试！');
    }
});


// 6. 取消/关闭按钮（点击取消时，也要关闭开关）
coupleAvatarCancelBtn.addEventListener('click', () => {
    coupleAvatarPopup.classList.add('hidden');
    
    // 【关键】如果用户点了取消，就把开关也关掉
    contactSettingsCoupleAvatarToggle.classList.remove('active');
});


coupleAvatarCloseBtn.addEventListener('click', () => {
    coupleAvatarPopup.classList.add('hidden');
    
    // 【关键】如果用户点了关闭，就把开关也关掉
    contactSettingsCoupleAvatarToggle.classList.remove('active');
});


coupleAvatarPopup.addEventListener('click', (e) => {
    if (e.target === coupleAvatarPopup) {
        coupleAvatarPopup.classList.add('hidden');
        
        // 【关键】如果用户点了背景关闭，就把开关也关掉
        contactSettingsCoupleAvatarToggle.classList.remove('active');
    }
});
// ======================================================
// 【新功能】数据设置功能
// ======================================================

// 1. 手风琴展开/折叠
const dataAccordionHeader = document.querySelector('#data-accordion-header');
const dataAccordionContent = document.querySelector('#data-accordion-content');

dataAccordionHeader.addEventListener('click', async () => {
    dataAccordionHeader.classList.toggle('expanded');
    dataAccordionContent.classList.toggle('expanded');
    
    // 展开时自动刷新统计
    if (dataAccordionContent.classList.contains('expanded')) {
        await refreshDataStats();
    }
});

// 2. 刷新数据统计
async function refreshDataStats() {
    try {
        // 统计联系人数量
        const contactsCount = await db.contacts.count();
        document.querySelector('#stat-contacts-count').textContent = contactsCount;
        
        // 统计聊天消息数
        const messagesCount = await db.chatMessages.count();
        document.querySelector('#stat-messages-count').textContent = messagesCount;
        
        // 统计世界书条目
        const worldbookCount = await db.worldbook_entries.count();
        document.querySelector('#stat-worldbook-count').textContent = worldbookCount;
        
        // 预估 Token 数（粗略计算：中文1字≈2token，英文1词≈1.3token）
        let totalTokens = 0;
        
        // 联系人人设
        const contacts = await db.contacts.toArray();
        contacts.forEach(c => {
            if (c.persona) totalTokens += Math.ceil(c.persona.length * 2);
            if (c.aiSummaryText) totalTokens += Math.ceil(c.aiSummaryText.length * 2);
        });
        
        // 聊天消息
        const messages = await db.chatMessages.toArray();
        messages.forEach(m => {
            if (m.text) totalTokens += Math.ceil(m.text.length * 2);
        });
        
        // 世界书
        const entries = await db.worldbook_entries.toArray();
        entries.forEach(e => {
            if (e.content) totalTokens += Math.ceil(e.content.length * 2);
        });
        
        document.querySelector('#stat-token-count').textContent = totalTokens.toLocaleString() + ' (约)';
        
    } catch (error) {
        console.error('统计失败:', error);
        alert('统计失败，请查看控制台');
    }
}

// 3. 刷新统计按钮
document.querySelector('#refresh-stats-btn').addEventListener('click', refreshDataStats);

// 4. 备份数据
document.querySelector('#backup-data-btn').addEventListener('click', async () => {
    try {
        // 确认备份
        if (!confirm('确定要备份所有数据吗？\n备份文件将保存到您的下载文件夹。')) {
            return;
        }
        
        const backupBtn = document.querySelector('#backup-data-btn');
        backupBtn.disabled = true;
        backupBtn.textContent = '正在备份...';
        
        // 导出所有表的数据
        const backupData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            data: {
                settings: await db.settings.toArray(),
                files: await db.files.toArray(),
                contacts: await db.contacts.toArray(),
                chatMessages: await db.chatMessages.toArray(),
                apiPresets: await db.apiPresets.toArray(),
                worldbook_categories: await db.worldbook_categories.toArray(),
                worldbook_entries: await db.worldbook_entries.toArray(),
                contact_worldbook_links: await db.contact_worldbook_links.toArray(),
                my_persona_presets: await db.my_persona_presets.toArray(),
                sticker_libraries: await db.sticker_libraries.toArray(),
                stickers: await db.stickers.toArray(),
                user_sticker_selection: await db.user_sticker_selection.toArray(),
                role_sticker_selection: await db.role_sticker_selection.toArray()
            }
        };
        
        // 转换为 JSON
        const jsonString = JSON.stringify(backupData, null, 2);
        
        // 创建下载链接
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `AI小手机备份_${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert('备份成功！文件已下载到您的设备。');
        
    } catch (error) {
        console.error('备份失败:', error);
        alert('备份失败：' + error.message);
    } finally {
        const backupBtn = document.querySelector('#backup-data-btn');
        backupBtn.disabled = false;
        backupBtn.textContent = '📥 备份所有数据';
    }
});

// 5. 恢复数据
document.querySelector('#restore-data-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    // 严格确认
    if (!confirm('⚠️ 警告！恢复数据会完全覆盖当前所有数据！\n\n确定要继续吗？')) {
        e.target.value = '';
        return;
    }
    
    if (!confirm('最后确认：真的要恢复备份吗？\n这个操作无法撤销！')) {
        e.target.value = '';
        return;
    }
    
    try {
        const reader = new FileReader();
        reader.onload = async (ev) => {
            try {
                const backupData = JSON.parse(ev.target.result);
                
                // 验证备份文件
                if (!backupData.version || !backupData.data) {
                    throw new Error('无效的备份文件格式');
                }
                
                // 清空所有表
                await db.settings.clear();
                await db.files.clear();
                await db.contacts.clear();
                await db.chatMessages.clear();
                await db.apiPresets.clear();
                await db.worldbook_categories.clear();
                await db.worldbook_entries.clear();
                await db.contact_worldbook_links.clear();
                await db.my_persona_presets.clear();
                await db.sticker_libraries.clear();
                await db.stickers.clear();
                await db.user_sticker_selection.clear();
                await db.role_sticker_selection.clear();
                
                // 恢复数据
                if (backupData.data.settings) await db.settings.bulkAdd(backupData.data.settings);
                if (backupData.data.files) await db.files.bulkAdd(backupData.data.files);
                if (backupData.data.contacts) await db.contacts.bulkAdd(backupData.data.contacts);
                if (backupData.data.chatMessages) await db.chatMessages.bulkAdd(backupData.data.chatMessages);
                if (backupData.data.apiPresets) await db.apiPresets.bulkAdd(backupData.data.apiPresets);
                if (backupData.data.worldbook_categories) await db.worldbook_categories.bulkAdd(backupData.data.worldbook_categories);
                if (backupData.data.worldbook_entries) await db.worldbook_entries.bulkAdd(backupData.data.worldbook_entries);
                if (backupData.data.contact_worldbook_links) await db.contact_worldbook_links.bulkAdd(backupData.data.contact_worldbook_links);
                if (backupData.data.my_persona_presets) await db.my_persona_presets.bulkAdd(backupData.data.my_persona_presets);
                if (backupData.data.sticker_libraries) await db.sticker_libraries.bulkAdd(backupData.data.sticker_libraries);
                if (backupData.data.stickers) await db.stickers.bulkAdd(backupData.data.stickers);
                if (backupData.data.user_sticker_selection) await db.user_sticker_selection.bulkAdd(backupData.data.user_sticker_selection);
                if (backupData.data.role_sticker_selection) await db.role_sticker_selection.bulkAdd(backupData.data.role_sticker_selection);
                
                alert('数据恢复成功！\n页面将自动刷新以加载新数据。');
                location.reload();
                
            } catch (error) {
                console.error('恢复失败:', error);
                alert('恢复失败：' + error.message);
            }
        };
        reader.readAsText(file);
        
    } catch (error) {
        console.error('读取文件失败:', error);
        alert('读取文件失败：' + error.message);
    } finally {
        e.target.value = '';
    }
});

// ======================================================
// 【新功能】多选删除消息模式
// ======================================================

let isBatchDeleteMode = false; // 是否处于多选删除模式
let selectedMessageIds = new Set(); // 存储被选中的消息ID

// 1. 点击标题栏进入/退出多选模式
const chatWindowTitle = document.querySelector('#chat-window-title');
const batchDeleteBtn = document.querySelector('#batch-delete-btn');

// 保存原始标题
let originalChatTitle = '';

chatWindowTitle.addEventListener('click', async () => {
    if (!currentOpenContactId) return;
    
    // 切换模式
    isBatchDeleteMode = !isBatchDeleteMode;
    
    if (isBatchDeleteMode) {
        // 【修改】进入多选模式 - 保存原标题并改成删除提示
        originalChatTitle = chatWindowTitle.textContent;
        chatWindowTitle.textContent = '删除中，再次点击退出';
        batchDeleteBtn.style.display = 'block';
        selectedMessageIds.clear(); // 清空之前的选择
        
        // 移除所有消息的选中样式
        messageContainer.querySelectorAll('.message-bubble').forEach(bubble => {
            bubble.classList.remove('selected');
        });
        
    } else {
        // 【修改】退出多选模式 - 恢复原标题
        chatWindowTitle.textContent = originalChatTitle;
        batchDeleteBtn.style.display = 'none';
        selectedMessageIds.clear();
        
        // 移除所有消息的选中样式
        messageContainer.querySelectorAll('.message-bubble').forEach(bubble => {
            bubble.classList.remove('selected');
        });
    }
});


// 2. 点击消息进行选中/取消选中
messageContainer.addEventListener('click', (e) => {
    // 只有在多选模式下才响应
    if (!isBatchDeleteMode) return;
    
    // 找到被点击的消息气泡
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return;
    
    const messageId = parseInt(bubble.dataset.messageId);
    if (!messageId) return;
    
    // 切换选中状态
    if (selectedMessageIds.has(messageId)) {
        // 取消选中
        selectedMessageIds.delete(messageId);
        bubble.classList.remove('selected');
    } else {
        // 选中
        selectedMessageIds.add(messageId);
        bubble.classList.add('selected');
    }
    
    // 更新删除按钮文字
    if (selectedMessageIds.size > 0) {
        batchDeleteBtn.textContent = `删除 (${selectedMessageIds.size})`;
    } else {
        batchDeleteBtn.textContent = '删除';
    }
});

// 3. 点击删除按钮

batchDeleteBtn.addEventListener('click', async () => {
    if (selectedMessageIds.size === 0) {
        alert('请先选择要删除的消息！');
        return;
    }
    
    if (!confirm(`确定要删除选中的 ${selectedMessageIds.size} 条消息吗？`)) {
        return;
    }
    
    try {
        // 从数据库删除
        for (const messageId of selectedMessageIds) {
            await db.chatMessages.delete(messageId);
        }
        
        // 从UI中移除
        messageContainer.querySelectorAll('.message-bubble').forEach(bubble => {
            const messageId = parseInt(bubble.dataset.messageId);
            if (selectedMessageIds.has(messageId)) {
                // 检查是否有头像容器
                const wrapper = bubble.closest('div[style*="display: flex"]');
                if (wrapper && wrapper !== messageContainer) {
                    wrapper.remove();
                } else {
                    bubble.remove();
                }
            }
        });
        
        // 清空选择
        selectedMessageIds.clear();
        
        // 【修改】退出多选模式并恢复标题
        isBatchDeleteMode = false;
        chatWindowTitle.textContent = originalChatTitle;
        batchDeleteBtn.style.display = 'none';
        batchDeleteBtn.textContent = '删除'; 
        
        alert('删除成功！');
        renderContactList();
        
    } catch (error) {
        console.error('删除失败:', error);
        alert('删除失败，请重试！');
    }
});
// ======================================================
// 【新增】朋友圈功能 - 底部标签栏切换
// ======================================================

// 1. 只抓取新增的元素（不重复声明已有变量）
const tabContacts = document.querySelector('#tab-contacts');
const tabContacts2 = document.querySelector('#tab-contacts-2');
const tabMoments = document.querySelector('#tab-moments');
const tabMoments2 = document.querySelector('#tab-moments-2');
const momentsScreen = document.querySelector('.moments-screen');
const momentsSettingsBtn = document.querySelector('#moments-settings-btn');
const momentsAddBtn = document.querySelector('#moments-add-btn');

// 2. 添加安全检查（如果元素不存在就不执行）
if (tabContacts && tabContacts2 && tabMoments && tabMoments2 && momentsScreen) {
    
    // 3. 切换到联系人页面
    function switchToContacts() {
        dialogueListScreen.classList.remove('hidden');
        momentsScreen.classList.add('hidden');
    }

    // 4. 切换到朋友圈页面
    function switchToMoments() {
        dialogueListScreen.classList.add('hidden');
        momentsScreen.classList.remove('hidden');
    }

    // 5. 绑定事件监听器
    tabContacts.addEventListener('click', switchToContacts);
    tabContacts2.addEventListener('click', switchToContacts);
    tabMoments.addEventListener('click', switchToMoments);
    tabMoments2.addEventListener('click', switchToMoments);


   // 7. 发布动态按钮 - 【修复版】
    // 先在外面定义所有元素和函数
    const publishOverlay = document.querySelector('#publish-moment-overlay');
    const publishCancelBtn = document.querySelector('#publish-cancel-btn');
    const publishSubmitBtn = document.querySelector('#publish-submit-btn');
    const publishTextarea = document.querySelector('#publish-textarea');
    const publishHashtagInput = document.querySelector('#publish-hashtag-input');
    const publishLocationInput = document.querySelector('#publish-location-input');
    const publishImageInput = document.querySelector('#publish-image-input');
    const publishImagesPreview = document.querySelector('#publish-images-preview');
    const imageCountHint = document.querySelector('#image-count-hint');

    let selectedImages = [];

    // 更新图片数量提示
    function updateImageCountHint() {
        if (!imageCountHint) return;
        const count = selectedImages.length;
        imageCountHint.textContent = count === 0 ? '最多9张' : `已选 ${count}/9 张`;
    }

    // 渲染图片预览
    function renderImagePreview() {
        if (!publishImagesPreview) return;
        publishImagesPreview.innerHTML = '';
        
        selectedImages.forEach((imgSrc, index) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'preview-image-wrapper';
            
            wrapper.innerHTML = `
                <img src="${imgSrc}" alt="预览${index + 1}" class="preview-image">
                <button class="remove-image-btn" data-index="${index}">×</button>
            `;
            
            publishImagesPreview.appendChild(wrapper);
        });
        
        document.querySelectorAll('.remove-image-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const index = parseInt(btn.dataset.index);
                selectedImages.splice(index, 1);
                renderImagePreview();
                updateImageCountHint();
            });
        });
    }

    // 打开发布弹窗
    if (momentsAddBtn) {
        momentsAddBtn.addEventListener('click', () => {
            if (!publishOverlay) return;
            publishOverlay.classList.remove('hidden');
            publishTextarea.value = '';
            publishHashtagInput.value = '';
            publishLocationInput.value = '';
            selectedImages = [];
            publishImagesPreview.innerHTML = '';
            updateImageCountHint();
        });
    }

    // 关闭发布弹窗
    if (publishCancelBtn) {
        publishCancelBtn.addEventListener('click', () => {
            publishOverlay.classList.add('hidden');
        });
    }

    // 点击遮罩层也关闭
    if (publishOverlay) {
        publishOverlay.addEventListener('click', (e) => {
            if (e.target === publishOverlay) {
                publishOverlay.classList.add('hidden');
            }
        });
    }

    // 选择图片
    if (publishImageInput) {
        publishImageInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            
            const remainingSlots = 9 - selectedImages.length;
            const filesToAdd = files.slice(0, remainingSlots);
            
            filesToAdd.forEach(file => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        selectedImages.push(event.target.result);
                        renderImagePreview();
                        updateImageCountHint();
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            e.target.value = '';
        });
    }

    // 发布动态
    if (publishSubmitBtn) {
  publishSubmitBtn.addEventListener('click', async () => {
        const content = publishTextarea.value.trim();
        
        // 【修改】根据模式检查内容
        if (!content && selectedImages.length === 0 && !document.querySelector('#publish-image-descriptions').value.trim()) {
            alert('请输入内容或添加图片！');
            return;
        }
        
        try {
            const hashtagsText = publishHashtagInput.value.trim();
            const hashtags = hashtagsText ? hashtagsText.split(/\s+/).filter(t => t) : [];
            const location = publishLocationInput.value.trim();
            
            // 【新增】根据当前模式决定使用哪种配图
            let images = [];
            let imageDescriptions = [];
            
            if (currentImageMode === 'real') {
                // 真实图片模式
                images = selectedImages;
            } else {
                // 文字描述模式
                const descText = document.querySelector('#publish-image-descriptions').value.trim();
                if (descText) {
                    imageDescriptions = descText.split('\n').filter(line => line.trim());
                }
            }
            
           const newMomentId = await db.moments.add({
    contactId: 0,
    contactName: null,
    contactAvatarKey: null,
    content: content,
    hashtags: hashtags,
    location: location || null,
    images: images,
    imageDescriptions: imageDescriptions,
    timestamp: new Date(),
    likes: [],
    likeCount: 0,
    commentCount: 0,
             comments: []
});

await renderMomentsList();
publishOverlay.classList.add('hidden');
alert('发布成功!');

// 【修复】触发角色自动点赞
await autoLikeByContacts(newMomentId);
        } catch (error) {
            console.error('发布失败:', error); // ← 关键：查看具体错误
        alert('发布失败：' + error.message); // ← 显示错误信息
        }
    });
}
    
} else {
    console.error('朋友圈功能初始化失败：找不到必要的HTML元素');
}
// ======================================================
// 【新增】用户主页功能
// ======================================================

// 1. 打开用户主页
async function openUserProfile() {
     const userProfileScreen = document.querySelector('.user-profile-screen');
 // 【新增】加载用户资料
    const profile = await db.settings.get('myMomentsProfile');
    if (profile && profile.value) {
        // 更新头像
        if (profile.value.avatarFileKey) {
            const avatarFile = await db.files.get(profile.value.avatarFileKey);
            if (avatarFile) {
                document.querySelector('#profile-avatar-img').src = URL.createObjectURL(avatarFile.file);
            }
        }
        
        // 更新昵称
        document.querySelector('.profile-nickname').textContent = profile.value.nickname || '我';
        
        // 更新签名
        document.querySelector('.profile-signature').textContent = profile.value.signature || '';
        
        // 更新背景墙
        if (profile.value.backgroundFileKey) {
            const coverFile = await db.files.get(profile.value.backgroundFileKey);
            if (coverFile) {
                document.querySelector('.profile-cover').style.backgroundImage = `url('${URL.createObjectURL(coverFile.file)}')`;
            }
        }
    }
  
    // 【强力修复】确保元素在 body 下
    if (userProfileScreen.parentElement !== document.body) {
        document.body.appendChild(userProfileScreen);
    }
    
    // 【强力修复】强制设置样式
    userProfileScreen.style.position = 'fixed';
    userProfileScreen.style.top = '0';
    userProfileScreen.style.left = '0';
    userProfileScreen.style.width = '100vw';
    userProfileScreen.style.height = '100vh';
    userProfileScreen.style.zIndex = '999999';
    userProfileScreen.style.backgroundColor = '#f5f5f5';
    
    // 隐藏朋友圈
    momentsScreen.classList.add('hidden');
    
    // 显示用户主页
    userProfileScreen.classList.remove('hidden');
    
    // 加载数据
    await loadProfileStats();
    await renderProfileMomentsGrid();
}
// 2. 加载统计数据
async function loadProfileStats() {
    try {
        // 统计动态数量
        const momentsCount = await db.moments.count();
        document.querySelector('#profile-moments-count').textContent = momentsCount;
        
        // 统计总获赞数
        const moments = await db.moments.toArray();
        const totalLikes = moments.reduce((sum, m) => sum + (m.likeCount || 0), 0);
        document.querySelector('#profile-likes-count').textContent = totalLikes;
        
    } catch (error) {
        console.error('加载统计数据失败:', error);
    }
}

// 3. 渲染九宫格动态
async function renderProfileMomentsGrid() {
    const grid = document.querySelector('#profile-moments-grid');
    const moments = await db.moments.reverse().toArray();
    
    if (moments.length === 0) {
        grid.innerHTML = '<p class="empty-list-message">还没有发布动态哦~</p>';
        return;
    }
    
    grid.innerHTML = '';
    
    moments.forEach(moment => {
        // 创建完整的动态卡片（和朋友圈一样）
        const timeStr = formatMomentTime(moment.timestamp);
        const card = document.createElement('div');
        card.className = 'moment-card';
        card.dataset.momentId = moment.id;
        
        let contentHtml = moment.content;
        if (moment.hashtags && moment.hashtags.length > 0) {
            moment.hashtags.forEach(tag => {
                contentHtml += ` <a href="#" class="moment-hashtag">#${tag}</a>`;
            });
        }
        
        let imagesHtml = '';
        if (moment.images && moment.images.length > 0) {
            const count = moment.images.length;
            imagesHtml = `<div class="moment-images count-${count}">`;
            moment.images.forEach((img, index) => {
                imagesHtml += `<img src="${img}" alt="图片${index + 1}" class="moment-image">`;
            });
            imagesHtml += '</div>';
        }
        
        card.innerHTML = `
            <div class="moment-header">
                <img src="./assets/default-avatar.png" alt="头像" class="moment-avatar">
                <div class="moment-user-info">
                    <p class="moment-username">我</p>
                    <p class="moment-time">${timeStr}</p>
                </div>
            </div>
            
            <div class="moment-content-text">${contentHtml}</div>
            
            ${moment.location ? `
                <div class="moment-location">
                    <span class="moment-location-icon">📍</span>
                    <span>${moment.location}</span>
                </div>
            ` : ''}
            
            ${imagesHtml}
            
            <div class="moment-actions">
                <button class="moment-action-btn">
                    <span class="moment-action-icon">❤️</span>
                    <span>${moment.likeCount || 0}</span>
                </button>
                <button class="moment-action-btn">
                    <span class="moment-action-icon">💬</span>
                    <span>${moment.commentCount || 0}</span>
                </button>
                <button class="moment-action-btn">
                    <span class="moment-action-icon">📤</span>
                    <span>分享</span>
                </button>
            </div>
        `;
        
        grid.appendChild(card);
    });
}


// ======================================================
// 【强力修复】用户主页返回按钮
// ======================================================
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const userProfileBackBtn = document.querySelector('#user-profile-back-btn');
        
        if (!userProfileBackBtn) {
          //  console.error('找不到用户主页返回按钮！');
            return;
        }
        
       // console.log('用户主页返回按钮已找到');
        
        // 移除旧的事件监听器
        const newBtn = userProfileBackBtn.cloneNode(true);
        userProfileBackBtn.parentNode.replaceChild(newBtn, userProfileBackBtn);
        
        // 绑定新的点击事件
        newBtn.addEventListener('click', function(e) {
          //  console.log('用户主页返回按钮被点击了！');
            e.preventDefault();
            e.stopPropagation();
            
            try {
                const userProfileScreen = document.querySelector('.user-profile-screen');
                const momentsScreen = document.querySelector('.moments-screen');
                
                if (!userProfileScreen) {
                    alert('错误：找不到用户主页！');
                    return;
                }
                
                if (!momentsScreen) {
                    alert('错误：找不到朋友圈页面！');
                    return;
                }
                
                // 隐藏用户主页
                userProfileScreen.classList.add('hidden');
                userProfileScreen.style.display = 'none';
                
                // 显示朋友圈
                momentsScreen.classList.remove('hidden');
                momentsScreen.style.display = 'flex';
                
                // 确保朋友圈的样式正确
                momentsScreen.style.position = 'absolute';
                momentsScreen.style.top = '0';
                momentsScreen.style.left = '0';
                momentsScreen.style.width = '100%';
                momentsScreen.style.height = '100%';
                momentsScreen.style.zIndex = '210';
                
                console.log('已返回朋友圈！');
                
            } catch (error) {
                console.error('返回失败:', error);
                alert('返回失败：' + error.message);
            }
        });
        
        console.log('用户主页返回按钮事件绑定成功！');
        
    }, 1000);
});

// ======================================================
// 【修复】用户主页设置按钮 - 完全独立版本
// ======================================================
document.addEventListener('DOMContentLoaded', function() {
    // 等待页面完全加载后再绑定
    setTimeout(() => {
        const settingsBtn = document.querySelector('#user-profile-settings-btn');
        
        if (!settingsBtn) {
            console.error('找不到设置按钮！');
            return;
        }
        
        console.log('设置按钮已找到，正在绑定事件...');
        
        // 移除可能存在的旧事件监听器
        const newBtn = settingsBtn.cloneNode(true);
        settingsBtn.parentNode.replaceChild(newBtn, settingsBtn);
        
        // 绑定点击事件
        newBtn.addEventListener('click', async function(e) {
            console.log('设置按钮被点击了！');
            e.preventDefault();
            e.stopPropagation();
            
            try {
                const settingsScreen = document.querySelector('.user-profile-settings-screen');
                
                if (!settingsScreen) {
                    alert('错误：找不到设置页面元素！');
                    return;
                }
                
                // 强制移动到 body 下
                if (settingsScreen.parentElement !== document.body) {
                    document.body.appendChild(settingsScreen);
                }
                
                // 强制设置样式
                settingsScreen.style.cssText = `
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    z-index: 99999999 !important;
                    background-color: #f0f0f0 !important;
                    display: flex !important;
                    flex-direction: column !important;
                    overflow-y: auto !important;
                `;
                
                // 加载当前设置
                const profile = await db.settings.get('myMomentsProfile');
                if (profile && profile.value) {
                    const nicknameInput = document.querySelector('#profile-settings-nickname-input');
                    const signatureInput = document.querySelector('#profile-settings-signature-input');
                    const avatarPreview = document.querySelector('#profile-settings-avatar-preview');
                    
                    if (nicknameInput) nicknameInput.value = profile.value.nickname || '';
                    if (signatureInput) signatureInput.value = profile.value.signature || '';
                    
                    if (profile.value.avatarFileKey && avatarPreview) {
                        const avatarFile = await db.files.get(profile.value.avatarFileKey);
                        if (avatarFile) {
                            avatarPreview.src = URL.createObjectURL(avatarFile.file);
                        }
                    }
                }
                
                // 隐藏用户主页
                const userProfileScreen = document.querySelector('.user-profile-screen');
                if (userProfileScreen) {
                    userProfileScreen.classList.add('hidden');
                }
                
                // 显示设置页面
                settingsScreen.classList.remove('hidden');
                
           
                
            } catch (error) {
                console.error('打开设置页面失败:', error);
                alert('打开失败：' + error.message);
            }
        });
        
        console.log('设置按钮事件绑定成功！');
        
    }, 1000); // 延迟1秒确保所有元素都加载完成
});
// ======================================================
// 【修复】头像预览
// ======================================================
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const avatarInput = document.querySelector('#profile-settings-avatar-input');
        if (avatarInput) {
            avatarInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        const preview = document.querySelector('#profile-settings-avatar-preview');
                        if (preview) {
                            preview.src = ev.target.result;
                        }
                    };
                    reader.readAsDataURL(file);
                }
            });
        }
    }, 1000);
});

// ======================================================
// 【修复】保存按钮
// ======================================================
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const saveBtn = document.querySelector('#profile-settings-save-btn');
        if (saveBtn) {
            saveBtn.addEventListener('click', async function() {
                try {
                    const nicknameInput = document.querySelector('#profile-settings-nickname-input');
                    const signatureInput = document.querySelector('#profile-settings-signature-input');
                    const avatarInput = document.querySelector('#profile-settings-avatar-input');
                    const coverInput = document.querySelector('#profile-settings-cover-input');
                    
                    const nickname = nicknameInput ? nicknameInput.value.trim() || '我' : '我';
                    const signature = signatureInput ? signatureInput.value.trim() : '';
                    
                    let profileData = {
                        nickname: nickname,
                        signature: signature
                    };
                    
                    // 保存头像
                    if (avatarInput && avatarInput.files[0]) {
                        const fileKey = 'my_moments_avatar_' + Date.now();
                        await db.files.put({ key: fileKey, file: avatarInput.files[0] });
                        profileData.avatarFileKey = fileKey;
                    } else {
                        const oldProfile = await db.settings.get('myMomentsProfile');
                        if (oldProfile && oldProfile.value && oldProfile.value.avatarFileKey) {
                            profileData.avatarFileKey = oldProfile.value.avatarFileKey;
                        }
                    }
                    
                    // 保存背景墙
                    if (coverInput && coverInput.files[0]) {
                        const fileKey = 'my_moments_cover_' + Date.now();
                        await db.files.put({ key: fileKey, file: coverInput.files[0] });
                        profileData.backgroundFileKey = fileKey;
                    } else {
                        const oldProfile = await db.settings.get('myMomentsProfile');
                        if (oldProfile && oldProfile.value && oldProfile.value.backgroundFileKey) {
                            profileData.backgroundFileKey = oldProfile.value.backgroundFileKey;
                        }
                    }
                    
                    await db.settings.put({ key: 'myMomentsProfile', value: profileData });
                    
                    alert('保存成功！');
                    
                    const settingsScreen = document.querySelector('.user-profile-settings-screen');
                    if (settingsScreen) {
                        settingsScreen.classList.add('hidden');
                    }
                    
                    await openUserProfile();
                    
                } catch (error) {
                    console.error('保存失败:', error);
                    alert('保存失败：' + error.message);
                }
            });
        }
    }, 1000);
});

// ======================================================
// 【修复】返回按钮
// ======================================================
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const backBtn = document.querySelector('#profile-settings-back-btn');
        
        if (!backBtn) {
            console.error('找不到返回按钮！');
            return;
        }
        
        console.log('返回按钮已找到');
        
        // 移除旧的事件监听器（如果有）
        const newBackBtn = backBtn.cloneNode(true);
        backBtn.parentNode.replaceChild(newBackBtn, backBtn);
        
        // 绑定新的点击事件
        newBackBtn.addEventListener('click', function(e) {
            console.log('返回按钮被点击了！');
            e.preventDefault();
            e.stopPropagation();
            
            try {
                const settingsScreen = document.querySelector('.user-profile-settings-screen');
                const userProfileScreen = document.querySelector('.user-profile-screen');
                
                if (!settingsScreen) {
                    alert('错误：找不到设置页面！');
                    return;
                }
                
                if (!userProfileScreen) {
                    alert('错误：找不到用户主页！');
                    return;
                }
                
                // 隐藏设置页面
                settingsScreen.classList.add('hidden');
                settingsScreen.style.display = 'none';
                
                // 显示用户主页
                userProfileScreen.classList.remove('hidden');
                userProfileScreen.style.display = 'flex';
                
                // 确保用户主页的样式正确
                userProfileScreen.style.position = 'fixed';
                userProfileScreen.style.top = '0';
                userProfileScreen.style.left = '0';
                userProfileScreen.style.width = '100vw';
                userProfileScreen.style.height = '100vh';
                userProfileScreen.style.zIndex = '999999';
                
                console.log('已返回用户主页！');
                
            } catch (error) {
                console.error('返回失败:', error);
                alert('返回失败：' + error.message);
            }
        });
        
        console.log('返回按钮事件绑定成功！');
        
    }, 1000);
});

document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const clearBtn = document.querySelector('#profile-settings-cover-clear-btn');
        
        if (clearBtn) {
            clearBtn.addEventListener('click', async function(e) {
                console.log('清除背景按钮被点击');
                e.preventDefault();
                e.stopPropagation();
                
                try {
                    const profile = await db.settings.get('myMomentsProfile');
                    
                    if (profile && profile.value && profile.value.backgroundFileKey) {
                        if (confirm('确定要清除背景墙吗？')) {
                            await db.files.delete(profile.value.backgroundFileKey);
                            profile.value.backgroundFileKey = null;
                            await db.settings.put(profile);
                            alert('背景墙已清除！');
                        }
                    } else {
                        alert('当前没有背景墙！');
                    }
                    
                } catch (error) {
                    console.error('清除背景失败:', error);
                    alert('清除失败：' + error.message);
                }
            });
            
            console.log('清除背景按钮事件绑定成功！');
        }
    }, 1000);
});

// ======================================================
// 【新增】自动发朋友圈功能 - 事件监听
// ======================================================

// 1. 开关切换
const autoMomentToggle = document.querySelector('#contact-settings-auto-moment-toggle');
const intervalContainer = document.querySelector('#moment-interval-container');
const cooldownContainer = document.querySelector('#moment-cooldown-container');

if (autoMomentToggle) {
    autoMomentToggle.addEventListener('click', () => {
        const isActive = autoMomentToggle.classList.toggle('active');
        
        if (isActive) {
            intervalContainer.classList.remove('hidden');
            cooldownContainer.classList.remove('hidden');
        } else {
            intervalContainer.classList.add('hidden');
            cooldownContainer.classList.add('hidden');
        }
    });
}

// 2. 发布间隔滑块同步
const intervalSlider = document.querySelector('#contact-settings-moment-interval');
const intervalValue = document.querySelector('#contact-settings-moment-interval-value');

if (intervalSlider && intervalValue) {
    intervalSlider.addEventListener('input', () => {
        intervalValue.value = intervalSlider.value;
    });
    
    intervalValue.addEventListener('input', () => {
        let newValue = parseInt(intervalValue.value);
        if (newValue < 1) newValue = 1;
        if (newValue > 60) newValue = 60;
        if (isNaN(newValue)) newValue = 5;
        intervalValue.value = newValue;
        intervalSlider.value = newValue;
    });
}

// 3. 冷却时间滑块同步
const cooldownSlider = document.querySelector('#contact-settings-moment-cooldown');
const cooldownValue = document.querySelector('#contact-settings-moment-cooldown-value');

if (cooldownSlider && cooldownValue) {
    cooldownSlider.addEventListener('input', () => {
        cooldownValue.value = cooldownSlider.value;
    });
    
    cooldownValue.addEventListener('input', () => {
        let newValue = parseInt(cooldownValue.value);
        if (newValue < 1) newValue = 1;
        if (newValue > 120) newValue = 120;
        if (isNaN(newValue)) newValue = 10;
        cooldownValue.value = newValue;
        cooldownSlider.value = newValue;
    });
}

// ======================================================
// 【新增】发布动态 - 配图方式切换
// ======================================================
const imageModeRealBtn = document.querySelector('#image-mode-real');
const imageModeTextBtn = document.querySelector('#image-mode-text');
const realImageContainer = document.querySelector('#real-image-container');
const textImageContainer = document.querySelector('#text-image-container');

if (imageModeRealBtn && imageModeTextBtn && realImageContainer && textImageContainer) {
    // 点击"真实图片"按钮
    imageModeRealBtn.addEventListener('click', () => {
        currentImageMode = 'real';
        realImageContainer.classList.remove('hidden');
        textImageContainer.classList.add('hidden');
    });
    
    // 点击"文字描述"按钮
    imageModeTextBtn.addEventListener('click', () => {
        currentImageMode = 'text';
        realImageContainer.classList.add('hidden');
        textImageContainer.classList.remove('hidden');
    });
}

// 【新增】定时检测器 - 每分钟检查一次所有角色
setInterval(async () => {
    const contacts = await db.contacts.toArray();
    for (const contact of contacts) {
        if (contact.autoPostMoments) {
            await checkAndPostMoment(contact.id);
        }
    }
}, 60000); // 每60秒检查一次


 
//这是事件监听末尾//  
  </script>
    
 <!-- ======================================================= -->
<!-- 【新增】用户主页 -->
<!-- ======================================================= -->
<div class="user-profile-screen hidden">
   <nav class="theme-nav">
    <button id="user-profile-back-btn" class="back-btn">&lt;</button>
    <h2>个人主页</h2>
 <button id="user-profile-settings-btn" class="nav-action-btn" style="font-size: 14px;">设置</button>

</nav>
    
    <!-- 背景墙 + 头像区域 -->
    <div class="profile-header">
        <div class="profile-cover"></div>
        <div class="profile-avatar-section">
            <img id="profile-avatar-img" src="./assets/default-avatar.png" alt="头像" class="profile-avatar">
            <p class="profile-nickname">我</p>
          <p class="profile-signature"></p>

        </div>
    </div>
    
    <!-- 统计信息栏 -->
    <div class="profile-stats">
        <div class="stat-item">
            <span class="stat-number" id="profile-moments-count">0</span>
            <span class="stat-label">动态</span>
        </div>
        <div class="stat-item">
            <span class="stat-number" id="profile-likes-count">0</span>
            <span class="stat-label">获赞</span>
        </div>
    </div>
    
    <!-- 九宫格动态列表 -->
    <div class="profile-moments-grid" id="profile-moments-grid">
        <p class="empty-list-message">还没有发布动态哦~</p>
    </div>
  <!-- ======================================================= -->
<!-- 【新增】用户主页设置页面 -->
<!-- ======================================================= -->
<div class="user-profile-settings-screen hidden">
    <nav class="theme-nav">
        <button id="profile-settings-back-btn" class="back-btn">&lt;</button>
        <h2>编辑资料</h2>
    </nav>
    
    <div class="theme-content">
        <!-- 头像设置 -->
        <div class="setting-item" style="text-align: center; padding: 20px 0;">
            <img id="profile-settings-avatar-preview" src="./assets/default-avatar.png" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; border: 3px solid #eee;">
            <label for="profile-settings-avatar-input" class="file-label" style="background-color: rgba(0, 122, 255, 0.8); width: 150px; margin: 10px auto 0 auto; padding: 8px 0;">
                修改头像
            </label>
            <input type="file" id="profile-settings-avatar-input" accept="image/*" style="display: none;">
        </div>
        
        <!-- 背景墙设置 -->
        <div class="setting-item">
            <label>背景墙</label>
            <label for="profile-settings-cover-input" class="file-label" style="background-color: rgba(76, 217, 100, 0.8); margin: 0;">
                上传背景墙
            </label>
            <input type="file" id="profile-settings-cover-input" accept="image/*" style="display: none;">
            <button id="profile-settings-cover-clear-btn" class="btn-clear" style="width: 100%; margin-top: 10px; padding: 8px;">清除背景</button>
        </div>
        
        <!-- 昵称设置 -->
        <div class="setting-item">
            <label for="profile-settings-nickname-input">昵称</label>
            <input type="text" id="profile-settings-nickname-input" placeholder="输入昵称（默认：我）">
        </div>
        
        <!-- 个性签名设置 -->
        <div class="setting-item">
            <label for="profile-settings-signature-input">个性签名</label>
            <textarea id="profile-settings-signature-input" rows="3" placeholder="输入个性签名（可选）" style="width: calc(100% - 20px); padding: 10px; border: 1px solid #ccc; border-radius: 8px; resize: vertical;"></textarea>
        </div>
        
        <!-- 保存按钮 -->
        <div class="button-group" style="margin-top: 20px;">
            <button class="btn-save" id="profile-settings-save-btn" style="width: 100%; padding: 12px; font-size: 16px;">保存更改</button>
        </div>
    </div>
</div>

</div>
<!--这里是body的最下方，有需要添加的功能可以直接搜索，然后添加到这个注释的最上面-->
    
</body>
</html>